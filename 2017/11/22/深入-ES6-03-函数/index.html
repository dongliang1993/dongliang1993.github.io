<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>深入-ES6-03 函数 | 我是你豆子欧巴</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">深入-ES6-03 函数</h1><a id="logo" href="/.">我是你豆子欧巴</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">深入-ES6-03 函数</h1><div class="post-meta">Nov 22, 2017<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><p>函数在任何编程语言中都是非常重要的一部分，而从 JS 诞生起，一直到 ES6 之前，函数都未有较大的变化。这积压了诸多问题及细微行为差异，由此容易诱发错误，并且经常需要用大量代码来实现非常基本的功能。</p>
<p>ES6 的函数考虑了 JS 开发者多年的抱怨与诉求，大踏步前进，在 ES5 函数基础上实现了不少增量改进，让 JS 更加强大，同时编程错误也更少。</p>
<h2 id="带参数默认值的函数"><a href="#带参数默认值的函数" class="headerlink" title="带参数默认值的函数"></a>带参数默认值的函数</h2><p>JS 函数的独特之处是可以接受任意数量的参数，而无视函数声明处的形参数量。这让你定义的函数可以使用不同的参数数量来调用，而未提供的参数经常会使用默认值来代替。本章将介绍默认的参数值在 ES6 前后是如何实现的，顺带介绍的内容还有： arguments 对象的一些重要信息，将表达式作为参数使用，以及另一种形式的 TDZ 。</p>
<h2 id="在-ES5-中模拟参数默认值"><a href="#在-ES5-中模拟参数默认值" class="headerlink" title="在 ES5 中模拟参数默认值"></a>在 ES5 中模拟参数默认值</h2><p>在 ES5 或更早的版本中，你或许会使用以下模式来创建带有参数默认值的函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span>(<span class="params">url, timeout, callback</span>) </span>&#123;</span><br><span class="line">  timeout = timeout || <span class="number">2000</span></span><br><span class="line">  callback = callback || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 函数的剩余部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在本例中， timeout 与 callback 实际上都是可选参数，因为他们都会在参数未被提供的情况下使用默认值。逻辑或运算符（ || ） 在左侧的值为假值（falsy ） 的情况下总会返回右侧的操作数。由于函数的具名参数在未被明确提供时会是 undefined ，逻辑或运算符就经常被用来给缺失的参数提供默认值。不过此方法有个瑕疵，此处的 timeout 的有效值实际上有可能是 0 ，但因为 0 是假值，就会导致 timeout 的值在这种情况下被替换为 2000 。</p>
<p>在这种情况下，更安全的选择是使用 typeof 来检测参数的类型，正如下例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span>(<span class="params">url, timeout, callback</span>) </span>&#123;</span><br><span class="line">  timeout = (<span class="keyword">typeof</span> timeout !== <span class="string">"undefined"</span>) ? timeout : <span class="number">2000</span></span><br><span class="line">  callback = (<span class="keyword">typeof</span> callback !== <span class="string">"undefined"</span>) ? callback : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 函数的剩余部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>尽管这种方式更安全，却为实现一个基本需求而书写了过多的代码。它代表了一种常见模<br>式，充斥在各种流行的 JS 库中。</p>
<h2 id="ES6-中的参数默认值"><a href="#ES6-中的参数默认值" class="headerlink" title="ES6 中的参数默认值"></a>ES6 中的参数默认值</h2><p>ES6 能更容易地为参数提供默认值，它使用了初始化形式，以便在参数未被正式传递进来时<br>使用。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span>(<span class="params">url, timeout = <span class="number">2000</span>, callback = function(</span>) </span>&#123;&#125;) &#123;</span><br><span class="line"><span class="comment">// 函数的剩余部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此函数只要求始终提供第一个参数。其余两个参数则都有默认值，这就无需再添加更多代码<br>来检查缺失的参数值，让函数体更为小巧。</p>
<p>若完整使用三个参数来调用 makeRequest() ，那么默认值将不会被用到，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用默认的 timeout 与 callback</span></span><br><span class="line">makeRequest(<span class="string">"/foo"</span>)</span><br><span class="line"><span class="comment">// 使用默认的 callback</span></span><br><span class="line">makeRequest(<span class="string">"/foo"</span>, <span class="number">500</span>)</span><br><span class="line"><span class="comment">// 不使用默认值</span></span><br><span class="line">makeRequest(<span class="string">"/foo"</span>, <span class="number">500</span>, <span class="function"><span class="keyword">function</span>(<span class="params">body</span>) </span>&#123;</span><br><span class="line">  doSomething(body)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>ES6 会认为 url 参数是必须的，因此三次调用 makeRequest() 都必须传入 “/foo” 。拥有默认值的两个参数则都被认为是可选的。</p>
<p>在函数声明中能指定任意一个参数的默认值，即使之后还存在未指定默认值的参数。例如，下面这样是可行的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span>(<span class="params">url, timeout = <span class="number">2000</span>, callback</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 函数的剩余部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在本例中，只有在未传递第二个参数、或明确将第二个参数值指定为 undefined 时，timeout 的默认值才会被使用，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用默认的 timeout</span></span><br><span class="line">makeRequest(<span class="string">"/foo"</span>, <span class="literal">undefined</span>, <span class="function"><span class="keyword">function</span>(<span class="params">body</span>) </span>&#123;</span><br><span class="line">  doSomething(body);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 使用默认的 timeout</span></span><br><span class="line">makeRequest(<span class="string">"/foo"</span>);</span><br><span class="line"><span class="comment">// 不使用默认值</span></span><br><span class="line">makeRequest(<span class="string">"/foo"</span>, <span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params">body</span>) </span>&#123;</span><br><span class="line">  doSomething(body);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中， null 值被认为是有效参数，意味着对于 makeRequest() 的第三次调用并不会使用 timeout 的默认值。</p>
<h2 id="参数默认值如何影响-arguments-对象"><a href="#参数默认值如何影响-arguments-对象" class="headerlink" title="参数默认值如何影响 arguments 对象"></a>参数默认值如何影响 arguments 对象</h2><p>需要记住的是， arguments 对象会在使用参数默认值时有不同的表现。在 ES5 的非严格模式下， arguments 对象会反映出具名参数的变化。以下代码说明了该工作机制：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixArgs</span>(<span class="params">first, second</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">  first = <span class="string">"c"</span>;</span><br><span class="line">  second = <span class="string">"d"</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">mixArgs(<span class="string">"a"</span>, <span class="string">"b"</span>);</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>在非严格模式下， arguments 对象总是会被更新，以反映出具名参数的变化。因此当 first 与 second 变量被赋予新值时， arguments[0] 与 arguments[1] 也就相应被更新，让这里所有的 === 严格比较的结果都为 true 。</p>
<p>然而在 ES5 的严格模式下，消除了关于 arguments 对象的这种混乱情况，它不再反映出具名参数的变化。在严格模式下重新使用上例中的函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixArgs</span>(<span class="params">first, second</span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">  first = <span class="string">"c"</span>;</span><br><span class="line">  second = <span class="string">"d"</span></span><br><span class="line">  <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">mixArgs(<span class="string">"a"</span>, <span class="string">"b"</span>);</span><br></pre></td></tr></table></figure></p>
<p>调用 mixArgs() 则输出：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<p>这一次更改 first 与 second 就不会再影响 arguments 对象，因此输出结果符合通常的期望。</p>
<p>然而在使用 ES6 参数默认值的函数中，无论函数是否明确运行在严格模式下， arguments 对象的表现总是会与 ES5 的严格模式一致，参数默认值的存在触发了 arguments 对象与具名参数的分离。这是个细微但重要的细节，表示 arguments 对象的使用方式发生了变化。研究如下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非严格模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixArgs</span>(<span class="params">first, second = <span class="string">"b"</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);</span><br><span class="line">  <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">  first = <span class="string">"c"</span>;</span><br><span class="line">  second = <span class="string">"d"</span></span><br><span class="line">  <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">mixArgs(<span class="string">"a"</span>);</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<p>本例中 arguments.length 的值为 1 ，因为只给 mixArgs() 传递了一个参数。这也意味着 arguments[1] 的值是 undefined ，符合将单个参数传递给函数时的预期；这同时意味着 first 与 arguments[0] 是相等的。无论是否在严格模式下，改变 first 和 second 的值不会对 arguments 对象造成影响，所以 arguments 对象始终能映射出初始调用状态。</p>
<h2 id="参数默认值表达式"><a href="#参数默认值表达式" class="headerlink" title="参数默认值表达式"></a>参数默认值表达式</h2><p>参数默认值最有趣的特性，或许就是默认值并不非得是基本类型值。例如，你可以执行一个函数来产生参数的默认值，就像这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first, second = getValue(</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> first + second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure></p>
<p>此处若未提供第二个参数， getValue() 函数就会被调用以获取正确的默认值。需要注意的是，仅在调用 add() 函数而未提供第二个参数时， getValue() 函数才会被调用，而在 add() 的函数声明初次被解析时并不会进行调用。这意味着 getValue() 函数若被写为可变的，则默认参数获取的值有可能也会变化，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first, second = getValue(</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> first + second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure></p>
<p>本例中 value 的初始值是 5 ，并且会随着对 getValue() 的每次调用而递增。首次调用 add(1) 返回的值为 6 ，再次调用时 value 的值已被增加，于是返回了 7 。由于 second 参数的默认值总是在 add() 函数被调用的情况下才被计算，因此该参数的值随时都会被改变。</p>
<p>将函数调用作为参数的默认值时需要小心，如果你遗漏了括号，例如在上面例子中使用 second = getValue ，你就传递了对于该函数的一个引用，而没有传递调用该函数的结果</p>
<p>这种行为引出了另一种有趣的能力：可以将前面的参数作为后面参数的默认值，此处有个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first, second = first</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> first + second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<p>此代码中 first 为 second 参数提供了默认值，意味着只传入一个参数会让两个参数获得相同的值，因此 add(1, 1) 与 add(1) 同样返回了 2 。再进一步，你还能将 first 作为参数传递给一个函数来产生 second 参数的值，正如下例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value + <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first, second = getValue(first</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> first + second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure></p>
<p>此例将 second 的值设为等于 getValue(first) 函数的返回值，因此 add(1) 会返回 7 （1 + 6 ） ，而 add(1, 1) 仍然返回 2 。</p>
<p>引用其他参数来为参数进行默认赋值时，仅允许引用前方的参数，因此前面的参数不能向后访问，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first = second, second</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> first + second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="literal">undefined</span>, <span class="number">1</span>)); <span class="comment">// 抛出错误</span></span><br></pre></td></tr></table></figure></p>
<p>调用 add(undefined, 1) 发生了错误，这是由于 second 在 first 之后定义，因此不能将其作为后者的默认值。为了理解这种情况的成因，需着重回顾“暂时性死区”概念。</p>
<h2 id="参数默认值的暂时性死区"><a href="#参数默认值的暂时性死区" class="headerlink" title="参数默认值的暂时性死区"></a>参数默认值的暂时性死区</h2><p>第一章介绍了 let 与 const 的暂时性死区（TDZ ） ，而参数默认值同样具有暂时性死区。与 let 声明相似，函数每个参数都会创建一个新的标识符绑定，它在初始化之前不允许被访问，否则会抛出错误。参数初始化会在函数被调用时进行，无论是给参数传递了一个值、还是使用了参数的默认值。</p>
<p>为了探索参数默认值中的暂时性死区，可再次研究“参数默认值表达式”中的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value + <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first, second = getValue(first</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> first + second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure></p>
<p>调用 add(1, 1) 和 add(1) 事实上执行了以下代码来创建 first 与 second 的参数值：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JS 调用 add(1, 1) 可表示为</span></span><br><span class="line"><span class="keyword">let</span> first = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> second = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// JS 调用 add(1) 可表示为</span></span><br><span class="line"><span class="keyword">let</span> first = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> second = getValue(first);</span><br></pre></td></tr></table></figure></p>
<p>当函数 add() 第一次执行时， first 与 second 的绑定被加入了特定参数的暂时性死区（ 类似于 let 声明的行为） 。因此 second 可以使用 first 来初始化，因为此处 first已完成了初始化，但反之则不行。现在再研究以下重写过的 add() 函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first = second, second</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> first + second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="literal">undefined</span>, <span class="number">1</span>)); <span class="comment">// 抛出错误</span></span><br></pre></td></tr></table></figure></p>
<p>本例中调用 add(1, 1) 与 add(undefined, 1) 对应着以下的后台代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JS 调用 add(1, 1) 可表示为</span></span><br><span class="line"><span class="keyword">let</span> first = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> second = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// JS 调用 add(1) 可表示为</span></span><br><span class="line"><span class="keyword">let</span> first = second;</span><br><span class="line"><span class="keyword">let</span> second = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>本例中调用 add(undefined, 1) 抛出了错误，是因为在对 first 进行初始化时， second 尚未被初始化。此处的 second 位于暂时性死区内，对 second 的引用就抛出了错误，正如第一章讨论过的 let 绑定的行为。</p>
<p>函数参数拥有各自的作用域和暂时性死区，与函数体的作用域相分离，这意味着参数的默认值不允许访问在函数体内部声明的任意变量。</p>
<h2 id="使用不具名参数"><a href="#使用不具名参数" class="headerlink" title="使用不具名参数"></a>使用不具名参数</h2><p>到目前为止，本章的例子只涵盖了在函数定义中的已被命名的参数。然而 JS 的函数并不强求参数的数量要等于已定义具名参数的数量，实际所传递的参数允许少于或多于正式指定的参数。参数的默认值让函数在接收更少参数时的行为更清晰，而 ES6 试图让相反情况的问题也被更好地解决。</p>
<h2 id="ES5-中的不具名参数"><a href="#ES5-中的不具名参数" class="headerlink" title="ES5 中的不具名参数"></a>ES5 中的不具名参数</h2><p>JS 早就提供了 arguments 对象用于查看传递给函数的所有参数，这样就不必分别指定每个参数。虽然查看 arguments 对象在大多数情况下都工作正常，但操作它有时仍然较为麻烦。例如，参考以下查看 arguments 对象的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  <span class="comment">// 从第二个参数开始处理</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">    result[<span class="built_in">arguments</span>[i]] = object[<span class="built_in">arguments</span>[i]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> book = &#123;</span><br><span class="line">  title: <span class="string">"Understanding ES6"</span>,</span><br><span class="line">  author: <span class="string">"Nicholas C. Zakas"</span>,</span><br><span class="line">  year: <span class="number">2015</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bookData = pick(book, <span class="string">"author"</span>, <span class="string">"year"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bookData.author); <span class="comment">// "Nicholas C. Zakas"</span></span><br><span class="line"><span class="built_in">console</span>.log(bookData.year); <span class="comment">// 2015</span></span><br></pre></td></tr></table></figure></p>
<p>此函数模拟了 Underscore.js 代码库的 pick() 方法，能够返回包含原有对象特定属性的子集副本。本例中只为函数定义了一个期望参数，也就是拷贝属性的来源对象，除此之外传递的所有参数则都是需要拷贝的属性的名称。</p>
<p>这个 pick() 函数有两点需要注意。首先，完全看不出该函数具备处理多个参数的能力，就算为其再多定义几个参数，但依然不足以标明它能处理任意数量的参数。其次，由于第一个参数被命名并被直接使用，当你寻找需要复制的属性时，就必须从 arguments 对象索引位置 1 而非位置 0 开始处理。要记住使用 arguments 的适当索引值或许不困难，但毕竟多了一件挂心之事。</p>
<p>ES6 引入了剩余参数以便解决此问题。</p>
<h2 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h2><p>剩余参数（rest parameter ） 由三个点（ … ） 与一个紧跟着的具名参数指定，它是包含传递给函数的其余参数的一个数组，由此得名“剩余”。例如， pick() 函数可以像下面这样用剩余参数来重写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">object, ...keys</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = keys.length; i &lt; len; i++) &#123;</span><br><span class="line">    result[keys[i]] = object[keys[i]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在此版本的函数中， keys 是一个剩余参数，包含所有在 object 之后的参数，这与囊括所有参数的 arguments 不同，后者连第一个参数都会包含。这意味着你无需有所顾虑，可以对 keys 从头到尾进行迭代。作为一个额外的收益，通过观察该函数声明便能判明它具有处理任意数量参数的能力。</p>
<p>函数的 length 属性用于指示具名参数的数量，而剩余参数对其毫无影响。此例中 pick() 函数的 length 属性值是 1 ，因为只有 object 参数被用于计算该值。</p>
<p>译注：这种说法并不严谨。若函数使用了默认参数，则 length 属性不包含使用默认值的参数，并且它只能指示出第一个默认参数之前的具名参数数量。例如对于<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params">first, second = <span class="string">'woo'</span>, third</span>) </span>&#123;&#125; <span class="comment">// length = 1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example2</span>(<span class="params">first, third</span>) </span>&#123;&#125; <span class="comment">// length = 2</span></span><br></pre></td></tr></table></figure></p>
<p>函数声明来说， length 的值是 1 而非 2，尽管这里有两个无默认值的具名参数。</p>
<h2 id="剩余参数的限制条件"><a href="#剩余参数的限制条件" class="headerlink" title="剩余参数的限制条件"></a>剩余参数的限制条件</h2><p>剩余参数受到两点限制。一是函数只能有一个剩余参数，并且它必须被放在最后。例如，如下代码是无法工作的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法错误：不能在剩余参数后使用具名参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">object, ...keys, last</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = keys.length; i &lt; len; i++) &#123;</span><br><span class="line">    result[keys[i]] = object[keys[i]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此处的 last 跟在了剩余参数 keys 后面，这会导致一个语法错误。</p>
<p>第二个限制是剩余参数不能在对象字面量的 setter 属性中使用，这意味着如下代码同样会导致语法错误：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line">  <span class="comment">// 语法错误：不能在 setter 中使用剩余参数</span></span><br><span class="line">  set name(...value) &#123;</span><br><span class="line">  <span class="comment">// 一些操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>存在此限制的原因是：对象字面量的 setter 被限定只能使用单个参数；而剩余参数按照定义是不限制参数数量的，因此它在此处不被许可。</p>
<h2 id="剩余参数如何影响-arguments-对象"><a href="#剩余参数如何影响-arguments-对象" class="headerlink" title="剩余参数如何影响 arguments 对象"></a>剩余参数如何影响 arguments 对象</h2><p>设计剩余参数是为了替代 ES 中的 arguments 对象。 ES4 曾经移除了 arguments 并添加了剩余参数，以便允许向函数传入不限数量的参数。尽管 ES4 规范被废弃，但这个想法被保持下来，并在 ES6 中被重新引入，不过 arguments 仍得以保留。</p>
<p>arguments 对象在函数被调用时反映了传入的参数，与剩余参数能协同工作，就像如下程序所演示的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkArgs</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(args.length);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);</span><br><span class="line">  <span class="built_in">console</span>.log(args[<span class="number">0</span>], <span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(args[<span class="number">1</span>], <span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">checkArgs(<span class="string">"a"</span>, <span class="string">"b"</span>);</span><br></pre></td></tr></table></figure></p>
<p>调用 checkArgs() 输出了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line">a a</span><br><span class="line">b b</span><br></pre></td></tr></table></figure></p>
<p>arguments 对象总能正确反映被传入函数的参数，而无视剩余参数的使用。</p>
<h2 id="函数构造器的增强"><a href="#函数构造器的增强" class="headerlink" title="函数构造器的增强"></a>函数构造器的增强</h2><p>Function 构造器允许你动态创建一个新函数，但在 JS 中并不常用。传给该构造器的参数都是字符串，它们就是目标函数的参数与函数体，此处有个范例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"first"</span>, <span class="string">"second"</span>, <span class="string">"return first + second"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<p>ES6 增强了 Function 构造器的能力，允许使用默认参数以及剩余参数。对于默认参数来说，你只需为参数名称添加等于符号以及默认值，正如下例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"first"</span>, <span class="string">"second = first"</span>,</span><br><span class="line"><span class="string">"return first + second"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<p>在此例中，当只传递了一个参数时， first 的值会被赋给 second 参数，此处的语法与不使用 Function 的函数声明一致。</p>
<p>而对剩余参数来说，只需在最后一个参数前添加 … 即可，就像这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pickFirst = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"...args"</span>, <span class="string">"return args[0]"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(pickFirst(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p>此代码创建了一个仅使用剩余参数的函数，让其返回所传入的第一个参数。<br>为 Function 构造器添加默认参数与剩余参数，确保了它拥有与函数声明形式相同的所有能力。</p>
<h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><p>与剩余参数关联最密切的就是扩展运算符。剩余参数允许你把多个独立的参数合并到一个数组中；而扩展运算符则允许将一个数组分割，并将各个项作为分离的参数传给函数。考虑一下 Math.max() 方法，它接受任意数量的参数，并会返回其中的最大值。此处有个简单用例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value1 = <span class="number">25</span>,</span><br><span class="line">    value2 = <span class="number">50</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(value1, value2)); <span class="comment">// 50</span></span><br></pre></td></tr></table></figure></p>
<p>若像本例这样仅处理两个值，那么仅需将这两个值直接传入 Math.max() ，较大的那个就会成为返回值。但如何处理数组中的多个值呢？ Math.max() 方法并不允许你传入一个数组，因此在 ES5 或更早版本中，要么自行搜索整个数组，要么像下面这样使用 apply() 方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">25</span>, <span class="number">50</span>, <span class="number">75</span>, <span class="number">100</span>]</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, values)); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure></p>
<p>该解决方案是可行的，但这样使用 apply() 会稍微令人疑惑，它使用额外语法而混淆了代码的真实意图。</p>
<p>ES6 的扩展运算符令这种情况变得简单。无须调用 apply() ，你可以在该数组前添加 … 并直接将其传递给 Math.max() ，就像使用剩余参数那样。 JS 引擎将会将该数组分割为独立参数并把它们传递进去：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">25</span>, <span class="number">50</span>, <span class="number">75</span>, <span class="number">100</span>]</span><br><span class="line"><span class="comment">// 等价于 console.log(Math.max(25, 50, 75, 100));</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...values)); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure></p>
<p>如此调用 Math.max() 更接近传统形式，并避免了为一个简单数学操作使用复杂的 this 绑定（ 即在上个例子中提供给 Math.max.apply() 的第一个参数） 。</p>
<p>你可以将扩展运算符与其他参数混用。假设你想让 Math.max() 返回的最小值为 0 ，以忽略数组内的负值，可以将参数 0 单独传入，并继续为其他参数使用扩展运算符，正如下例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">-25</span>, <span class="number">-50</span>, <span class="number">-75</span>, <span class="number">-100</span>]</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...values, <span class="number">0</span>)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></p>
<p>本例中传给 Math.max() 的最后一个参数是 0 ，它跟在使用扩展运算符的其他参数之后。用扩展运算符传递参数，让函数更容易用数组作为参数，在大部分场景中，扩展运算符都是 apply() 方法的合适替代品。</p>
<p>关于 ES6 中的默认参数与剩余参数，除了你至今看到的用法之外，还可以在 Function 构造器中使用它们。</p>
<h2 id="ES6-的名称属性"><a href="#ES6-的名称属性" class="headerlink" title="ES6 的名称属性"></a>ES6 的名称属性</h2><p>定义函数有各种各样的方式，在 JS 中识别函数因此变得很有挑战性。此外，匿名函数表达式的流行使得调试有点困难，经常导致堆栈跟踪难以被阅读与解释。为此， ES6 给所有函数添加了 name 属性。</p>
<h2 id="选择合适的名称"><a href="#选择合适的名称" class="headerlink" title="选择合适的名称"></a>选择合适的名称</h2><p>ES6 中所有函数都有适当的 name 属性值。为了理解其实际运作，请看下例——它展示了一个函数与一个函数表达式，并将二者的 name 属性都打印出来：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> doAnotherThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(doSomething.name); <span class="comment">// "doSomething"</span></span><br><span class="line"><span class="built_in">console</span>.log(doAnotherThing.name); <span class="comment">// "doAnotherThing</span></span><br></pre></td></tr></table></figure></p>
<p>在此代码中，由于 doSomething() 是一个函数声明，它就拥有一个值为 “doSomething” 的 name 属性。而匿名函数表达式 doAnotherThing() 的 name 属性值则是 “doAnotherThing”，因为这是该函数所赋值的变量的名称。</p>
<p>译注：匿名函数的名称属性在 FireFox 与 Edge 中仍然不被支持，值为空字符串，而 Chrome 直到 51.0 版本才提供了该特性。</p>
<h2 id="名称属性的特殊情况"><a href="#名称属性的特殊情况" class="headerlink" title="名称属性的特殊情况"></a>名称属性的特殊情况</h2><p>虽然函数声明与函数表达式的名称易于确定，但 ES6 还做了更多规定以确保所有函数都拥有合适的名称。为了表明这点，请参考如下程序：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span> <span class="title">doSomethingElse</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  get firstName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Nicholas"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(doSomething.name); <span class="comment">// "doSomethingElse"</span></span><br><span class="line"><span class="built_in">console</span>.log(person.sayName.name); <span class="comment">// "sayName"</span></span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">"firstName"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.get.name); <span class="comment">// "get firstName"</span></span><br></pre></td></tr></table></figure></p>
<p>本例中的 doSomething.name 的值是 “doSomethingElse” ，因为该函数表达式自己拥有一个名称，并且此名称的优先级要高于赋值目标的变量名。 person.sayName() 的 name 属性值是 “sayName” ，正如对象字面量指定的那样。类似的， person.firstName 实际是个 getter 函数，因此它的名称是 “get firstName” ，以标明它的特征；同样， setter 函数也会带有 “set” 的前缀（getter 与 setter 函数都必须用 Object.getOwnPropertyDescriptor() 来检索） 。</p>
<p>函数名称还有另外两个特殊情况。使用 bind() 创建的函数会在名称属性值之前带有 “bound” 前缀；而使用 Function 构造器创建的函数，其名称属性为 “anonymous” ，正如此例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(doSomething.bind().name); <span class="comment">// "bound doSomething"</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="keyword">new</span> <span class="built_in">Function</span>()).name); <span class="comment">// "anonymous"</span></span><br></pre></td></tr></table></figure></p>
<p>绑定产生的函数拥有原函数的名称，并总会附带 “bound” 前缀，因此 doSomething() 函数的绑定版本的名称为 “bound doSomething” 。</p>
<p>需要注意的是，函数的 name 属性值未必会关联到同名变量。 name 属性是为了在调试时获得有用的相关信息，所以不能用 name 属性值去获取对函数的引用。</p>
<h2 id="明确函数的双重用途"><a href="#明确函数的双重用途" class="headerlink" title="明确函数的双重用途"></a>明确函数的双重用途</h2><p>在 ES5 以及更早版本中，函数根据是否使用 new 去调用而有双重用途。当使用 new 时，函数内部的 this 是一个新对象，并作为函数的返回值，如下例所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>);</span><br><span class="line"><span class="keyword">var</span> notAPerson = Person(<span class="string">"Nicholas"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// "[Object object]"</span></span><br><span class="line"><span class="built_in">console</span>.log(notAPerson); <span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure></p>
<p>当调用 Person() 来创建 notAPerson 时，未使用 new ，输出了 undefined ，并且在非严格模式下给全局对象添加了 name 属性。 Person 首字母大写是指示其应当使用 new 来调用的唯一标识，这在 JS 编程中是个惯例。函数双重角色的混乱情况在 ES6 中发生了一些改变</p>
<p>JS 为函数提供了两个不同的内部方法： [[Call]] 与 [[Construct]] 。当未使用 new 进行函数调用时， [[Call]] 方法会被执行，运行的是代码中的函数体。而当使用 new 进行函数调用时， [[Construct]] 方法则会被执行，负责创建一个被称为新目标的新对象，并且将该新目标作为 this 去执行函数体。拥有 [[Construct]] 方法的函数被称为构造器。</p>
<p>切记并非所有函数都拥有 [[Construct]] 方法，因此不是所有函数都可以用 new 去调用。在后面会介绍的箭头函数就是个例外。</p>
<h2 id="在-ES5-中判断函数如何被调用"><a href="#在-ES5-中判断函数如何被调用" class="headerlink" title="在 ES5 中判断函数如何被调用"></a>在 ES5 中判断函数如何被调用</h2><p>在 ES5 中判断是否使用了 new 去调用函数（ 即作为构造器） ，最流行的方式是使用 instanceof ，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="string">'this'</span>)</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name; <span class="comment">// 使用 new</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"You must use new with Person."</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>);</span><br><span class="line"><span class="keyword">var</span> notAPerson = Person(<span class="string">"Nicholas"</span>); <span class="comment">// 抛出错误</span></span><br></pre></td></tr></table></figure></p>
<p>此处对 this 值进行了检查，来判断其是否为构造器的一个实例：若是，正常继续执行；否则抛出错误。这么做能奏效是因为 [[Construct]] 方法创建了 Person 的一个新实例并将其赋值给 this 。可惜该方法并不绝对可靠，因为有时未使用 new 但 this 仍然可能是 Person 的实例，正如下例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name; <span class="comment">// 使用 new</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"You must use new with Person."</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>);</span><br><span class="line"><span class="keyword">var</span> notAPerson = Person.call(person, <span class="string">"Michael"</span>); <span class="comment">// 奏效了！</span></span><br></pre></td></tr></table></figure></p>
<p>调用 Person.call() 并将 person 变量作为第一个参数传入，这意味着将 Person 内部的 this 被设置为了 person 。对于该函数来说，没任何办法能将这种方式与使用 new 调用区分开来。</p>
<h2 id="new-target-元属性"><a href="#new-target-元属性" class="headerlink" title="new.target 元属性"></a>new.target 元属性</h2><p>为了解决这个问题， ES6 引入了 new.target 元属性。元属性指的是“非对象”（ 例如 new 运算符） 上的属性，并提供关联目标的附加信息。当函数的 [[Construct]] 方法被调用时，new 运算符的作用目标会填入 new.target 元属性，此时函数体内部的 this 值是新创建的对象实例，而 new.target 的值正是该实例的构造器。而若 [[Call]] 被执行， new.target 的值将会是 undefined 。</p>
<p>通过检查 new.target 这个新的元属性是否被定义，就能让你安全地判断函数被调用时是否使用了 new 。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span>.target, <span class="string">'new.target)</span></span><br><span class="line"><span class="string">  if (typeof new.target !== "undefined") &#123;</span></span><br><span class="line"><span class="string">    this.name = name; // 使用 new</span></span><br><span class="line"><span class="string">  &#125; else &#123;</span></span><br><span class="line"><span class="string">    throw new Error("You must use new with Person.")</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">var person = new Person("Nicholas");</span></span><br><span class="line"><span class="string">var notAPerson = Person.call(person, "Michael"); // 出错！</span></span><br></pre></td></tr></table></figure></p>
<p>使用 new.target 而非 this instanceof Person ， Person 构造器会在未使用 new 时正确地抛出错误。</p>
<p>也可以检查 new.target 来判断是否使用特定构造器进行了调用，例如以下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">new</span>.target === Person) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target)</span><br><span class="line">    <span class="keyword">this</span>.name = name; <span class="comment">// 使用 new</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"You must use new with Person."</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AnotherPerson</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>);</span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="keyword">new</span> AnotherPerson(<span class="string">"Nicholas"</span>); <span class="comment">// 出错！</span></span><br></pre></td></tr></table></figure></p>
<p>在此代码中，为了正确工作， new.target 必须是 Person 。当调用 new<br>AnotherPerson(“Nicholas”) 时， Person.call(this, name) 也随之被调用，从而抛出了错误，因为此时在 Person 构造器内部的 new.target 值为 undefined （ 调用 Person 时并未使用 new ） 。</p>
<p>警告：在函数之外使用 new.target 会导致语法错误。</p>
<p>ES6 通过新增 new.target 而消除了函数调用方式的不确定性。在此方面 ES6 还随之解决了语言此前另一个不确定的部分——在代码块内部声明函数。</p>
<h2 id="块级函数"><a href="#块级函数" class="headerlink" title="块级函数"></a>块级函数</h2><p>在 ES3 或更早版本中，在代码块中声明函数（ 即块级函数） 严格来说应当是一个语法错误，但所有的浏览器却都支持该语法。可惜每个浏览器都有轻微的行为差异，所以最佳实践就是切勿在代码块中声明函数，更好的选择是使用函数表达式。</p>
<p>为了控制这种不兼容行为， ES5 的严格模式为代码块内部的函数声明引入了一种错误，就像这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// 在 ES5 会抛出语法错误， ES6 则不会</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 ES5 中，这段代码会抛出语法错误。不过 ES6 会将 doSomething() 函数视为块级声明，并允许它在声明所在的代码块内部被访问。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSomething); <span class="comment">// "function"</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  doSomething();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSomething); <span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure></p>
<p>块级函数会被提升到所在代码块的顶部，因此 typeof doSomething 会返回 “function” ，即便该检查位于此函数定义位置之前。一旦 if 代码块执行完毕， doSomething() 也就不复存在。</p>
<h2 id="决定何时使用块级函数"><a href="#决定何时使用块级函数" class="headerlink" title="决定何时使用块级函数"></a>决定何时使用块级函数</h2><p>块级函数与 let 函数表达式相似，在执行流跳出定义所在的代码块之后，函数定义就会被移除。关键区别在于：块级函数会被提升到所在代码块的顶部；而使用 let 的函数表达式则不会，正如以下范例所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSomething); <span class="comment">// 抛出错误</span></span><br><span class="line">  <span class="keyword">let</span> doSomething = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  doSomething();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSomething);</span><br></pre></td></tr></table></figure></p>
<p>此处代码在 typeof doSomething 被执行时中断了，因为 let 声明尚未被执行，doSomething() 位于暂时性死区。了解这个区别之后，就能根据是否想要提升，来选择应当使用块级函数还是 let 表达式。</p>
<h2 id="非严格模式的块级函数"><a href="#非严格模式的块级函数" class="headerlink" title="非严格模式的块级函数"></a>非严格模式的块级函数</h2><p>ES6 在非严格模式下同样允许使用块级函数，但行为有细微不同。块级函数的作用域会被提升到所在函数或全局环境的顶部，而不是代码块的顶部。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6 behavior</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSomething); <span class="comment">// "function"</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  doSomething();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSomething); <span class="comment">// "function"</span></span><br></pre></td></tr></table></figure></p>
<p>本例中的 doSomething() 会被提升到全局作用域，因此在 if 代码块外部它仍然存在。 ES6标准化了这种行为，以便移除浏览器此前存在的不兼容性，于是在所有 ES6 运行环境中其行为都会遵循相同的方式。</p>
<p>允许使用块级函数只是增强了在 JS 中声明函数的能力，但 ES6 还引入了一种全新的函数声明方式。</p>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>ES6 最有趣的一个新成分便是箭头函数（arrow function ） 。箭头函数正如名称所示那样使用一个“箭头”（ =&gt; ） 来定义，但它的行为在很多重要方面与传统的 JS 函数不同：</p>
<ol>
<li><p>没有 this 、 super 、 arguments ，也没有 new.target 绑定： this 、 super 、arguments 、以及函数内部的 new.target 的值由外层最近的非箭头函数来决定（ super 详见第四章） 。</p>
</li>
<li><p>不能使用 new 去调用：箭头函数没有 [[Construct]] 方法，因此不能被用为构造函数，使用 new 调用箭头函数会抛出错误。</p>
</li>
<li><p>没有原型： 既然不能对箭头函数使用 new ，那么它也不需要原型，也就是没有prototype 属性。</p>
</li>
<li><p>不能更改 this ： this 的值在函数内部不能被修改，在函数的整个生命周期内其值会保持不变。</p>
</li>
<li><p>没有 arguments 对象：箭头函数没有 arguments 绑定，你必须依赖于具名参数或剩余参数来访问函数的参数。</p>
</li>
<li><p>不允许重复的具名参数：箭头函数不允许拥有重复的具名参数，无论是否在严格模式下；而相对来说，传统函数只有在严格模式下才禁止这种重复。</p>
</li>
</ol>
<p>产生这些差异是有理由的。首先并且最重要的是，在 JS 编程中 this 绑定是发生错误的常见根源之一，在嵌套的函数中有时会因为调用方式的不同，而导致丢失对外层 this 值的追踪，就可能会导致预期外的程序行为。其次，箭头函数使用单一的 this 值来执行代码，使得 JS 引擎可以更容易对代码的操作进行优化；而常规函数可能会作为构造函数使用，导致this 易变而不利优化。</p>
<p>其余差异也聚集在减少箭头函数内部的错误与不确定性，这样 JS 引擎也能更好地优化箭头函数的运行。</p>
<p>注意：箭头函数也拥有 name 属性，并且遵循与其他函数相同的规则</p>
<h2 id="箭头函数语法"><a href="#箭头函数语法" class="headerlink" title="箭头函数语法"></a>箭头函数语法</h2><p>箭头函数的语法可以有多种变体，取决于你要完成的目标。所有变体都以函数参数为开头，紧跟着的是箭头，再接下来则是函数体。参数与函数体都根据实际使用有不同的形式。例如，以下箭头函数接收单个参数并直接返回它：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reflect = <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line"><span class="comment">// 基本等价于：</span></span><br><span class="line"><span class="keyword">var</span> reflect = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当箭头函数只有单个参数时，该参数可以直接书写而不需要额外的语法；接下来是箭头以及箭头右边的表达式，该表达式会被计算并返回结果。即使此处没有明确的 return 语句，该箭头函数仍然会将所传入的参数返回出来。</p>
<p>如果需要传入多于一个的参数，就需要将它们放在括号内，就像这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class="line"><span class="comment">// 基本等价于：</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>sum() 函数简单地将两个参数相加并返回结果。此箭头函数与上面的 reflect() 之间唯一区别在于：此处的参数被封闭在括号内，相互之间使用逗号分隔，就像传统函数那样。</p>
<p>如果函数没有任何参数，那么在声明时就必须使用一对空括号，就像这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">"Nicholas"</span>;</span><br><span class="line"><span class="comment">// 基本等价于：</span></span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Nicholas"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当你想使用更传统的函数体、也就是可能包含多个语句的时候，需要将函数体用一对花括号进行包裹，并明确定义一个返回值，正如下面这个版本的 sum() ：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 基本等价于：</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>除了 arguments 对象不可用之外，几乎可将花括号内部的代码当做传统函数那样对待。若你想创建一个空函数，就必须使用空的花括号，就像这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doNothing = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// 基本等价于：</span></span><br><span class="line"><span class="keyword">var</span> doNothing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>花括号被用于表示函数的主体，它在你至今看到的例子中都工作正常。但若要箭头函数向外返回一个对象字面量，就必须将该字面量包裹在圆括号内，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">"Temp"</span> &#125;);</span><br><span class="line"><span class="comment">// 基本等价于：</span></span><br><span class="line"><span class="keyword">var</span> getTempItem = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    id: id,</span><br><span class="line">    name: <span class="string">"Temp"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>将对象字面量包裹在括号内，标示了括号内是一个字面量而不是函数体。</p>
<h2 id="创建立即调用函数表达式"><a href="#创建立即调用函数表达式" class="headerlink" title="创建立即调用函数表达式"></a>创建立即调用函数表达式</h2><p>JS 中使用函数的一种流行方式是创建立即调用函数表达式（immediately-invoked function expression ， IIFE ） 。 IIFE 允许你定义一个匿名函数并在未保存引用的情况下立刻调用它。</p>
<p>当你想创建一个作用域并与程序其他部分相隔离时，这种模式就很有用。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;(<span class="string">"Nicholas"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.getName()); <span class="comment">// "Nicholas"</span></span><br></pre></td></tr></table></figure></p>
<p>此代码中 IIFE 被用于创建一个包含 getName() 方法的对象。该方法使用 name 参数作为返回值，实际上让 name 成为所返回对象的一个私有成员。</p>
<p>你可以使用箭头函数来完成同样的事情，只要将其包裹在括号内即可：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="function">(<span class="params">(name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)(<span class="string">"Nicholas"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.getName()); <span class="comment">// "Nicholas"</span></span><br></pre></td></tr></table></figure></p>
<p>需要注意的是括号仅包裹了箭头函数的定义，并未包裹 (“Nicholas”) 。使用传统函数时，括号既可以连函数定义与参数调用一起包裹，也可以只用于包裹函数定义，箭头函数与此有别。</p>
<p>译注：使用传统函数时， (function(){/<em>函数体</em>/})(); 与 (function(){/<em>函数体</em>/}());<br>这两种方式都是可行的。但若使用箭头函数，则只有下面的写法是有效的： (() =&gt; {/<em>函数体</em>/})();</p>
<h2 id="没有-this-绑定"><a href="#没有-this-绑定" class="headerlink" title="没有 this 绑定"></a>没有 this 绑定</h2><p>JS 最常见的错误领域之一就是在函数内的 this 绑定。由于一个函数内部的 this 值会根据调用该函数时的上下文而改变，因此完全可能违背本意地影响了预期外的对象。研究如下例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> PageHandler = &#123;</span><br><span class="line">  id: <span class="string">"123456"</span>,</span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的 this 是 PageHandler</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="string">'first'</span>)</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 这里的 this 是 document</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="string">'secont'</span>)</span><br><span class="line">      <span class="keyword">this</span>.doSomething(event.type); <span class="comment">// 错误</span></span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  doSomething: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Handling "</span> + type + <span class="string">" for "</span> + <span class="keyword">this</span>.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>此代码的 PageHandler 对象被设计用于处理页面上的交互。调用 init() 方法以建立交互，并注册了一个事件处理函数来调用 this.doSomething() 。然而此代码并未按预期工作。</p>
<p>此处的 this 是对事件目标对象（ 也就是 document ） 的一个引用，而没有绑定到 PageHandler 上，因此调用 this.doSomething() 会被中断。若试图运行此代码，你将会在事件处理函数被触发时得到一个错误，因为 document 对象并不存在 doSomething() 方法。</p>
<p>你可以明确使用 bind() 方法将函数的 this 值绑定到 PageHandler 上，以修正这段代码，就像这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> PageHandler = &#123;</span><br><span class="line">  id: <span class="string">"123456"</span>,</span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>, (<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.doSomething(event.type); <span class="comment">// 没有错误</span></span><br><span class="line">    &#125;).bind(<span class="keyword">this</span>), <span class="literal">false</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  doSomething: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Handling "</span> + type + <span class="string">" for "</span> + <span class="keyword">this</span>.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>现在此代码能像预期那样运行，但看起来有点奇怪。通过调用 bind(this) ，你实际上创建了一个新函数，它的 this 被绑定到当前 this ，也就是 PageHandler 。为了避免额外创建一个函数，修正此代码的更好方式是使用箭头函数。</p>
<p>箭头函数没有 this 绑定，意味着箭头函数内部的 this 值只能通过查找作用域链来确定。如果箭头函数被包含在一个非箭头函数内，那么 this 值就会与该函数的相等；否则，this 值就会是全局对象（ 在浏览器中是 window ，在 nodejs 中是 global ） 。你可以使用箭头函数来书写如下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> PageHandler = &#123;</span><br><span class="line">  id: <span class="string">"123456"</span>,</span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>, event =&gt; <span class="keyword">this</span>.doSomething(event.type), <span class="literal">false</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  doSomething: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Handling "</span> + type + <span class="string">" for "</span> + <span class="keyword">this</span>.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>本例中的事件处理函数是一个调用 this.doSomething() 的箭头函数，它的 this 值与 init() 方法的相同，因此这个版本的代码的工作方式与使用了 bind(this) 的上个例子相似。尽管 doSomething() 方法并不返回任何值，它仍然是函数体内唯一被执行的语句，因此无需使用花扩花来包裹它。</p>
<p>箭头函数被设计为“抛弃型”的函数，因此不能被用于定义新的类型； prototype 属性的缺失让这个特性显而易见。对箭头函数使用 new 运算符会导致错误，正如下例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyType = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,</span><br><span class="line">object = <span class="keyword">new</span> MyType(); <span class="comment">// 错误：你不能对箭头函数使用 'new'</span></span><br></pre></td></tr></table></figure></p>
<p>由于 MyType() 是一个箭头函数，它就不存在 [[Construct]] 方法，此代码调用 newMyType() 的操作也因此失败。了解箭头函数不能被用于 new 的特性后， JS 引擎就能进一步对其进行优化。</p>
<p>同样，由于箭头函数的 this 值由包含它的函数决定，因此不能使用 call() 、 apply()或 bind() 方法来改变其 this 值。</p>
<h2 id="箭头函数与数组"><a href="#箭头函数与数组" class="headerlink" title="箭头函数与数组"></a>箭头函数与数组</h2><p>箭头函数的简洁语法也让它成为进行数组操作的理想选择。例如，若你想使用自定义比较器来对数组进行排序，通常会这么写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = values.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这里为一个非常简单的工序使用了过多代码，可以比较一下使用了箭头函数的更简洁版本：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = values.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br></pre></td></tr></table></figure></p>
<p>能使用回调函数的数组方法，例如 sort() 、 map() 与 reduce() 方法，都能从箭头函数的简洁语法中获得收益，它用简单的代码实现看似复杂的需求。</p>
<h2 id="没有-arguments-绑定"><a href="#没有-arguments-绑定" class="headerlink" title="没有 arguments 绑定"></a>没有 arguments 绑定</h2><p>尽管箭头函数没有自己的 arguments 对象，但仍然能访问包含它的函数的 arguments 对象。无论此后箭头函数在何处执行，该对象都是可用的。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArrowFunctionReturningFirstArg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arrowFunction = createArrowFunctionReturningFirstArg(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arrowFunction()); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></p>
<p>在 createArrowFunctionReturningFirstArg() 内部， arguments[0] 元素被已创建的箭头函数 arrowFunction 所引用，该引用包含了传递给 createArrowFunctionReturningFirstArg() 函数的首个参数。当箭头函数在此后被执行时，它返回了 5 ，正是传递给createArrowFunctionReturningFirstArg() 的首个参数。尽管箭头函数 arrowFunction 已不在创建它的函数的作用域内，但由于 arguments 标识符的作用域链解析，当时的 arguments 对象依然可被访问。</p>
<h2 id="识别箭头函数"><a href="#识别箭头函数" class="headerlink" title="识别箭头函数"></a>识别箭头函数</h2><p>尽管语法不同，但箭头函数依然属于函数，并能被照常识别。研究如下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> comparator = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> comparator); <span class="comment">// "function"</span></span><br><span class="line"><span class="built_in">console</span>.log(comparator <span class="keyword">instanceof</span> <span class="built_in">Function</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>console.log() 的输出揭示了 typeof 与 instanceof 在作用于箭头函数时的行为，与作用在其他函数上完全一致。</p>
<p>就像对待其他函数那样，你仍然可以对箭头函数使用 call() 、 apply() 与 bind() 方法，只是箭头函数的 this 绑定并不会受影响。这里有几个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class="line"><span class="built_in">console</span>.log(sum.call(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(sum.apply(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>])); <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">var</span> boundSum = sum.bind(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(boundSum()); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<p>sum() 函数被使用 call() 与 apply() 方法调用并传入了参数。 bind() 方法被用于创建 boundSum() ，后者的两个参数已被绑定为 1 与 2 ，因此调用时不再需要传入这两个参数。</p>
<p>箭头函数能在任意位置，包括使用回调函数时，替代你当前使用的匿名函数。下一节介绍的内容是 ES6 的另一项主要改进，不过该内容完全是内部实现，并没有使用新语法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>函数在 ES6 中并未经历巨大变化，然而一系列增量改进使得函数更易使用。</p>
<p>在特定参数未被传入时，函数的默认参数允许你更容易指定需要使用的值。而在 ES6 之前，为了检查参数是已否已提供，并在未提供时为其分配一个预设值，需要在函数内书写一些额外代码。</p>
<p>剩余参数允许你将余下的所有参数放入指定数组。使用真正的数组，并可以根据需要指定包含哪些参数，让剩余参数成为比 arguments 更为灵活的解决方案。</p>
<p>扩展运算符是剩余参数的好伙伴，允许在调用函数时将数组解构为分离的参数。在 ES6 之前，要将数组的元素用作独立参数传给函数只有两种办法：手动指定每一个参数，或者使用apply() 方法。有了扩展运算符，你就能轻易将数组传递给函数而无须顾虑该函数的 this绑定。</p>
<p>新增的 name 属性让你在调试与执行方面能更容易地识别函数。此外， ES6 正式定义了块级函数的行为，因此在严格模式下它们不再是语法错误。</p>
<p>在 ES6 中，函数的行为被 [[Call]] 与 [[Construct]] 方法所定义，前者对应普通的函数执行，后者则对应着使用了 new 的调用。 new.target 元属性也能用于判断函数被调用时是否使用了 new 。</p>
<p>ES6 函数的最大变化就是增加了箭头函数。箭头函数被设计用于替代匿名函数表达式，它拥有更简洁的语法、词法级的 this 绑定，并且没有 arguments 对象。此外，箭头函数不能修改它们的 this 绑定，因此不能被用作构造器。、</p>
<p>尾调用优化允许某些函数的调用被优化，以保持更小的调用栈、使用更少的内存，并防止堆栈溢出。当能进行安全优化时，它会由引擎自动应用。不过你可以考虑重写递归函数，以便利用这种优化。</p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2017/11/22/笔记/">笔记</a><a class="next" href="/2017/11/21/深入-ES6-03-Promise-与异步编程/">深入-ES6-03 Promise 与异步编程</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/js/" style="font-size: 15px;">js</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/05/14/一条前端咸鱼在杭州两年的总结/">一条前端咸鱼在杭州两年的总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/23/【笔记】事件/">【笔记】事件</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/12/面向对象编程-笔记/">面向对象编程 -- 笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/12/同源策略-笔记/">同源策略--笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/12/history对象-笔记/">history 对象 -- 笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/11/前端路由浅解析/">前端路由浅解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/24/react-基础知识/">react 基础知识</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/07/js-设计模式笔记/">js 设计模式笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/06/promise-笔记/">promise 笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/06/Flex-布局笔记/">Flex 布局笔记</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://miaoyuxinbaby.github.io/" title="yui" target="_blank">yui</a><ul></ul><a href="http://www.ruhook.com/" title="肥宅七六" target="_blank">肥宅七六</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">我是你豆子欧巴.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>