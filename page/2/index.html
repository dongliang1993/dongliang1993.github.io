<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">















  <link rel="alternate" href="/default" title="我是你豆子欧巴">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0" />



<link rel="canonical" href="http://yoursite.com/page/2/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />






  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









    <title> 我是你豆子欧巴 </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">我是你豆子欧巴</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">我是你豆子欧巴</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/12/12/深入-ES6-04-扩展的对象功能/">深入-ES6-04 扩展的对象功能</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-12-12
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>ES6 注重于提高对象的效用，这是因为在 JS 中几乎所有的值都是某种类型的对象。此外，随着 JS 应用复杂度的增长，在 JS 程序中所使用的对象的平均数也在持续增长，因此更有效使<br>用对象就变得更加必要。</p>
<p>ES6 在对象的许多方面都进行了改进，从简单的语法扩展，到操作与交互。</p>
<h2 id="对象类别"><a href="#对象类别" class="headerlink" title="对象类别"></a>对象类别</h2><p>相对于那些由浏览器或 Node.js 之类运行环境所添加的对象， JS 使用混合术语来描述在标准中的对象， ES6 规范明确定义了对象的每种类别。理解对象术语对于从整体上清楚认识这门<br>语言来说非常重要。对象类别包括：</p>
<ol>
<li>普通对象：拥有 JS 对象所有默认的内部行为。</li>
<li>奇异对象：其内部行为在某些方面有别于默认行为。</li>
<li>标准对象：在 ES6 中被定义的对象，例如 Array 、 Date ，等等。标准对象可以是普<br>通的，也可以是奇异的。</li>
<li>内置对象：脚本在 JS 运行环境中开始运行时可用的对象。所有的标准对象都是内置对<br>象。</li>
</ol>
<p>我会在整本书中使用这些术语来讲解在 ES6 中定义的各种对象</p>
<h2 id="对象字面量语法的扩展"><a href="#对象字面量语法的扩展" class="headerlink" title="对象字面量语法的扩展"></a>对象字面量语法的扩展</h2><p>对象字面量是 JS 中最流行的模式之一，它存在于互联网上的几乎所有 JS 文件中， JSON 就<br>是基于这种语法。对象字面量如此流行，是因为它能用简洁语法创建对象，避免了书写冗余<br>代码。对开发者来说幸运的是， ES6 用几种方式扩展了对象字面量，让这种语法变得更强大<br>也更简洁。</p>
<h3 id="属性初始化器的速记法"><a href="#属性初始化器的速记法" class="headerlink" title="属性初始化器的速记法"></a>属性初始化器的速记法</h3><p>在 ES5 及更早版本中，对象字面量是简单的“键/值对”集合。这意味着初始化属性值的代码可<br>能会有些重复，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    age: age</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>createPerson() 函数创建了一个对象，其属性名与函数的参数名相同。这看起来重复了<br>name 与 age ，尽管左侧是对象属性的名称，而右侧则负责给属性提供值。返回对象的<br>name 键与 age 键分别被变量 name 与 age 变量所赋值。</p>
<p>在 ES6 中，你可以使用属性初始化器的速记法来消除对象名称与本地变量名的重复情况。当对象的一个属性名称与本地变量名相同时，可以简单书写名称而省略冒号与值。例如，<br>createPerson() 能用 ES6 这样重写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">    age</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当对象字面量中的属性只有名称时， JS 引擎会在周边作用域查找同名变量。若找到，该变量的值将会被赋给对象字面量的同名属性。在本例中，局部变量 name 的值就被赋给了 name<br>属性。</p>
<p>这个扩展让对象字面量的初始化更加简洁，也有助于消除命名错误。用局部变量为对象同名属性赋值在 JS 中是极其常见的模式，因此这个扩展自然非常受欢迎</p>
<h3 id="方法简写"><a href="#方法简写" class="headerlink" title="方法简写"></a>方法简写</h3><p>ES6 同样改进了为对象字面量方法赋值的语法。在 ES5 及更早版本中，你必须指定一个名称并用完整的函数定义来为对象添加方法，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Nicholas"</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过省略冒号与 function 关键字， ES6 将这个语法变得更简洁，这意味着你可以这样重写上个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Nicholas"</span>,</span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这种速记语法也被称为方法简写语法（concise method syntax ） ，与上例一样在 person对象中创建了一个方法。 sayName() 属性被一个匿名函数所赋值，并且具备 ES5 版本的 sayName() 方法的所有特征。但有一点区别是：方法简写能使用 super ，而非简写的方法则不能（ super 会在后面的小节中讨论） 。</p>
<p>使用方法简写速记法创建的方法，其 name 属性就是括号之前的名称。上面这个例子中， person.sayName() 的名称属性就是 “sayName” 。</p>
<h3 id="可计算属性名"><a href="#可计算属性名" class="headerlink" title="可计算属性名"></a>可计算属性名</h3><p>在 ES5 及更早版本中，对象实例能使用“可计算的属性名”，只要用方括号表示法来代替小数点表示法即可。方括号允许你指定变量或字符串字面量为属性名，并且在字符串中允许存在<br>不能用于标识符的特殊字符。此处有个范例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;,</span><br><span class="line">    lastName = <span class="string">"last name"</span>;</span><br><span class="line"></span><br><span class="line">person[<span class="string">"first name"</span>] = <span class="string">"Nicholas"</span>;</span><br><span class="line">person[lastName] = <span class="string">"Zakas"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">"first name"</span>]); <span class="comment">// "Nicholas"</span></span><br><span class="line"><span class="built_in">console</span>.log(person[lastName]); <span class="comment">// "Zakas"</span></span><br></pre></td></tr></table></figure></p>
<p>lastName 变量的值为 “last name” ，这样该例中两个属性名都包含了空格，这种情况是无法使用小数点表示法的，而方括号表示法允许将任意字符串用作属性名。最终 “first name”<br>与 “last name” 属性分别被赋值为 “Nicholas” 与 “Zakas” 。</p>
<p>此外，你可以在对象字面量中直接使用字符串字面量作为属性，就像这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="string">"first name"</span>: <span class="string">"Nicholas"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">"first name"</span>]); <span class="comment">// "Nicholas"</span></span><br></pre></td></tr></table></figure></p>
<p>这种模式要求属性名事先已知、并且能用字符串字面量表示。然而，若属性名被包含在变量中（ 就像前面例子中的 “first name” ） ，或者必须通过计算才能获得，那么在 ES5 中就无<br>法为对象字面量定义这种属性。</p>
<p>在 ES6 中，可计算属性名是对象字面量语法的一部分，它用的也是方括号表示法，与此前在对象实例上的用法一致。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lastName = <span class="string">"last name"</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="string">"first name"</span>: <span class="string">"Nicholas"</span>,</span><br><span class="line">  [lastName]: <span class="string">"Zakas"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">"first name"</span>]); <span class="comment">// "Nicholas"</span></span><br><span class="line"><span class="built_in">console</span>.log(person[lastName]); <span class="comment">// "Zakas"</span></span><br></pre></td></tr></table></figure></p>
<p>对象字面量内的方括号表明该属性名需要计算，其结果是一个字符串。这意味着其中可以包含表达式，像下面这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> suffix = <span class="string">" name"</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  [<span class="string">"first"</span> + suffix]: <span class="string">"Nicholas"</span>,</span><br><span class="line">  [<span class="string">"last"</span> + suffix]: <span class="string">"Zakas"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">"first name"</span>]); <span class="comment">// "Nicholas"</span></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">"last name"</span>]); <span class="comment">// "Zakas"</span></span><br></pre></td></tr></table></figure></p>
<p>这些属性名被计算为 “first name” 与 “last name” ，而这两个字符串此后可以用来引用对应属性。使用了方括号表示法，任何能放在对象实例方括号内的东西，都可以作为可计算属<br>性名用在对象字面量中。</p>
<h2 id="新的方法"><a href="#新的方法" class="headerlink" title="新的方法"></a>新的方法</h2><p>从 ES5 开始就有这么一个设计意图：避免创建新的全局函数，避免在 Object 对象的原型上添加新方法，而尽量尝试将新方法添加到合适对象上。不过，当新方法不适用于其他任何对<br>象时，全局的 Object 对象就会收到越来越多的方法。 ES6 也在 Object 对象上引入了两个新方法，以便让特定任务更易完成。</p>
<h3 id="Object-is-方法"><a href="#Object-is-方法" class="headerlink" title="Object.is() 方法"></a>Object.is() 方法</h3><p>在 JS 中当要比较两个值时，你可能会使用相等运算符（ == ） 或严格相等运算符（ === ） 。为了避免在比较时发生强制类型转换，许多开发者更倾向于使用后者。但严格相等运算<br>符也并不完全准确，例如，它认为 +0 与 -0 相等，尽管这两者在 JS 引擎中有不同的表示；另外 NaN === NaN 会返回 false ，因此只有用 isNaN() 函数才能正确检测 NaN 。</p>
<p>ES6 引入了 Object.is() 方法来弥补严格相等运算符残留的怪异缺陷。此方法接受两个参数，并会在二者类型相同并且值也相等相等时返回 true 。此处有个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> == <span class="number">-0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === <span class="number">-0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> == <span class="number">5</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> == <span class="string">"5"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> === <span class="number">5</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> === <span class="string">"5"</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">5</span>, <span class="number">5</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">5</span>, <span class="string">"5"</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>绝大多数情况下， Object.is() 的结果与 === 运算符是相同的，仅有的例外是：它会认为+0 与 -0 不相等，而且 NaN 等于 NaN 。但没必要停止使用严格相等运算符，选择 Object.is() 还是选择 == 或 === ，取决于代码的实际需求。</p>
<h3 id="Object-assign-方法"><a href="#Object-assign-方法" class="headerlink" title="Object.assign() 方法"></a>Object.assign() 方法</h3><p>混入（Mixin ） 是在 JS 中组合对象时最流行的模式。在一次混入中，一个对象会从另一个对象中接收属性与方法。很多 JS 的库中都有类似下面这样的混入方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixin</span>(<span class="params">receiver, supplier</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.keys(supplier).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    receiver[key] = supplier[key];</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> receiver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>mixin() 函数在 supplier 对象的自有属性上进行迭代，并将这些属性复制到 receiver 对象（ 浅复制，当属性值为对象时，仅复制其引用） 。这样 receiver 对象就能获得新的属性<br>而无须使用继承，正如下面代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventTarget</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">EventTarget.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: EventTarget,</span><br><span class="line">  emit: function() &#123; <span class="comment">/*...*/</span> &#125;,</span><br><span class="line">  on: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;;</span><br><span class="line">mixin(myObject, EventTarget.prototype);</span><br><span class="line">myObject.emit(<span class="string">"somethingChanged"</span>);</span><br></pre></td></tr></table></figure></p>
<p>此处 myObject 对象接收了 EventTarget.prototype 对象的行为，获得了使用 emit() 方法来发布事件、使用 on() 来订阅事件的能力。</p>
<p>此模式非常流行，于是 ES6 也添加了 Object.assign() 方法来完成同样的行为。该方法接受一个接收者对象，以及任意数量的源对象，并会返回接收者对象。由于像前面这样的 mixin() 函数使用了赋值运算符（ = ） ，也就无法将访问器属性复制到接收者上，而assign() 更能反映出实际发生的操作，因此 mixin() 这个名称被弃用了。</p>
<p>各式各样的库中都有相似但名称不同的方法，流行的有 extend() 或 mix() ，其基本功能都相同。而 ES6 草案除了 Object.assign() 之外，也曾短暂存在一个 Object.mixin() 方法，二者的主要差异在于 Object.mixin() 也会复制访问器属性。但考虑到 super 的使用，此方法最终被移除了（ 本章后面小节会介绍 super ） 。</p>
<p>你可以在任意曾使用 mixin() 函数的地方使 Object.assign() ，此处有个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventTarget</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">EventTarget.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: EventTarget,</span><br><span class="line">  emit: function() &#123; <span class="comment">/*...*/</span> &#125;,</span><br><span class="line">  on: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(myObject, EventTarget.prototype);</span><br><span class="line">myObject.emit(<span class="string">"somethingChanged"</span>);</span><br></pre></td></tr></table></figure></p>
<p>Object.assign() 方法接受任意数量的源对象，而接收对象会按照源对象在参数中的顺序来依次接收它们的属性。这意味着在接收对象中，后面源对象的属性可能会覆盖前面的，下面代码片段中就有这种情况：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> receiver = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(receiver,</span><br><span class="line">  &#123;</span><br><span class="line">    type: <span class="string">"js"</span>,</span><br><span class="line">    name: <span class="string">"file.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    type: <span class="string">"css"</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="built_in">console</span>.log(receiver.type); <span class="comment">// "css"</span></span><br><span class="line"><span class="built_in">console</span>.log(receiver.name); <span class="comment">// "file.js"</span></span><br></pre></td></tr></table></figure></p>
<p>receiver.type 的值为 “css” ，这是因为第二个源对象覆盖了第一个源对象的值。</p>
<p>Object.assign() 方法并不是 ES6 的一项重大扩展，但它确实把很多 JS 库中存在的一个公共方法标准化了。</p>
<h3 id="操作访问器属性"><a href="#操作访问器属性" class="headerlink" title="操作访问器属性"></a>操作访问器属性</h3><p>切记 Object.assign() 不能将源对象的访问器属性复制到接收对象中，由于它使用了赋值运算符，源对象的访问器属性就会转变成接收对象的数据属性，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> receiver = &#123;&#125;,</span><br><span class="line">supplier = &#123;</span><br><span class="line">  get name() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"file.js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(receiver, supplier);</span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(receiver, <span class="string">"name"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.value); <span class="comment">// "file.js"</span></span><br><span class="line"><span class="built_in">console</span>.log(descriptor.get); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p>
<p>此代码中的 supplier 对象拥有一个名为 name 的访问器属性。在使用Object.assign() 方法时， supplier.name 返回的值是 “file.js” ，于是该值就被存储<br>到 receiver.name 数据属性上。</p>
<h2 id="重复的对象字面量属性"><a href="#重复的对象字面量属性" class="headerlink" title="重复的对象字面量属性"></a>重复的对象字面量属性</h2><p>ES5 严格模式为重复的对象字面量属性引入了一个检查，存在重复的属性名时会抛出错误。例如，以下代码就有问题：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Nicholas"</span>,</span><br><span class="line">  name: <span class="string">"Greg"</span> <span class="comment">// 在 ES5 严格模式中是语法错误</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在 ES5 严格模式下运行时，第二个 name 属性会造成语法错误。但 ES6 移除了重复属性的检查，无论是否严格模式，都不再进行检查。当存在重复属性时，排在后面的属性的值会成<br>为该属性的实际值，如下所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Nicholas"</span>,</span><br><span class="line">  name: <span class="string">"Greg"</span> <span class="comment">// 在 ES6 严格模式中不会出错</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// "Greg"</span></span><br></pre></td></tr></table></figure></p>
<p>在本例中， person.name 的值为 “Greg” ，因为这是赋给该属性的最后一个值。</p>
<h2 id="自有属性的枚举顺序"><a href="#自有属性的枚举顺序" class="headerlink" title="自有属性的枚举顺序"></a>自有属性的枚举顺序</h2><p>ES5 并没有定义对象属性的枚举顺序，而是将该问题留给了 JS 引擎厂商。 ES6 则严格定义了对象自有属性在被枚举时的返回顺序。这影响了 Object.getOwnPropertyNames() 与<br>Reflect.ownKeys （ 详见第十二章） 返回属性的方式，也同样影响了 Object.assign() 处理属性的顺序。</p>
<p>自有属性枚举时基本顺序如下：</p>
<ol>
<li><p>所有的数字类型键，按升序排列。</p>
</li>
<li><p>所有的字符串类型键，按被添加到对象的顺序排列。</p>
</li>
<li><p>所有的符号类型（ 详见第六章） 键，也按添加顺序排列。</p>
</li>
</ol>
<p>此处有个示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">  c: <span class="number">1</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">1</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line">obj.d = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(obj).join(<span class="string">""</span>)); <span class="comment">// "012acbd"</span></span><br></pre></td></tr></table></figure></p>
<p>Object.getOwnPropertyNames() 方法按 0 、 1 、 2 、 a 、 c 、 b 、 d 的顺序返回了 obj 对象的属性。注意，数值类型的键不会遵循在对象字面量中的顺序，而会被合并及<br>排序。字符串类型的键会跟在数值类型的键之后，按照被添加到 obj 对象的顺序，在对象字面量中定义的键会首先出现，接下来是此后动态添加到对象的键。</p>
<p>对于 for-in 循环，并非所有的 JS 引擎都采用相同的处理方式，其枚举顺序仍未被明确规定。而 Object.keys() 和 JSON.stringify() 也使用了与 for-in 一样的枚举顺<br>序。</p>
<p>虽然枚举顺序的变动对 JS 的工作方式影响甚小，但依赖于特定枚举顺序才能正确运行的程序并不罕见。 ES6 通过规定枚举的顺序，就确保了依赖枚举操作的 JS 代码无论在什么运行环<br>境中都能正常工作。</p>
<h2 id="更强大的原型"><a href="#更强大的原型" class="headerlink" title="更强大的原型"></a>更强大的原型</h2><p>原型是在 JS 中进行继承的基础， ES6 则继续强化原型。早期的 JS 版本对原型的使用有严重限制，然而随着语言的成熟，开发者也越来越熟悉原型的工作机制，因此他们明确希望能对原型有更多控制权、并能更方便地使用它。于是 ES6 就给原型引入了一些改进。</p>
<h3 id="修改对象的原型"><a href="#修改对象的原型" class="headerlink" title="修改对象的原型"></a>修改对象的原型</h3><p>一般来说，对象的原型会在通过构造器或 Object.create() 方法创建对象时被指定。 JS 编程到 ES5 为止最重要的假定之一就是：对象的原型在初始化完成后会保持不变。 ES5 添加了 Object.getPrototypeOf() 方法来获取任意指定对象的原型，不过仍然缺少在初始化之后更改对象原型的标准方法。</p>
<p>ES6 通过添加 Object.setPrototypeOf() 方法而改变了这种假定。此方法允许你修改任意指定对象的原型，它接受两个参数：需要被修改原型的对象，以及将会成为前者原型的对象。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  getGreeting() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">  getGreeting() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Woof"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 原型为 person</span></span><br><span class="line"><span class="keyword">let</span> friend = <span class="built_in">Object</span>.create(person);</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting()); <span class="comment">// "Hello"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === person); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 将原型设置为 dog</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, dog);</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting()); <span class="comment">// "Woof"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === dog); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>此代码定义了两个基础对象： person 与 dog ，二者都拥有一个名为 getGreeting() 的方法，用于返回一个字符串。 friend 对象起初继承了 person 对象，意味着 friend.getGreeting() 方法会输出 “Hello” ；当它的原型被更改为 dog 对象，与 person 的关联就被破坏， friend.getGreeting() 方法会改而输出 “Woof” 。</p>
<p>对象原型的实际值被存储在一个内部属性 [[Prototype]] 上， Object.getPrototypeOf() 方法会返回此属性存储的值，而 Object.setPrototypeOf() 方法则能够修改该值。不过，使用<br>[[Prototype]] 属性的方式还不止这些。</p>
<p>###使用 super 引用的简单原型访问</p>
<p>正如前面所提到的，原型对 JS 来说非常重要，而 ES6 也进行了很多工作来让它更易用。关于原型的另一项进步就是引入了 super 引用，这样就能更轻易地在对象原型上进行功能调用。例如，若要覆盖对象实例的一个方法，但依然想调用原型上的同名方法，你可能会这么做：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  getGreeting() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">  getGreeting() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Woof"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">  getGreeting() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">this</span>).getGreeting.call(<span class="keyword">this</span>) + <span class="string">", hi!"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 将原型设置为 person</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, person);</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting()); <span class="comment">// "Hello, hi!"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === person); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 将原型设置为 dog</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, dog);</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting()); <span class="comment">// "Woof, hi!"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === dog); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>本例中 friend 上的 getGreeting() 调用了对象上的同名方法。 Object.getPrototypeOf() 方法确保了能调用正确的原型，并在其返回结果上附加了一个字符串；之后的 call(this) 则能确保正确设置原型方法内部的 this 值。</p>
<p>调用原型上的方法时，要牢记使用 Object.getPrototypeOf() 与 .call(this) ，实在有点复杂，因此 ES6 才引入了 super 。简单来说， super 是指向当前对象的原型的一个指针，实际上就是 Object.getPrototypeOf(this) 的值。了解这些后，你就可以像下面这样简化getGreeting() 方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">  getGreeting() &#123;</span><br><span class="line">    <span class="comment">// 这相当于上个例子中的：</span></span><br><span class="line">    <span class="comment">// Object.getPrototypeOf(this).getGreeting.call(this)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getGreeting() + <span class="string">", hi!"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>此处调用 super.getGreeting() 等同于在上例的环境中使用Object.getPrototypeOf(this).getGreeting.call(this) 。类似的，你能使用 super 引用来调用对象原型上的任何方法，只要这个引用是位于简写的方法之内。试图在方法简写之外的情况使用 super 会导致语法错误，正如下例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">  getGreeting: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 语法错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getGreeting() + <span class="string">", hi!"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>此例使用了一个匿名函数作为属性，于是调用 super.getGreeting() 就导致了语法错误，因为在这种上下文中 super 是不可用的。</p>
<p>当使用多级继承时， Object.getPrototypeOf() 不再适用于所有场景，此时 super 引用就能体现出它的强大。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  getGreeting() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型为 person</span></span><br><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">  getGreeting() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">this</span>).getGreeting.call(<span class="keyword">this</span>) + <span class="string">", hi!"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, person);</span><br><span class="line"><span class="comment">// 原型为 friend</span></span><br><span class="line"><span class="keyword">let</span> relative = <span class="built_in">Object</span>.create(friend);</span><br><span class="line"><span class="built_in">console</span>.log(person.getGreeting()); <span class="comment">// "Hello"</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting()); <span class="comment">// "Hello, hi!"</span></span><br><span class="line"><span class="built_in">console</span>.log(relative.getGreeting()); <span class="comment">// error!</span></span><br></pre></td></tr></table></figure></p>
<p>使用 Object.getPrototypeOf() ，在调用 relative.getGreeting() 时发生了错误。这是因为此时 this 的值是 relative ，而 relative 的原型是 friend 对象，这样 friend.getGreeting().call() 调用就会导致进程开始反复进行递归调用，直到发生堆栈错误。</p>
<p>此问题在 ES5 中很难解决，但若使用 ES6 的 super ，就很简单了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  getGreeting() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型为 person</span></span><br><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">  getGreeting() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getGreeting() + <span class="string">", hi!"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, person);</span><br><span class="line"><span class="comment">// 原型为 friend</span></span><br><span class="line"><span class="keyword">let</span> relative = <span class="built_in">Object</span>.create(friend);</span><br><span class="line"><span class="built_in">console</span>.log(person.getGreeting()); <span class="comment">// "Hello"</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting()); <span class="comment">// "Hello, hi!"</span></span><br><span class="line"><span class="built_in">console</span>.log(relative.getGreeting()); <span class="comment">// "Hello, hi!"</span></span><br></pre></td></tr></table></figure></p>
<p>由于 super 引用并非是动态的，它总是能指向正确的对象。在本例中，<br>super.getGreeting() 总是指向 person.getGreeting() ，而不管有多少对象继承了此方法。</p>
<h2 id="正式的“方法”定义"><a href="#正式的“方法”定义" class="headerlink" title="正式的“方法”定义"></a>正式的“方法”定义</h2><p>在 ES6 之前，“方法”的概念从未被正式定义，它此前仅指对象的函数属性而非数据属性。ES6 则正式将方法定义为：一个拥有 [[HomeObject]] 内部属性的函数，此内部属性指向该方法所属的对象。研究以下例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="comment">// 方法</span></span><br><span class="line">  getGreeting() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并非方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shareGreeting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hi!"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此例定义了拥有单个 getGreeting() 方法的 person 对象。由于 getGreeting() 被直接赋给了一个对象，它的 [[HomeObject]] 属性值就是 person 。 而另一方面， shareGreeting() 函数被创建时并没有赋给一个对象，它就不具备 [[HomeObject]] 属性。这种差异在大多数情况下并不重要，然而使用 super 引用时就完全不同了。</p>
<p>任何对 super 的引用都会使用 [[HomeObject]] 属性来判断要做什么。第一步是在 [[HomeObject]] 上调用 Object.getPrototypeOf() 来获取对原型的引用；接下来，在该原型上查找同名函数；最后，创建 this 绑定并调用该方法。此处有个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  getGreeting() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型为 person</span></span><br><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">  getGreeting() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getGreeting() + <span class="string">", hi!"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, person);</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting()); <span class="comment">// "Hello, hi!"</span></span><br></pre></td></tr></table></figure></p>
<p>调用 friend.getGreeting() 返回了一个字符串，即 person.getGreeting() 的返回值与 “, hi!” 的拼接结果。此时 friend.getGreeting() 的 [[HomeObject]] 值是 friend ，并且<br>friend 的原型是 person ，因此 super.getGreeting() 就等价于<br>person.getGreeting.call(this) 。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对象是 JS 编程的核心， ES6 对它进行了一些正面改进，让它更易用也更强大。</p>
<p>ES6 为对象字面量做了几个改进。若要将作用域内的变量赋值给对象的同名属性，使用属性定义速记法能简化代码；可计算属性名允许你将非字面量的值指定为属性的名称，类似于此前在其他场合的用法；方法简写让你在对象字面量中定义方法时能省略冒号和 function 关键字，从而减少输入的字符数； ES6 还舍弃了对象字面量中重复属性名的检查，意味着你可以在一个对象字面量中书写两个同名属性，而不会抛出错误。</p>
<p>Object.assign() 方法让一次性更改单个对象的多个属性变得更加容易，这在使用混入模式时非常有用。 Object.is() 方法对任何值都会执行严格相等比较，在处理特殊的 JS 值时，它成为了 === 的一个更有效更安全的替代品。</p>
<p>对象自有属性的枚举顺序在 ES6 中被明确定义了。在枚举属性时，数字类型的键总是会首先出现，并按升序排列，此后是字符串类型的键，最后是符号类型的键，后两者都分别按添加顺序排列。</p>
<p>借助 ES6 的 Object.setPrototypeOf() 方法，能在对象创建之后再更改其原型。</p>
<p>最后，你能用 super 关键字去调用对象原型上的方法，所调用的方法会被设置好其内部的this 绑定，以自动使用该 this 值来进行工作。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/12/07/函数式编程笔记（一）/">函数式编程笔记（一）</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-12-07
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>第 1 章：为什么使用函数式编程？</p>
<h2 id="置信度"><a href="#置信度" class="headerlink" title="置信度"></a>置信度</h2><ol>
<li>你不能信任的代码是你不明白的代码。</li>
<li>对你不信任或不明白的代码，你将不能确定这些代码是否符合你的业务场景。代码运行时也只能祈求好运。</li>
</ol>
<p>信任是什么意思？信任是指你通过读代码，不仅是跑代码，就能理解这段代码能干什么事，而不只是停留在它可能是干什么的层面。</p>
<h2 id="交流渠道"><a href="#交流渠道" class="headerlink" title="交流渠道"></a>交流渠道</h2><ol>
<li>代码的主要作用是方便人与人交流。应该更多的关注一下代码的可读性。</li>
</ol>
<h2 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h2><p>一些你务必要阅读的函数式编程 / JavaScript 书籍：</p>
<p>Professor Frisby’s Mostly Adequate Guide to Functional Programming by Brian Lonsdorf<br>JavaScript Allongé by Reg Braithwaite<br>Functional JavaScript by Michael Fogus</p>
<h2 id="博客和站点"><a href="#博客和站点" class="headerlink" title="博客和站点"></a>博客和站点</h2><p>一些其他作者和相关内容供查阅：</p>
<p>Fun Fun Function Videos by Mattias P Johansson<br>Awesome函数式编程JS<br>Kris Jenkins<br>Eric Elliott<br>James A Forbes<br>James Longster<br>André Staltz<br>Functional Programming Jargon<br>Functional Programming Exercises</p>
<h2 id="第-2-章：函数基础"><a href="#第-2-章：函数基础" class="headerlink" title="第 2 章：函数基础"></a>第 2 章：函数基础</h2><ol>
<li>函数式编程就是使用在数学意义上的方程作为函数, function 应该接收输入值，并且返回输出值。</li>
<li>arguments 是你输入的值（实参）， parameters 是函数中的命名变量（形参），用于接收函数的输入值</li>
<li>注意： 在 JavaScript 中，实参的个数没必要完全符合形参的个数。如果你传入许多个实参，而且多过你所声明的形参，这些值仍然会原封不动地被传入。你可以通过不同的方式去访问，包含了你以前可能听过的老办法 —— arguments 对象。反之，你传入少于声明形参个数的实参，所有缺少的参数将会被赋予 undefined 变量，意味着你仍然可以在函数作用域中使用它，但值是 undefined。</li>
<li>Arity: 指的是一个函数声明的形参数量。 使用函数的 length 属性即可</li>
<li>由于 ES5（特别是严格模式下）的 arguments 不被一些人认同，很多人尽可能地避免使用。尽管如此，它永远不会被移除，这是因为在 JS 中我们“永远不会”因为便利性而去牺牲向后的兼容性，但我还是强烈建议不要去使用它。<br>然而，当你需要知道参数个数的时候，arguments.length 还是可以用的。在未来版本的 JS 或许会新增特性来替代 arguments.length，如果成真，那么我们可以完全把 arguments 抛诸脑后。<br>请注意：不要通过 arguments[1] 访问参数的位置。只要记住 arguments.length。</li>
<li>带有可变数量参数的函数被称为 variadic<br>7.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"> [x,y,...args] = [] </span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo( [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] );</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>8.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"> &#123;x,y&#125; = &#123;&#125; </span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( x, y );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo( &#123;</span><br><span class="line">    y: <span class="number">3</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure></p>
<ol>
<li>通过不同的输入值让一个函数重载拥有不同的行为的技巧叫做特定多态（ad hoc polymorphism）</li>
<li>如果你没有 return 值，或者你使用 return;，那么则会隐式地返回 undefined 值。<br>如果想要尽可能靠近函数式编程的定义：使用函数而非程序，那么我们的函数必须永远有返回值。这也意味着他们必须明确地 return 一个值，通常这个值也不是 undefined</li>
<li>我认为在许多可读性的问题上，是因为我们不仅使用 return 返回不同的值，更把它作为一个流控制结构——在某些情况下可以提前退出一个函数的执行。我们显然有更好的方法来编写流控制（ if 逻辑等），也有办法使输出路径更加明显。<br>我不是说，你只能有一个 return，或你不应该提早 return，我只是认为在定义函数时，最好不要用 return 来实现流控制，这样会创造更多的隐含意义。尝试找出最明确的表达逻辑的方式，这往往是最好的办法。</li>
<li>这个隐式函数输出在函数式编程中有一个特殊的名称：副作用。当然，没有副作用的函数也有一个特殊的名称：纯函数。我们将在以后的章节讨论这些，但关键是我们应该喜欢纯函数，并且要尽可能地避免副作用。</li>
<li>一个函数如果可以接受或返回一个甚至多个函数，它被叫做高阶函数。</li>
<li><p>闭包是它可以记录并且访问它作用域外的变量，甚至当这个函数在不同的作用域被执行<br>处于 foo(..) 函数作用域中的 msg 参数变量是可以在内部函数中被引用的。当 foo(..) 执行时，并且内部函数被创建，函数可以获取 msg 变量，即使 return 后仍可被访问。<br>虽然我们有函数内部引用 helloFn，现在 foo(..) 执行后，作用域应该回收，这也意味着 msg 也不存在了。不过这个情况并不会发生，函数内部会因为闭包的关系，将 msg 保留下来。只要内部函数（现在被处在不同作用域的 helloFn 引用）存在， msg 就会一直被保留。<br>15.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">x.name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>你几乎从没看到为 IIFE 函数来命名，但他们应该命名</p>
</li>
<li>命名所有单个函数</li>
<li>函数式编程中你不应当使用 this。</li>
</ol>
<h2 id="第-3-章：管理函数的输入（Inputs）"><a href="#第-3-章：管理函数的输入（Inputs）" class="headerlink" title="第 3 章：管理函数的输入（Inputs）"></a>第 3 章：管理函数的输入（Inputs）</h2><ol>
<li><p>用一句话来说明发生的事情：getOrder(data,cb) 是 ajax(url,data,cb) 函数的偏函数（partially-applied functions）。该术语代表的概念是：在函数调用现场（function call-site），将实参应用（apply） 于形参。</p>
</li>
<li><p>偏函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">fn,...presetArgs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">partiallyApplied</span>(<span class="params">...laterArgs</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn( ...presetArgs, ...laterArgs );</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>partial(..) 函数接收 fn 参数，来表示被我们偏应用实参（partially apply）的函数。<br>接着，fn 形参之后，presetArgs 数组收集了后面传入的实参，保存起来稍后使用。<br>我们创建并 return 了一个新的内部函数（为了清晰明了，我们把它命名为partiallyApplied(..)），<br>该函数中，laterArgs 数组收集了全部实参。<br>你注意到在内部函数中的 fn 和 presetArgs 引用了吗？他们是怎么如何工作的？在函数 partial(..) 结束运行后，内部函数为何还能访问 fn 和 presetArgs 引用？你答对了，就是因为闭包！内部函数 partiallyApplied(..) 封闭（closes over）了 fn 和 presetArgs 变量，所以无论该函数在哪里运行，在 partial(..) 函数运行后我们仍然可以访问这些变量。所以理解闭包是多么的重要！<br>当 partiallyApplied(..) 函数稍后在某处执行时，该函数使用被闭包作用（closed over）的 fn 引用来执行原函数，首先传入（被闭包作用的）presetArgs 数组中所有的偏应用（partial application）实参，然后再进一步传入 laterArgs 数组中的实参。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/12/07/koa2-源码分析之-request-js/">koa2 源码分析之 request.js</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-12-07
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>这篇文章我们主要分析一下 request.js 文件的源码</p>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// request.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将代码收起来，我们可以看到，request.js 中导出的是一个对象。</p>
<p>为什么会导出一个对象呢？我们先看一下在 application.js 中是如何使用的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// application.js</span></span><br><span class="line"><span class="comment">// 省略了无关紧要的代码</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'./request'</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">Emitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">this</span>.context = <span class="built_in">Object</span>.create(context); <span class="comment">// context模块，通过context.js创建</span></span><br><span class="line">    <span class="keyword">this</span>.request = <span class="built_in">Object</span>.create(request); <span class="comment">// request模块，通过request.js创建</span></span><br><span class="line">    <span class="keyword">this</span>.response = <span class="built_in">Object</span>.create(response); <span class="comment">//response模块，通过response.js创建</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>
<p>可以看到，在 Application 这个类的构造函数中，request 是当做一个参数传给 Object.create<br>这个函数的。</p>
<p>先讲一下 Object.create 这个方法，首先看一下 MDN 对应的文档<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create</a></p>
<p>Object.create() 方法会使用指定的原型对象及其属性去创建一个新的对象。用法如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create(proto [, propertiesObject ])</span><br></pre></td></tr></table></figure></p>
<ol>
<li>proto 为新创建对象的原型对象，设置为null可创建没有原型的空对象。</li>
<li>如果 proto 参数不是 null 或一个对象，则抛出一个 TypeError 异常。</li>
<li>propertiesObject 可选。如果没有指定为 undefined，则是要添加到新创建对象的可枚举属性<br>（即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及相应的属性名称。<br>这些属性对应Object.defineProperties()的第二个参数。</li>
</ol>
<p>简单来说，就是创建了一个对象，然后这个对象的原型就是你进去的那个参数</p>
<h2 id="简单包装"><a href="#简单包装" class="headerlink" title="简单包装"></a>简单包装</h2><p>其实 request.js 这部分代码没有什么很复杂的地方，主要是把我们常用的属性读取和赋值包装成了 getter 和 setter<br>附上 MDN 对应的文档 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get</a></p>
<p>举个例子，比如我们想查看请求的 URL，我们会用 ctx.resquest.url 来查看，也可以用 ctx.url。而 ctx.url<br>就是被包装成了 getter 和 setter：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">get url() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.req.url;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set request URL.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @api public</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">set url(val) &#123;</span><br><span class="line">  <span class="keyword">this</span>.req.url = val;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<p>无非就是暴露出来一下语法糖，方便开发而已</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/12/06/koa2-源码分析-一/">koa2 源码分析 (一)</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-12-06
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p>koa2 启动一个 http server 的代码如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"></span><br><span class="line">app.user(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;ctx.request.url&#125;</span> <span class="subst">$&#123;ctx.request.method&#125;</span>`</span>)</span><br><span class="line">  <span class="keyword">await</span> next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.user(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`hello world !`</span>)</span><br><span class="line">  <span class="keyword">await</span> next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server listening at 3000 port!'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>知道怎么使用之后，我们对照着这个模板一点一点来拆分 koa2 整个源码<br>
          <div class="read-more">
            <a href="/2017/12/06/koa2-源码分析-一/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/12/04/babel从入门到入门的知识归纳/">babel从入门到入门的知识归纳</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-12-04
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>1、babel是什么</p>
<p>2、javascript制作规范</p>
<p>3、babel转译器</p>
<p>4、babel的使用</p>
<p>5、常见的几种babel转译器和插件</p>
<p>6、babel最常见配置选项</p>
<p>7、babel的其他</p>
<p>8、在webpack中使用babel</p>
<p>9、总结</p>
<h1 id="1、babel是什么"><a href="#1、babel是什么" class="headerlink" title="1、babel是什么"></a>1、babel是什么</h1><p>babel官网正中间一行黄色大字写着 “babel is a javascript compiler”，翻译一下就是babel是一个 javascript 编译器。</p>
<p>为什么会有babel存在呢？原因 javascript 在不断的发展，但是浏览器的发展速度跟不上。</p>
<p>以 es6 为例，es6 中为 javascript 增加了箭头函数、块级作用域等新的语法和 Symbol、Promise 等新的数据类型，但是这些语法和数据类型并不能够马上被现在的浏览器全部支持，为了能在现有的浏览器上使用 js 新的语法和新的数据类型，就需要使用一个转译器，将 javascript 中新增的特性转为现代浏览器能理解的形式。babel 就是做这个方面的转化工作。</p>
<h1 id="2、javascript制作规范"><a href="#2、javascript制作规范" class="headerlink" title="2、javascript制作规范"></a>2、javascript制作规范</h1><p>在这里有必要简单讲一下 javascript 版本，我只是大体讲下。</p>
<p>javascript 是网景公司开发的一种脚本语言，1996 年的时候以 ECMAScript 的名字正式成为一种标准。2007 年的时候发布了版本 es5 ，然后在随后近 10 年里 js 并没有大的变化。所以现在的浏览器都可以很好的支持 es5。这一局面直到 2015 年被打破。2015年6月，TC39（javascript标准的制定组织）公布了新版本的js语言——ES6。而且从ES6开始，TC39规定每年都要发布一个js的新版本，新版本将包含年号，都是以ESxxxx的方式进行命名。所以2015年发布的ES6又叫ES2015，2016年发布的新的js版本就叫ES2016，2017年发布的新的js版本就叫ES2017……。</p>
<p>因为版本都是向前兼容的，就是老版本js版本中规定的语法和api在新版本的js中同样也会合理的。所以我们可以想到后面的规范肯定是包含前面的规范的，也就是ES2016版本的js规范是包含ES2015(ES6)规范的，ES2017是包含ES2016的也包含ES2015的。针对不同的规范，Babel也提供了对应的转换器。</p>
<p>babel-preset-es2015 将es2015版本的js转译为es5。<br>babel-preset-es2016 将es2016版本的js转译为es5。<br>babel-preset-es2017 将es2017版本的js转译为es5。<br>在转译过程中遇到更高版本的js语法，babel是会直接忽略的。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/12/04/react-代码规范/">react 代码规范</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-12-04
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <ol>
<li><p>布尔变量或返回布尔值的函数应该以“is”，“has”或“should”开头。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dirty</span></span><br><span class="line"><span class="keyword">const</span> done = current &gt;= goal</span><br><span class="line"><span class="comment">// Clean</span></span><br><span class="line"><span class="keyword">const</span> isComplete = current &gt;= goal</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数命名应该体现做了什么，而不是是怎样做的。换言之，不要在命名中体现出实现细节。假如有天出现变化，就不需要因此而重构引用该函数的代码。比如，今天可能会从 REST API 加载配置，但是可能明天就会将其直接写入到 JavaScript 中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dirty</span></span><br><span class="line"><span class="keyword">const</span> loadConfigFromServer = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Clean</span></span><br><span class="line"><span class="keyword">const</span> loadConfig = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构建 React 应用程序时，应该遵循以下最佳实践：</p>
<ol>
<li>使用小函数，每个函数具备单一功能，即所谓的单一职责原则（Single responsibility principle）。确保每个函数都能完成一项工作，并做得很好。这样就能将复杂的组件分解成许多较小的组件。同时，将具备更好的可测试性。</li>
<li>小心抽象泄露（leaky abstractions）。换言之，不要强迫消费方去了解内部代码实现细节。</li>
</ol>
</li>
<li>使用 defaultProps</li>
<li>使用无状态组件</li>
</ol>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/11/22/笔记/">笔记</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-11-22
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h3 id="属性初始化器的速记法"><a href="#属性初始化器的速记法" class="headerlink" title="属性初始化器的速记法"></a>属性初始化器的速记法</h3><p>局部变量为对象同名属性赋值<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">    age</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="方法简写"><a href="#方法简写" class="headerlink" title="方法简写"></a>方法简写</h3><p>省略冒号与 function 关键字<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Nicholas"</span>,</span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>使用方法简写速记法创建的方法，其 name 属性就是括号之前的名称。</p>
<h3 id="可计算属性名"><a href="#可计算属性名" class="headerlink" title="可计算属性名"></a>可计算属性名</h3><p>方括号允许指定变量或字符串字面量为属性名<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种用法</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;&#125;,</span><br><span class="line">    lastName = <span class="string">"last name"</span>;</span><br><span class="line"></span><br><span class="line">person[<span class="string">"first name"</span>] = <span class="string">"Nicholas"</span>;</span><br><span class="line">person[lastName] = <span class="string">"Zakas"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">"first name"</span>]); <span class="comment">// "Nicholas"</span></span><br><span class="line"><span class="built_in">console</span>.log(person[lastName]); <span class="comment">// "Zakas"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种用法</span></span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">"last name"</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="string">"first name"</span>: <span class="string">"Nicholas"</span>,</span><br><span class="line">  [lastName]: <span class="string">"Zakas"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种用法</span></span><br><span class="line"><span class="keyword">var</span> suffix = <span class="string">" name"</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  [<span class="string">"first"</span> + suffix]: <span class="string">"Nicholas"</span>,</span><br><span class="line">  [<span class="string">"last"</span> + suffix]: <span class="string">"Zakas"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="新的方法"><a href="#新的方法" class="headerlink" title="新的方法"></a>新的方法</h2><h3 id="Object-is-方法"><a href="#Object-is-方法" class="headerlink" title="Object.is() 方法"></a>Object.is() 方法</h3><p>绝大多数情况下， Object.is() 的结果与 === 运算符是相同的<br>仅有的例外是：它会认为+0 与 -0 不相等，而且 NaN 等于 NaN </p>
<h3 id="Object-assign-方法"><a href="#Object-assign-方法" class="headerlink" title="Object.assign() 方法"></a>Object.assign() 方法</h3><h2 id="重复的对象字面量属性"><a href="#重复的对象字面量属性" class="headerlink" title="重复的对象字面量属性"></a>重复的对象字面量属性</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Nicholas"</span>,</span><br><span class="line">  name: <span class="string">"Greg"</span> <span class="comment">// 在 ES6 严格模式中不会出错</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// "Greg"</span></span><br></pre></td></tr></table></figure>
<h2 id="自有属性的枚举顺序"><a href="#自有属性的枚举顺序" class="headerlink" title="自有属性的枚举顺序"></a>自有属性的枚举顺序</h2><p>Object.getOwnPropertyNames()</p>
<ol>
<li>所有的数字类型键，按升序排列。</li>
<li>所有的字符串类型键，按被添加到对象的顺序排列。</li>
<li>所有的符号类型（ 详见第六章） 键，也按添加顺序排列。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">  c: <span class="number">1</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">1</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line">obj.d = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(obj).join(<span class="string">""</span>)); <span class="comment">// "012acbd"</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>对于 for-in 循环，并非所有的 JS 引擎都采用相同的处理方式，其枚举顺序仍未被明确规定。而 Object.keys() 和 JSON.stringify() 也使用了与 for-in 一样的枚举顺<br>序。</p>
<h2 id="更强大的原型"><a href="#更强大的原型" class="headerlink" title="更强大的原型"></a>更强大的原型</h2><p>###修改对象的原型<br>对象原型的实际值被存储在一个内部属性 [[Prototype]] 上</p>
<ol>
<li>ES5 添加了 Object.getPrototypeOf() 方法来获取任意指定对象的原型</li>
<li>Object.setPrototypeOf() 接受两个参数：需要被修改原型的对象，以及将会成为前者原型的对象<br>###使用 super 引用的简单原型访问<ol>
<li>简单来说， super 是指向当前对象的原型的一个指针<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">  getGreeting() &#123;</span><br><span class="line">    <span class="comment">// 这相当于上个例子中的：</span></span><br><span class="line">    <span class="comment">// Object.getPrototypeOf(this).getGreeting.call(this)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getGreeting() + <span class="string">", hi!"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<ol>
<li>试图在方法简写之外的情况使用 super 会导致语法错误<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">  getGreeting: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 语法错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getGreeting() + <span class="string">", hi!"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="正式的“方法”定义"><a href="#正式的“方法”定义" class="headerlink" title="正式的“方法”定义"></a>正式的“方法”定义</h2><ol>
<li>ES6 则正式将方法定义为：一个拥有 [[HomeObject]] 内部属性的函数，此内部属性指向该方法所属的对象。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="comment">// 方法</span></span><br><span class="line">  getGreeting() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并非方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shareGreeting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hi!"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h1 id="第六章-符号与符号属性"><a href="#第六章-符号与符号属性" class="headerlink" title="第六章 符号与符号属性"></a>第六章 符号与符号属性</h1><h2 id="创建符号值"><a href="#创建符号值" class="headerlink" title="创建符号值"></a>创建符号值</h2><ol>
<li><p>使用全局 Symbol 函数来创建一个符号值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> person = &#123;&#125;;</span><br><span class="line">person[firstName] = <span class="string">"Nicholas"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person[firstName]); <span class="comment">// "Nicholas"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Symbol 函数还可以接受一个额外的参数用于描述符号值，该描述并不能用来访问对应属性，但它能用于调试，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="built_in">Symbol</span>(<span class="string">"first name"</span>);</span><br><span class="line"><span class="keyword">let</span> person = &#123;&#125;;</span><br><span class="line">person[firstName] = <span class="string">"Nicholas"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"first name"</span> <span class="keyword">in</span> person); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(person[firstName]); <span class="comment">// "Nicholas"</span></span><br><span class="line"><span class="built_in">console</span>.log(firstName); <span class="comment">// "Symbol(first name)"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>由于符号值是基本类型的值，因此调用 new Symbol() 将会抛出错误</p>
</li>
<li>可以使用 typeof 运算符来判断一个变量是否为符号<h2 id="使用符号值"><a href="#使用符号值" class="headerlink" title="使用符号值"></a>使用符号值</h2>你可以在任意能使用“可计算属性名”的场合使用符号。<h2 id="共享符号值"><a href="#共享符号值" class="headerlink" title="共享符号值"></a>共享符号值</h2><h2 id="符号值的转换"><a href="#符号值的转换" class="headerlink" title="符号值的转换"></a>符号值的转换</h2><h2 id="检索符号属性"><a href="#检索符号属性" class="headerlink" title="检索符号属性"></a>检索符号属性</h2><h2 id="使用知名符号暴露内部方法"><a href="#使用知名符号暴露内部方法" class="headerlink" title="使用知名符号暴露内部方法"></a>使用知名符号暴露内部方法</h2><h3 id="Symbol-hasInstance-属性"><a href="#Symbol-hasInstance-属性" class="headerlink" title="Symbol.hasInstance 属性"></a>Symbol.hasInstance 属性</h3><h3 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a>Symbol.isConcatSpreadable</h3><h3 id="Symbol-match-、-Symbol-replace-、Symbol-search-与-Symbol-split"><a href="#Symbol-match-、-Symbol-replace-、Symbol-search-与-Symbol-split" class="headerlink" title="Symbol.match 、 Symbol.replace 、Symbol.search 与 Symbol.split"></a>Symbol.match 、 Symbol.replace 、Symbol.search 与 Symbol.split</h3>###Symbol.toPrimitive<h3 id="Symbol-toStringTag"><a href="#Symbol-toStringTag" class="headerlink" title="Symbol.toStringTag"></a>Symbol.toStringTag</h3><h4 id="识别问题的变通解决方法"><a href="#识别问题的变通解决方法" class="headerlink" title="识别问题的变通解决方法"></a>识别问题的变通解决方法</h4><h4 id="ES6-给出的答案"><a href="#ES6-给出的答案" class="headerlink" title="ES6 给出的答案"></a>ES6 给出的答案</h4><h3 id="Symbol-unscopables"><a href="#Symbol-unscopables" class="headerlink" title="Symbol.unscopables"></a>Symbol.unscopables</h3>总结</li>
</ol>
<h1 id="第七章-Set与Map"><a href="#第七章-Set与Map" class="headerlink" title="第七章 Set与Map"></a>第七章 Set与Map</h1><h1 id="第九章-JS的类"><a href="#第九章-JS的类" class="headerlink" title="第九章 JS的类"></a>第九章 JS的类</h1><h2 id="ES5-中的仿类结构"><a href="#ES5-中的仿类结构" class="headerlink" title="ES5 中的仿类结构"></a>ES5 中的仿类结构</h2><ol>
<li>创建一个构造器，然后将方法指派到该构造器的原型上<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PersonType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">PersonType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> PersonType(<span class="string">"Nicholas"</span>);</span><br><span class="line">person.sayName(); <span class="comment">// 输出 "Nicholas"</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> PersonType); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h2><h3 id="基本的类声明"><a href="#基本的类声明" class="headerlink" title="基本的类声明"></a>基本的类声明</h3><ol>
<li><p>类声明以 class 关键字开始，其后是类的名称；剩余部分的语法看起来就像对象字面量中的方法简写，并且在方法之间不需要使用逗号：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonClass</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 等价于 PersonType 构造器</span></span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 等价于 PersonType.prototype.sayName</span></span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自有属性（Own properties ） ：该属性出现在实例上而不是原型上，只能在类的构造器或方法内部进行创建。</p>
<h3 id="为何要使用类的语法"><a href="#为何要使用类的语法" class="headerlink" title="为何要使用类的语法"></a>为何要使用类的语法</h3><p>尽管类与自定义类型之间有相似性，但仍然要记住一些重要的区别：</p>
</li>
<li>类声明不会被提升，这与函数定义不同。类声明的行为与 let 相似，因此在程序执行到声明处之前，类都会位于暂时性死区内。</li>
<li>类声明中的所有代码会自动运行并锁定在严格模式下</li>
<li>类的所有方法都是不可枚举的，这是对于自定义类型的显著变化，后者必须用 Object.defineProperty() 才能将方法改变为不可枚举。</li>
<li>类的所有方法内部都没有 [[Construct]] ，因此使用 new 来调用它们会抛出错误。</li>
<li>调用类构造器时不使用 new ，会抛出错误。</li>
<li>试图在类的方法内部重写类名，会抛出错误。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    Foo = <span class="string">"bar"</span>; <span class="comment">// 执行时抛出错误</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 但在类声明之后没问题</span></span><br><span class="line">Foo = <span class="string">"baz"</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="类表达式"><a href="#类表达式" class="headerlink" title="类表达式"></a>类表达式</h2><h3 id="基本的类表达式"><a href="#基本的类表达式" class="headerlink" title="基本的类表达式"></a>基本的类表达式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> PersonClass = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 等价于 PersonType 构造器</span></span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 等价于 PersonType.prototype.sayName</span></span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="具名类表达式"><a href="#具名类表达式" class="headerlink" title="具名类表达式"></a>具名类表达式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> PersonClass = <span class="class"><span class="keyword">class</span> <span class="title">PersonClass2</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 等价于 PersonType 构造器</span></span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 等价于 PersonType.prototype.sayName</span></span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass); <span class="comment">// "function"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass2); <span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure>
<h2 id="作为一等公民的类"><a href="#作为一等公民的类" class="headerlink" title="作为一等公民的类"></a>作为一等公民的类</h2><h2 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h2><h2 id="可计算的成员名"><a href="#可计算的成员名" class="headerlink" title="可计算的成员名"></a>可计算的成员名</h2><h2 id="生成器方法"><a href="#生成器方法" class="headerlink" title="生成器方法"></a>生成器方法</h2><h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><h2 id="使用派生类进行继承"><a href="#使用派生类进行继承" class="headerlink" title="使用派生类进行继承"></a>使用派生类进行继承</h2><h3 id="屏蔽类方法"><a href="#屏蔽类方法" class="headerlink" title="屏蔽类方法"></a>屏蔽类方法</h3><h3 id="继承静态成员"><a href="#继承静态成员" class="headerlink" title="继承静态成员"></a>继承静态成员</h3><h3 id="从表达式中派生类"><a href="#从表达式中派生类" class="headerlink" title="从表达式中派生类"></a>从表达式中派生类</h3><h3 id="继承内置对象"><a href="#继承内置对象" class="headerlink" title="继承内置对象"></a>继承内置对象</h3><h3 id="Symbol-species-属性"><a href="#Symbol-species-属性" class="headerlink" title="Symbol.species 属性"></a>Symbol.species 属性</h3><h2 id="在类构造器中使用-new-target"><a href="#在类构造器中使用-new-target" class="headerlink" title="在类构造器中使用 new.target"></a>在类构造器中使用 new.target</h2><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/11/22/深入-ES6-03-函数/">深入-ES6-03 函数</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-11-22
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>函数在任何编程语言中都是非常重要的一部分，而从 JS 诞生起，一直到 ES6 之前，函数都未有较大的变化。这积压了诸多问题及细微行为差异，由此容易诱发错误，并且经常需要用大量代码来实现非常基本的功能。</p>
<p>ES6 的函数考虑了 JS 开发者多年的抱怨与诉求，大踏步前进，在 ES5 函数基础上实现了不少增量改进，让 JS 更加强大，同时编程错误也更少。</p>
<h2 id="带参数默认值的函数"><a href="#带参数默认值的函数" class="headerlink" title="带参数默认值的函数"></a>带参数默认值的函数</h2><p>JS 函数的独特之处是可以接受任意数量的参数，而无视函数声明处的形参数量。这让你定义的函数可以使用不同的参数数量来调用，而未提供的参数经常会使用默认值来代替。本章将介绍默认的参数值在 ES6 前后是如何实现的，顺带介绍的内容还有： arguments 对象的一些重要信息，将表达式作为参数使用，以及另一种形式的 TDZ 。</p>
<h2 id="在-ES5-中模拟参数默认值"><a href="#在-ES5-中模拟参数默认值" class="headerlink" title="在 ES5 中模拟参数默认值"></a>在 ES5 中模拟参数默认值</h2><p>在 ES5 或更早的版本中，你或许会使用以下模式来创建带有参数默认值的函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span>(<span class="params">url, timeout, callback</span>) </span>&#123;</span><br><span class="line">  timeout = timeout || <span class="number">2000</span></span><br><span class="line">  callback = callback || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 函数的剩余部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在本例中， timeout 与 callback 实际上都是可选参数，因为他们都会在参数未被提供的情况下使用默认值。逻辑或运算符（ || ） 在左侧的值为假值（falsy ） 的情况下总会返回右侧的操作数。由于函数的具名参数在未被明确提供时会是 undefined ，逻辑或运算符就经常被用来给缺失的参数提供默认值。不过此方法有个瑕疵，此处的 timeout 的有效值实际上有可能是 0 ，但因为 0 是假值，就会导致 timeout 的值在这种情况下被替换为 2000 。</p>
<p>在这种情况下，更安全的选择是使用 typeof 来检测参数的类型，正如下例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span>(<span class="params">url, timeout, callback</span>) </span>&#123;</span><br><span class="line">  timeout = (<span class="keyword">typeof</span> timeout !== <span class="string">"undefined"</span>) ? timeout : <span class="number">2000</span></span><br><span class="line">  callback = (<span class="keyword">typeof</span> callback !== <span class="string">"undefined"</span>) ? callback : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 函数的剩余部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>尽管这种方式更安全，却为实现一个基本需求而书写了过多的代码。它代表了一种常见模<br>式，充斥在各种流行的 JS 库中。</p>
<h2 id="ES6-中的参数默认值"><a href="#ES6-中的参数默认值" class="headerlink" title="ES6 中的参数默认值"></a>ES6 中的参数默认值</h2><p>ES6 能更容易地为参数提供默认值，它使用了初始化形式，以便在参数未被正式传递进来时<br>使用。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span>(<span class="params">url, timeout = <span class="number">2000</span>, callback = function(</span>) </span>&#123;&#125;) &#123;</span><br><span class="line"><span class="comment">// 函数的剩余部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此函数只要求始终提供第一个参数。其余两个参数则都有默认值，这就无需再添加更多代码<br>来检查缺失的参数值，让函数体更为小巧。</p>
<p>若完整使用三个参数来调用 makeRequest() ，那么默认值将不会被用到，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用默认的 timeout 与 callback</span></span><br><span class="line">makeRequest(<span class="string">"/foo"</span>)</span><br><span class="line"><span class="comment">// 使用默认的 callback</span></span><br><span class="line">makeRequest(<span class="string">"/foo"</span>, <span class="number">500</span>)</span><br><span class="line"><span class="comment">// 不使用默认值</span></span><br><span class="line">makeRequest(<span class="string">"/foo"</span>, <span class="number">500</span>, <span class="function"><span class="keyword">function</span>(<span class="params">body</span>) </span>&#123;</span><br><span class="line">  doSomething(body)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>ES6 会认为 url 参数是必须的，因此三次调用 makeRequest() 都必须传入 “/foo” 。拥有默认值的两个参数则都被认为是可选的。</p>
<p>在函数声明中能指定任意一个参数的默认值，即使之后还存在未指定默认值的参数。例如，下面这样是可行的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span>(<span class="params">url, timeout = <span class="number">2000</span>, callback</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 函数的剩余部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在本例中，只有在未传递第二个参数、或明确将第二个参数值指定为 undefined 时，timeout 的默认值才会被使用，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用默认的 timeout</span></span><br><span class="line">makeRequest(<span class="string">"/foo"</span>, <span class="literal">undefined</span>, <span class="function"><span class="keyword">function</span>(<span class="params">body</span>) </span>&#123;</span><br><span class="line">  doSomething(body);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 使用默认的 timeout</span></span><br><span class="line">makeRequest(<span class="string">"/foo"</span>);</span><br><span class="line"><span class="comment">// 不使用默认值</span></span><br><span class="line">makeRequest(<span class="string">"/foo"</span>, <span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params">body</span>) </span>&#123;</span><br><span class="line">  doSomething(body);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中， null 值被认为是有效参数，意味着对于 makeRequest() 的第三次调用并不会使用 timeout 的默认值。</p>
<h2 id="参数默认值如何影响-arguments-对象"><a href="#参数默认值如何影响-arguments-对象" class="headerlink" title="参数默认值如何影响 arguments 对象"></a>参数默认值如何影响 arguments 对象</h2><p>需要记住的是， arguments 对象会在使用参数默认值时有不同的表现。在 ES5 的非严格模式下， arguments 对象会反映出具名参数的变化。以下代码说明了该工作机制：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixArgs</span>(<span class="params">first, second</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">  first = <span class="string">"c"</span>;</span><br><span class="line">  second = <span class="string">"d"</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">mixArgs(<span class="string">"a"</span>, <span class="string">"b"</span>);</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>在非严格模式下， arguments 对象总是会被更新，以反映出具名参数的变化。因此当 first 与 second 变量被赋予新值时， arguments[0] 与 arguments[1] 也就相应被更新，让这里所有的 === 严格比较的结果都为 true 。</p>
<p>然而在 ES5 的严格模式下，消除了关于 arguments 对象的这种混乱情况，它不再反映出具名参数的变化。在严格模式下重新使用上例中的函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixArgs</span>(<span class="params">first, second</span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">  first = <span class="string">"c"</span>;</span><br><span class="line">  second = <span class="string">"d"</span></span><br><span class="line">  <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">mixArgs(<span class="string">"a"</span>, <span class="string">"b"</span>);</span><br></pre></td></tr></table></figure></p>
<p>调用 mixArgs() 则输出：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<p>这一次更改 first 与 second 就不会再影响 arguments 对象，因此输出结果符合通常的期望。</p>
<p>然而在使用 ES6 参数默认值的函数中，无论函数是否明确运行在严格模式下， arguments 对象的表现总是会与 ES5 的严格模式一致，参数默认值的存在触发了 arguments 对象与具名参数的分离。这是个细微但重要的细节，表示 arguments 对象的使用方式发生了变化。研究如下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非严格模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixArgs</span>(<span class="params">first, second = <span class="string">"b"</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);</span><br><span class="line">  <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">  first = <span class="string">"c"</span>;</span><br><span class="line">  second = <span class="string">"d"</span></span><br><span class="line">  <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">mixArgs(<span class="string">"a"</span>);</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<p>本例中 arguments.length 的值为 1 ，因为只给 mixArgs() 传递了一个参数。这也意味着 arguments[1] 的值是 undefined ，符合将单个参数传递给函数时的预期；这同时意味着 first 与 arguments[0] 是相等的。无论是否在严格模式下，改变 first 和 second 的值不会对 arguments 对象造成影响，所以 arguments 对象始终能映射出初始调用状态。</p>
<h2 id="参数默认值表达式"><a href="#参数默认值表达式" class="headerlink" title="参数默认值表达式"></a>参数默认值表达式</h2><p>参数默认值最有趣的特性，或许就是默认值并不非得是基本类型值。例如，你可以执行一个函数来产生参数的默认值，就像这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first, second = getValue(</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> first + second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure></p>
<p>此处若未提供第二个参数， getValue() 函数就会被调用以获取正确的默认值。需要注意的是，仅在调用 add() 函数而未提供第二个参数时， getValue() 函数才会被调用，而在 add() 的函数声明初次被解析时并不会进行调用。这意味着 getValue() 函数若被写为可变的，则默认参数获取的值有可能也会变化，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first, second = getValue(</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> first + second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure></p>
<p>本例中 value 的初始值是 5 ，并且会随着对 getValue() 的每次调用而递增。首次调用 add(1) 返回的值为 6 ，再次调用时 value 的值已被增加，于是返回了 7 。由于 second 参数的默认值总是在 add() 函数被调用的情况下才被计算，因此该参数的值随时都会被改变。</p>
<p>将函数调用作为参数的默认值时需要小心，如果你遗漏了括号，例如在上面例子中使用 second = getValue ，你就传递了对于该函数的一个引用，而没有传递调用该函数的结果</p>
<p>这种行为引出了另一种有趣的能力：可以将前面的参数作为后面参数的默认值，此处有个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first, second = first</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> first + second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<p>此代码中 first 为 second 参数提供了默认值，意味着只传入一个参数会让两个参数获得相同的值，因此 add(1, 1) 与 add(1) 同样返回了 2 。再进一步，你还能将 first 作为参数传递给一个函数来产生 second 参数的值，正如下例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value + <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first, second = getValue(first</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> first + second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure></p>
<p>此例将 second 的值设为等于 getValue(first) 函数的返回值，因此 add(1) 会返回 7 （1 + 6 ） ，而 add(1, 1) 仍然返回 2 。</p>
<p>引用其他参数来为参数进行默认赋值时，仅允许引用前方的参数，因此前面的参数不能向后访问，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first = second, second</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> first + second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="literal">undefined</span>, <span class="number">1</span>)); <span class="comment">// 抛出错误</span></span><br></pre></td></tr></table></figure></p>
<p>调用 add(undefined, 1) 发生了错误，这是由于 second 在 first 之后定义，因此不能将其作为后者的默认值。为了理解这种情况的成因，需着重回顾“暂时性死区”概念。</p>
<h2 id="参数默认值的暂时性死区"><a href="#参数默认值的暂时性死区" class="headerlink" title="参数默认值的暂时性死区"></a>参数默认值的暂时性死区</h2><p>第一章介绍了 let 与 const 的暂时性死区（TDZ ） ，而参数默认值同样具有暂时性死区。与 let 声明相似，函数每个参数都会创建一个新的标识符绑定，它在初始化之前不允许被访问，否则会抛出错误。参数初始化会在函数被调用时进行，无论是给参数传递了一个值、还是使用了参数的默认值。</p>
<p>为了探索参数默认值中的暂时性死区，可再次研究“参数默认值表达式”中的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value + <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first, second = getValue(first</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> first + second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure></p>
<p>调用 add(1, 1) 和 add(1) 事实上执行了以下代码来创建 first 与 second 的参数值：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JS 调用 add(1, 1) 可表示为</span></span><br><span class="line"><span class="keyword">let</span> first = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> second = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// JS 调用 add(1) 可表示为</span></span><br><span class="line"><span class="keyword">let</span> first = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> second = getValue(first);</span><br></pre></td></tr></table></figure></p>
<p>当函数 add() 第一次执行时， first 与 second 的绑定被加入了特定参数的暂时性死区（ 类似于 let 声明的行为） 。因此 second 可以使用 first 来初始化，因为此处 first已完成了初始化，但反之则不行。现在再研究以下重写过的 add() 函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first = second, second</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> first + second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="literal">undefined</span>, <span class="number">1</span>)); <span class="comment">// 抛出错误</span></span><br></pre></td></tr></table></figure></p>
<p>本例中调用 add(1, 1) 与 add(undefined, 1) 对应着以下的后台代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JS 调用 add(1, 1) 可表示为</span></span><br><span class="line"><span class="keyword">let</span> first = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> second = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// JS 调用 add(1) 可表示为</span></span><br><span class="line"><span class="keyword">let</span> first = second;</span><br><span class="line"><span class="keyword">let</span> second = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>本例中调用 add(undefined, 1) 抛出了错误，是因为在对 first 进行初始化时， second 尚未被初始化。此处的 second 位于暂时性死区内，对 second 的引用就抛出了错误，正如第一章讨论过的 let 绑定的行为。</p>
<p>函数参数拥有各自的作用域和暂时性死区，与函数体的作用域相分离，这意味着参数的默认值不允许访问在函数体内部声明的任意变量。</p>
<h2 id="使用不具名参数"><a href="#使用不具名参数" class="headerlink" title="使用不具名参数"></a>使用不具名参数</h2><p>到目前为止，本章的例子只涵盖了在函数定义中的已被命名的参数。然而 JS 的函数并不强求参数的数量要等于已定义具名参数的数量，实际所传递的参数允许少于或多于正式指定的参数。参数的默认值让函数在接收更少参数时的行为更清晰，而 ES6 试图让相反情况的问题也被更好地解决。</p>
<h2 id="ES5-中的不具名参数"><a href="#ES5-中的不具名参数" class="headerlink" title="ES5 中的不具名参数"></a>ES5 中的不具名参数</h2><p>JS 早就提供了 arguments 对象用于查看传递给函数的所有参数，这样就不必分别指定每个参数。虽然查看 arguments 对象在大多数情况下都工作正常，但操作它有时仍然较为麻烦。例如，参考以下查看 arguments 对象的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  <span class="comment">// 从第二个参数开始处理</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">    result[<span class="built_in">arguments</span>[i]] = object[<span class="built_in">arguments</span>[i]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> book = &#123;</span><br><span class="line">  title: <span class="string">"Understanding ES6"</span>,</span><br><span class="line">  author: <span class="string">"Nicholas C. Zakas"</span>,</span><br><span class="line">  year: <span class="number">2015</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bookData = pick(book, <span class="string">"author"</span>, <span class="string">"year"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bookData.author); <span class="comment">// "Nicholas C. Zakas"</span></span><br><span class="line"><span class="built_in">console</span>.log(bookData.year); <span class="comment">// 2015</span></span><br></pre></td></tr></table></figure></p>
<p>此函数模拟了 Underscore.js 代码库的 pick() 方法，能够返回包含原有对象特定属性的子集副本。本例中只为函数定义了一个期望参数，也就是拷贝属性的来源对象，除此之外传递的所有参数则都是需要拷贝的属性的名称。</p>
<p>这个 pick() 函数有两点需要注意。首先，完全看不出该函数具备处理多个参数的能力，就算为其再多定义几个参数，但依然不足以标明它能处理任意数量的参数。其次，由于第一个参数被命名并被直接使用，当你寻找需要复制的属性时，就必须从 arguments 对象索引位置 1 而非位置 0 开始处理。要记住使用 arguments 的适当索引值或许不困难，但毕竟多了一件挂心之事。</p>
<p>ES6 引入了剩余参数以便解决此问题。</p>
<h2 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h2><p>剩余参数（rest parameter ） 由三个点（ … ） 与一个紧跟着的具名参数指定，它是包含传递给函数的其余参数的一个数组，由此得名“剩余”。例如， pick() 函数可以像下面这样用剩余参数来重写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">object, ...keys</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = keys.length; i &lt; len; i++) &#123;</span><br><span class="line">    result[keys[i]] = object[keys[i]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在此版本的函数中， keys 是一个剩余参数，包含所有在 object 之后的参数，这与囊括所有参数的 arguments 不同，后者连第一个参数都会包含。这意味着你无需有所顾虑，可以对 keys 从头到尾进行迭代。作为一个额外的收益，通过观察该函数声明便能判明它具有处理任意数量参数的能力。</p>
<p>函数的 length 属性用于指示具名参数的数量，而剩余参数对其毫无影响。此例中 pick() 函数的 length 属性值是 1 ，因为只有 object 参数被用于计算该值。</p>
<p>译注：这种说法并不严谨。若函数使用了默认参数，则 length 属性不包含使用默认值的参数，并且它只能指示出第一个默认参数之前的具名参数数量。例如对于<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params">first, second = <span class="string">'woo'</span>, third</span>) </span>&#123;&#125; <span class="comment">// length = 1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example2</span>(<span class="params">first, third</span>) </span>&#123;&#125; <span class="comment">// length = 2</span></span><br></pre></td></tr></table></figure></p>
<p>函数声明来说， length 的值是 1 而非 2，尽管这里有两个无默认值的具名参数。</p>
<h2 id="剩余参数的限制条件"><a href="#剩余参数的限制条件" class="headerlink" title="剩余参数的限制条件"></a>剩余参数的限制条件</h2><p>剩余参数受到两点限制。一是函数只能有一个剩余参数，并且它必须被放在最后。例如，如下代码是无法工作的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法错误：不能在剩余参数后使用具名参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">object, ...keys, last</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = keys.length; i &lt; len; i++) &#123;</span><br><span class="line">    result[keys[i]] = object[keys[i]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此处的 last 跟在了剩余参数 keys 后面，这会导致一个语法错误。</p>
<p>第二个限制是剩余参数不能在对象字面量的 setter 属性中使用，这意味着如下代码同样会导致语法错误：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line">  <span class="comment">// 语法错误：不能在 setter 中使用剩余参数</span></span><br><span class="line">  set name(...value) &#123;</span><br><span class="line">  <span class="comment">// 一些操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>存在此限制的原因是：对象字面量的 setter 被限定只能使用单个参数；而剩余参数按照定义是不限制参数数量的，因此它在此处不被许可。</p>
<h2 id="剩余参数如何影响-arguments-对象"><a href="#剩余参数如何影响-arguments-对象" class="headerlink" title="剩余参数如何影响 arguments 对象"></a>剩余参数如何影响 arguments 对象</h2><p>设计剩余参数是为了替代 ES 中的 arguments 对象。 ES4 曾经移除了 arguments 并添加了剩余参数，以便允许向函数传入不限数量的参数。尽管 ES4 规范被废弃，但这个想法被保持下来，并在 ES6 中被重新引入，不过 arguments 仍得以保留。</p>
<p>arguments 对象在函数被调用时反映了传入的参数，与剩余参数能协同工作，就像如下程序所演示的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkArgs</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(args.length);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);</span><br><span class="line">  <span class="built_in">console</span>.log(args[<span class="number">0</span>], <span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(args[<span class="number">1</span>], <span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">checkArgs(<span class="string">"a"</span>, <span class="string">"b"</span>);</span><br></pre></td></tr></table></figure></p>
<p>调用 checkArgs() 输出了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line">a a</span><br><span class="line">b b</span><br></pre></td></tr></table></figure></p>
<p>arguments 对象总能正确反映被传入函数的参数，而无视剩余参数的使用。</p>
<h2 id="函数构造器的增强"><a href="#函数构造器的增强" class="headerlink" title="函数构造器的增强"></a>函数构造器的增强</h2><p>Function 构造器允许你动态创建一个新函数，但在 JS 中并不常用。传给该构造器的参数都是字符串，它们就是目标函数的参数与函数体，此处有个范例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"first"</span>, <span class="string">"second"</span>, <span class="string">"return first + second"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<p>ES6 增强了 Function 构造器的能力，允许使用默认参数以及剩余参数。对于默认参数来说，你只需为参数名称添加等于符号以及默认值，正如下例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"first"</span>, <span class="string">"second = first"</span>,</span><br><span class="line"><span class="string">"return first + second"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<p>在此例中，当只传递了一个参数时， first 的值会被赋给 second 参数，此处的语法与不使用 Function 的函数声明一致。</p>
<p>而对剩余参数来说，只需在最后一个参数前添加 … 即可，就像这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pickFirst = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"...args"</span>, <span class="string">"return args[0]"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(pickFirst(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p>此代码创建了一个仅使用剩余参数的函数，让其返回所传入的第一个参数。<br>为 Function 构造器添加默认参数与剩余参数，确保了它拥有与函数声明形式相同的所有能力。</p>
<h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><p>与剩余参数关联最密切的就是扩展运算符。剩余参数允许你把多个独立的参数合并到一个数组中；而扩展运算符则允许将一个数组分割，并将各个项作为分离的参数传给函数。考虑一下 Math.max() 方法，它接受任意数量的参数，并会返回其中的最大值。此处有个简单用例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value1 = <span class="number">25</span>,</span><br><span class="line">    value2 = <span class="number">50</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(value1, value2)); <span class="comment">// 50</span></span><br></pre></td></tr></table></figure></p>
<p>若像本例这样仅处理两个值，那么仅需将这两个值直接传入 Math.max() ，较大的那个就会成为返回值。但如何处理数组中的多个值呢？ Math.max() 方法并不允许你传入一个数组，因此在 ES5 或更早版本中，要么自行搜索整个数组，要么像下面这样使用 apply() 方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">25</span>, <span class="number">50</span>, <span class="number">75</span>, <span class="number">100</span>]</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, values)); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure></p>
<p>该解决方案是可行的，但这样使用 apply() 会稍微令人疑惑，它使用额外语法而混淆了代码的真实意图。</p>
<p>ES6 的扩展运算符令这种情况变得简单。无须调用 apply() ，你可以在该数组前添加 … 并直接将其传递给 Math.max() ，就像使用剩余参数那样。 JS 引擎将会将该数组分割为独立参数并把它们传递进去：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">25</span>, <span class="number">50</span>, <span class="number">75</span>, <span class="number">100</span>]</span><br><span class="line"><span class="comment">// 等价于 console.log(Math.max(25, 50, 75, 100));</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...values)); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure></p>
<p>如此调用 Math.max() 更接近传统形式，并避免了为一个简单数学操作使用复杂的 this 绑定（ 即在上个例子中提供给 Math.max.apply() 的第一个参数） 。</p>
<p>你可以将扩展运算符与其他参数混用。假设你想让 Math.max() 返回的最小值为 0 ，以忽略数组内的负值，可以将参数 0 单独传入，并继续为其他参数使用扩展运算符，正如下例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">-25</span>, <span class="number">-50</span>, <span class="number">-75</span>, <span class="number">-100</span>]</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...values, <span class="number">0</span>)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></p>
<p>本例中传给 Math.max() 的最后一个参数是 0 ，它跟在使用扩展运算符的其他参数之后。用扩展运算符传递参数，让函数更容易用数组作为参数，在大部分场景中，扩展运算符都是 apply() 方法的合适替代品。</p>
<p>关于 ES6 中的默认参数与剩余参数，除了你至今看到的用法之外，还可以在 Function 构造器中使用它们。</p>
<h2 id="ES6-的名称属性"><a href="#ES6-的名称属性" class="headerlink" title="ES6 的名称属性"></a>ES6 的名称属性</h2><p>定义函数有各种各样的方式，在 JS 中识别函数因此变得很有挑战性。此外，匿名函数表达式的流行使得调试有点困难，经常导致堆栈跟踪难以被阅读与解释。为此， ES6 给所有函数添加了 name 属性。</p>
<h2 id="选择合适的名称"><a href="#选择合适的名称" class="headerlink" title="选择合适的名称"></a>选择合适的名称</h2><p>ES6 中所有函数都有适当的 name 属性值。为了理解其实际运作，请看下例——它展示了一个函数与一个函数表达式，并将二者的 name 属性都打印出来：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> doAnotherThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(doSomething.name); <span class="comment">// "doSomething"</span></span><br><span class="line"><span class="built_in">console</span>.log(doAnotherThing.name); <span class="comment">// "doAnotherThing</span></span><br></pre></td></tr></table></figure></p>
<p>在此代码中，由于 doSomething() 是一个函数声明，它就拥有一个值为 “doSomething” 的 name 属性。而匿名函数表达式 doAnotherThing() 的 name 属性值则是 “doAnotherThing”，因为这是该函数所赋值的变量的名称。</p>
<p>译注：匿名函数的名称属性在 FireFox 与 Edge 中仍然不被支持，值为空字符串，而 Chrome 直到 51.0 版本才提供了该特性。</p>
<h2 id="名称属性的特殊情况"><a href="#名称属性的特殊情况" class="headerlink" title="名称属性的特殊情况"></a>名称属性的特殊情况</h2><p>虽然函数声明与函数表达式的名称易于确定，但 ES6 还做了更多规定以确保所有函数都拥有合适的名称。为了表明这点，请参考如下程序：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span> <span class="title">doSomethingElse</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  get firstName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Nicholas"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(doSomething.name); <span class="comment">// "doSomethingElse"</span></span><br><span class="line"><span class="built_in">console</span>.log(person.sayName.name); <span class="comment">// "sayName"</span></span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">"firstName"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.get.name); <span class="comment">// "get firstName"</span></span><br></pre></td></tr></table></figure></p>
<p>本例中的 doSomething.name 的值是 “doSomethingElse” ，因为该函数表达式自己拥有一个名称，并且此名称的优先级要高于赋值目标的变量名。 person.sayName() 的 name 属性值是 “sayName” ，正如对象字面量指定的那样。类似的， person.firstName 实际是个 getter 函数，因此它的名称是 “get firstName” ，以标明它的特征；同样， setter 函数也会带有 “set” 的前缀（getter 与 setter 函数都必须用 Object.getOwnPropertyDescriptor() 来检索） 。</p>
<p>函数名称还有另外两个特殊情况。使用 bind() 创建的函数会在名称属性值之前带有 “bound” 前缀；而使用 Function 构造器创建的函数，其名称属性为 “anonymous” ，正如此例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(doSomething.bind().name); <span class="comment">// "bound doSomething"</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="keyword">new</span> <span class="built_in">Function</span>()).name); <span class="comment">// "anonymous"</span></span><br></pre></td></tr></table></figure></p>
<p>绑定产生的函数拥有原函数的名称，并总会附带 “bound” 前缀，因此 doSomething() 函数的绑定版本的名称为 “bound doSomething” 。</p>
<p>需要注意的是，函数的 name 属性值未必会关联到同名变量。 name 属性是为了在调试时获得有用的相关信息，所以不能用 name 属性值去获取对函数的引用。</p>
<h2 id="明确函数的双重用途"><a href="#明确函数的双重用途" class="headerlink" title="明确函数的双重用途"></a>明确函数的双重用途</h2><p>在 ES5 以及更早版本中，函数根据是否使用 new 去调用而有双重用途。当使用 new 时，函数内部的 this 是一个新对象，并作为函数的返回值，如下例所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>);</span><br><span class="line"><span class="keyword">var</span> notAPerson = Person(<span class="string">"Nicholas"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// "[Object object]"</span></span><br><span class="line"><span class="built_in">console</span>.log(notAPerson); <span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure></p>
<p>当调用 Person() 来创建 notAPerson 时，未使用 new ，输出了 undefined ，并且在非严格模式下给全局对象添加了 name 属性。 Person 首字母大写是指示其应当使用 new 来调用的唯一标识，这在 JS 编程中是个惯例。函数双重角色的混乱情况在 ES6 中发生了一些改变</p>
<p>JS 为函数提供了两个不同的内部方法： [[Call]] 与 [[Construct]] 。当未使用 new 进行函数调用时， [[Call]] 方法会被执行，运行的是代码中的函数体。而当使用 new 进行函数调用时， [[Construct]] 方法则会被执行，负责创建一个被称为新目标的新对象，并且将该新目标作为 this 去执行函数体。拥有 [[Construct]] 方法的函数被称为构造器。</p>
<p>切记并非所有函数都拥有 [[Construct]] 方法，因此不是所有函数都可以用 new 去调用。在后面会介绍的箭头函数就是个例外。</p>
<h2 id="在-ES5-中判断函数如何被调用"><a href="#在-ES5-中判断函数如何被调用" class="headerlink" title="在 ES5 中判断函数如何被调用"></a>在 ES5 中判断函数如何被调用</h2><p>在 ES5 中判断是否使用了 new 去调用函数（ 即作为构造器） ，最流行的方式是使用 instanceof ，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="string">'this'</span>)</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name; <span class="comment">// 使用 new</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"You must use new with Person."</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>);</span><br><span class="line"><span class="keyword">var</span> notAPerson = Person(<span class="string">"Nicholas"</span>); <span class="comment">// 抛出错误</span></span><br></pre></td></tr></table></figure></p>
<p>此处对 this 值进行了检查，来判断其是否为构造器的一个实例：若是，正常继续执行；否则抛出错误。这么做能奏效是因为 [[Construct]] 方法创建了 Person 的一个新实例并将其赋值给 this 。可惜该方法并不绝对可靠，因为有时未使用 new 但 this 仍然可能是 Person 的实例，正如下例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name; <span class="comment">// 使用 new</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"You must use new with Person."</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>);</span><br><span class="line"><span class="keyword">var</span> notAPerson = Person.call(person, <span class="string">"Michael"</span>); <span class="comment">// 奏效了！</span></span><br></pre></td></tr></table></figure></p>
<p>调用 Person.call() 并将 person 变量作为第一个参数传入，这意味着将 Person 内部的 this 被设置为了 person 。对于该函数来说，没任何办法能将这种方式与使用 new 调用区分开来。</p>
<h2 id="new-target-元属性"><a href="#new-target-元属性" class="headerlink" title="new.target 元属性"></a>new.target 元属性</h2><p>为了解决这个问题， ES6 引入了 new.target 元属性。元属性指的是“非对象”（ 例如 new 运算符） 上的属性，并提供关联目标的附加信息。当函数的 [[Construct]] 方法被调用时，new 运算符的作用目标会填入 new.target 元属性，此时函数体内部的 this 值是新创建的对象实例，而 new.target 的值正是该实例的构造器。而若 [[Call]] 被执行， new.target 的值将会是 undefined 。</p>
<p>通过检查 new.target 这个新的元属性是否被定义，就能让你安全地判断函数被调用时是否使用了 new 。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span>.target, <span class="string">'new.target)</span></span><br><span class="line"><span class="string">  if (typeof new.target !== "undefined") &#123;</span></span><br><span class="line"><span class="string">    this.name = name; // 使用 new</span></span><br><span class="line"><span class="string">  &#125; else &#123;</span></span><br><span class="line"><span class="string">    throw new Error("You must use new with Person.")</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">var person = new Person("Nicholas");</span></span><br><span class="line"><span class="string">var notAPerson = Person.call(person, "Michael"); // 出错！</span></span><br></pre></td></tr></table></figure></p>
<p>使用 new.target 而非 this instanceof Person ， Person 构造器会在未使用 new 时正确地抛出错误。</p>
<p>也可以检查 new.target 来判断是否使用特定构造器进行了调用，例如以下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">new</span>.target === Person) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target)</span><br><span class="line">    <span class="keyword">this</span>.name = name; <span class="comment">// 使用 new</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"You must use new with Person."</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AnotherPerson</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>);</span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="keyword">new</span> AnotherPerson(<span class="string">"Nicholas"</span>); <span class="comment">// 出错！</span></span><br></pre></td></tr></table></figure></p>
<p>在此代码中，为了正确工作， new.target 必须是 Person 。当调用 new<br>AnotherPerson(“Nicholas”) 时， Person.call(this, name) 也随之被调用，从而抛出了错误，因为此时在 Person 构造器内部的 new.target 值为 undefined （ 调用 Person 时并未使用 new ） 。</p>
<p>警告：在函数之外使用 new.target 会导致语法错误。</p>
<p>ES6 通过新增 new.target 而消除了函数调用方式的不确定性。在此方面 ES6 还随之解决了语言此前另一个不确定的部分——在代码块内部声明函数。</p>
<h2 id="块级函数"><a href="#块级函数" class="headerlink" title="块级函数"></a>块级函数</h2><p>在 ES3 或更早版本中，在代码块中声明函数（ 即块级函数） 严格来说应当是一个语法错误，但所有的浏览器却都支持该语法。可惜每个浏览器都有轻微的行为差异，所以最佳实践就是切勿在代码块中声明函数，更好的选择是使用函数表达式。</p>
<p>为了控制这种不兼容行为， ES5 的严格模式为代码块内部的函数声明引入了一种错误，就像这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// 在 ES5 会抛出语法错误， ES6 则不会</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 ES5 中，这段代码会抛出语法错误。不过 ES6 会将 doSomething() 函数视为块级声明，并允许它在声明所在的代码块内部被访问。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSomething); <span class="comment">// "function"</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  doSomething();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSomething); <span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure></p>
<p>块级函数会被提升到所在代码块的顶部，因此 typeof doSomething 会返回 “function” ，即便该检查位于此函数定义位置之前。一旦 if 代码块执行完毕， doSomething() 也就不复存在。</p>
<h2 id="决定何时使用块级函数"><a href="#决定何时使用块级函数" class="headerlink" title="决定何时使用块级函数"></a>决定何时使用块级函数</h2><p>块级函数与 let 函数表达式相似，在执行流跳出定义所在的代码块之后，函数定义就会被移除。关键区别在于：块级函数会被提升到所在代码块的顶部；而使用 let 的函数表达式则不会，正如以下范例所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSomething); <span class="comment">// 抛出错误</span></span><br><span class="line">  <span class="keyword">let</span> doSomething = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  doSomething();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSomething);</span><br></pre></td></tr></table></figure></p>
<p>此处代码在 typeof doSomething 被执行时中断了，因为 let 声明尚未被执行，doSomething() 位于暂时性死区。了解这个区别之后，就能根据是否想要提升，来选择应当使用块级函数还是 let 表达式。</p>
<h2 id="非严格模式的块级函数"><a href="#非严格模式的块级函数" class="headerlink" title="非严格模式的块级函数"></a>非严格模式的块级函数</h2><p>ES6 在非严格模式下同样允许使用块级函数，但行为有细微不同。块级函数的作用域会被提升到所在函数或全局环境的顶部，而不是代码块的顶部。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6 behavior</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSomething); <span class="comment">// "function"</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  doSomething();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSomething); <span class="comment">// "function"</span></span><br></pre></td></tr></table></figure></p>
<p>本例中的 doSomething() 会被提升到全局作用域，因此在 if 代码块外部它仍然存在。 ES6标准化了这种行为，以便移除浏览器此前存在的不兼容性，于是在所有 ES6 运行环境中其行为都会遵循相同的方式。</p>
<p>允许使用块级函数只是增强了在 JS 中声明函数的能力，但 ES6 还引入了一种全新的函数声明方式。</p>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>ES6 最有趣的一个新成分便是箭头函数（arrow function ） 。箭头函数正如名称所示那样使用一个“箭头”（ =&gt; ） 来定义，但它的行为在很多重要方面与传统的 JS 函数不同：</p>
<ol>
<li><p>没有 this 、 super 、 arguments ，也没有 new.target 绑定： this 、 super 、arguments 、以及函数内部的 new.target 的值由外层最近的非箭头函数来决定（ super 详见第四章） 。</p>
</li>
<li><p>不能使用 new 去调用：箭头函数没有 [[Construct]] 方法，因此不能被用为构造函数，使用 new 调用箭头函数会抛出错误。</p>
</li>
<li><p>没有原型： 既然不能对箭头函数使用 new ，那么它也不需要原型，也就是没有prototype 属性。</p>
</li>
<li><p>不能更改 this ： this 的值在函数内部不能被修改，在函数的整个生命周期内其值会保持不变。</p>
</li>
<li><p>没有 arguments 对象：箭头函数没有 arguments 绑定，你必须依赖于具名参数或剩余参数来访问函数的参数。</p>
</li>
<li><p>不允许重复的具名参数：箭头函数不允许拥有重复的具名参数，无论是否在严格模式下；而相对来说，传统函数只有在严格模式下才禁止这种重复。</p>
</li>
</ol>
<p>产生这些差异是有理由的。首先并且最重要的是，在 JS 编程中 this 绑定是发生错误的常见根源之一，在嵌套的函数中有时会因为调用方式的不同，而导致丢失对外层 this 值的追踪，就可能会导致预期外的程序行为。其次，箭头函数使用单一的 this 值来执行代码，使得 JS 引擎可以更容易对代码的操作进行优化；而常规函数可能会作为构造函数使用，导致this 易变而不利优化。</p>
<p>其余差异也聚集在减少箭头函数内部的错误与不确定性，这样 JS 引擎也能更好地优化箭头函数的运行。</p>
<p>注意：箭头函数也拥有 name 属性，并且遵循与其他函数相同的规则</p>
<h2 id="箭头函数语法"><a href="#箭头函数语法" class="headerlink" title="箭头函数语法"></a>箭头函数语法</h2><p>箭头函数的语法可以有多种变体，取决于你要完成的目标。所有变体都以函数参数为开头，紧跟着的是箭头，再接下来则是函数体。参数与函数体都根据实际使用有不同的形式。例如，以下箭头函数接收单个参数并直接返回它：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reflect = <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line"><span class="comment">// 基本等价于：</span></span><br><span class="line"><span class="keyword">var</span> reflect = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当箭头函数只有单个参数时，该参数可以直接书写而不需要额外的语法；接下来是箭头以及箭头右边的表达式，该表达式会被计算并返回结果。即使此处没有明确的 return 语句，该箭头函数仍然会将所传入的参数返回出来。</p>
<p>如果需要传入多于一个的参数，就需要将它们放在括号内，就像这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class="line"><span class="comment">// 基本等价于：</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>sum() 函数简单地将两个参数相加并返回结果。此箭头函数与上面的 reflect() 之间唯一区别在于：此处的参数被封闭在括号内，相互之间使用逗号分隔，就像传统函数那样。</p>
<p>如果函数没有任何参数，那么在声明时就必须使用一对空括号，就像这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">"Nicholas"</span>;</span><br><span class="line"><span class="comment">// 基本等价于：</span></span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Nicholas"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当你想使用更传统的函数体、也就是可能包含多个语句的时候，需要将函数体用一对花括号进行包裹，并明确定义一个返回值，正如下面这个版本的 sum() ：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 基本等价于：</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>除了 arguments 对象不可用之外，几乎可将花括号内部的代码当做传统函数那样对待。若你想创建一个空函数，就必须使用空的花括号，就像这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doNothing = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// 基本等价于：</span></span><br><span class="line"><span class="keyword">var</span> doNothing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>花括号被用于表示函数的主体，它在你至今看到的例子中都工作正常。但若要箭头函数向外返回一个对象字面量，就必须将该字面量包裹在圆括号内，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">"Temp"</span> &#125;);</span><br><span class="line"><span class="comment">// 基本等价于：</span></span><br><span class="line"><span class="keyword">var</span> getTempItem = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    id: id,</span><br><span class="line">    name: <span class="string">"Temp"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>将对象字面量包裹在括号内，标示了括号内是一个字面量而不是函数体。</p>
<h2 id="创建立即调用函数表达式"><a href="#创建立即调用函数表达式" class="headerlink" title="创建立即调用函数表达式"></a>创建立即调用函数表达式</h2><p>JS 中使用函数的一种流行方式是创建立即调用函数表达式（immediately-invoked function expression ， IIFE ） 。 IIFE 允许你定义一个匿名函数并在未保存引用的情况下立刻调用它。</p>
<p>当你想创建一个作用域并与程序其他部分相隔离时，这种模式就很有用。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;(<span class="string">"Nicholas"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.getName()); <span class="comment">// "Nicholas"</span></span><br></pre></td></tr></table></figure></p>
<p>此代码中 IIFE 被用于创建一个包含 getName() 方法的对象。该方法使用 name 参数作为返回值，实际上让 name 成为所返回对象的一个私有成员。</p>
<p>你可以使用箭头函数来完成同样的事情，只要将其包裹在括号内即可：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="function">(<span class="params">(name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)(<span class="string">"Nicholas"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.getName()); <span class="comment">// "Nicholas"</span></span><br></pre></td></tr></table></figure></p>
<p>需要注意的是括号仅包裹了箭头函数的定义，并未包裹 (“Nicholas”) 。使用传统函数时，括号既可以连函数定义与参数调用一起包裹，也可以只用于包裹函数定义，箭头函数与此有别。</p>
<p>译注：使用传统函数时， (function(){/<em>函数体</em>/})(); 与 (function(){/<em>函数体</em>/}());<br>这两种方式都是可行的。但若使用箭头函数，则只有下面的写法是有效的： (() =&gt; {/<em>函数体</em>/})();</p>
<h2 id="没有-this-绑定"><a href="#没有-this-绑定" class="headerlink" title="没有 this 绑定"></a>没有 this 绑定</h2><p>JS 最常见的错误领域之一就是在函数内的 this 绑定。由于一个函数内部的 this 值会根据调用该函数时的上下文而改变，因此完全可能违背本意地影响了预期外的对象。研究如下例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> PageHandler = &#123;</span><br><span class="line">  id: <span class="string">"123456"</span>,</span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的 this 是 PageHandler</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="string">'first'</span>)</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 这里的 this 是 document</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="string">'secont'</span>)</span><br><span class="line">      <span class="keyword">this</span>.doSomething(event.type); <span class="comment">// 错误</span></span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  doSomething: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Handling "</span> + type + <span class="string">" for "</span> + <span class="keyword">this</span>.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>此代码的 PageHandler 对象被设计用于处理页面上的交互。调用 init() 方法以建立交互，并注册了一个事件处理函数来调用 this.doSomething() 。然而此代码并未按预期工作。</p>
<p>此处的 this 是对事件目标对象（ 也就是 document ） 的一个引用，而没有绑定到 PageHandler 上，因此调用 this.doSomething() 会被中断。若试图运行此代码，你将会在事件处理函数被触发时得到一个错误，因为 document 对象并不存在 doSomething() 方法。</p>
<p>你可以明确使用 bind() 方法将函数的 this 值绑定到 PageHandler 上，以修正这段代码，就像这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> PageHandler = &#123;</span><br><span class="line">  id: <span class="string">"123456"</span>,</span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>, (<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.doSomething(event.type); <span class="comment">// 没有错误</span></span><br><span class="line">    &#125;).bind(<span class="keyword">this</span>), <span class="literal">false</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  doSomething: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Handling "</span> + type + <span class="string">" for "</span> + <span class="keyword">this</span>.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>现在此代码能像预期那样运行，但看起来有点奇怪。通过调用 bind(this) ，你实际上创建了一个新函数，它的 this 被绑定到当前 this ，也就是 PageHandler 。为了避免额外创建一个函数，修正此代码的更好方式是使用箭头函数。</p>
<p>箭头函数没有 this 绑定，意味着箭头函数内部的 this 值只能通过查找作用域链来确定。如果箭头函数被包含在一个非箭头函数内，那么 this 值就会与该函数的相等；否则，this 值就会是全局对象（ 在浏览器中是 window ，在 nodejs 中是 global ） 。你可以使用箭头函数来书写如下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> PageHandler = &#123;</span><br><span class="line">  id: <span class="string">"123456"</span>,</span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>, event =&gt; <span class="keyword">this</span>.doSomething(event.type), <span class="literal">false</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  doSomething: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Handling "</span> + type + <span class="string">" for "</span> + <span class="keyword">this</span>.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>本例中的事件处理函数是一个调用 this.doSomething() 的箭头函数，它的 this 值与 init() 方法的相同，因此这个版本的代码的工作方式与使用了 bind(this) 的上个例子相似。尽管 doSomething() 方法并不返回任何值，它仍然是函数体内唯一被执行的语句，因此无需使用花扩花来包裹它。</p>
<p>箭头函数被设计为“抛弃型”的函数，因此不能被用于定义新的类型； prototype 属性的缺失让这个特性显而易见。对箭头函数使用 new 运算符会导致错误，正如下例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyType = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,</span><br><span class="line">object = <span class="keyword">new</span> MyType(); <span class="comment">// 错误：你不能对箭头函数使用 'new'</span></span><br></pre></td></tr></table></figure></p>
<p>由于 MyType() 是一个箭头函数，它就不存在 [[Construct]] 方法，此代码调用 newMyType() 的操作也因此失败。了解箭头函数不能被用于 new 的特性后， JS 引擎就能进一步对其进行优化。</p>
<p>同样，由于箭头函数的 this 值由包含它的函数决定，因此不能使用 call() 、 apply()或 bind() 方法来改变其 this 值。</p>
<h2 id="箭头函数与数组"><a href="#箭头函数与数组" class="headerlink" title="箭头函数与数组"></a>箭头函数与数组</h2><p>箭头函数的简洁语法也让它成为进行数组操作的理想选择。例如，若你想使用自定义比较器来对数组进行排序，通常会这么写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = values.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这里为一个非常简单的工序使用了过多代码，可以比较一下使用了箭头函数的更简洁版本：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = values.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br></pre></td></tr></table></figure></p>
<p>能使用回调函数的数组方法，例如 sort() 、 map() 与 reduce() 方法，都能从箭头函数的简洁语法中获得收益，它用简单的代码实现看似复杂的需求。</p>
<h2 id="没有-arguments-绑定"><a href="#没有-arguments-绑定" class="headerlink" title="没有 arguments 绑定"></a>没有 arguments 绑定</h2><p>尽管箭头函数没有自己的 arguments 对象，但仍然能访问包含它的函数的 arguments 对象。无论此后箭头函数在何处执行，该对象都是可用的。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArrowFunctionReturningFirstArg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arrowFunction = createArrowFunctionReturningFirstArg(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arrowFunction()); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></p>
<p>在 createArrowFunctionReturningFirstArg() 内部， arguments[0] 元素被已创建的箭头函数 arrowFunction 所引用，该引用包含了传递给 createArrowFunctionReturningFirstArg() 函数的首个参数。当箭头函数在此后被执行时，它返回了 5 ，正是传递给createArrowFunctionReturningFirstArg() 的首个参数。尽管箭头函数 arrowFunction 已不在创建它的函数的作用域内，但由于 arguments 标识符的作用域链解析，当时的 arguments 对象依然可被访问。</p>
<h2 id="识别箭头函数"><a href="#识别箭头函数" class="headerlink" title="识别箭头函数"></a>识别箭头函数</h2><p>尽管语法不同，但箭头函数依然属于函数，并能被照常识别。研究如下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> comparator = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> comparator); <span class="comment">// "function"</span></span><br><span class="line"><span class="built_in">console</span>.log(comparator <span class="keyword">instanceof</span> <span class="built_in">Function</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>console.log() 的输出揭示了 typeof 与 instanceof 在作用于箭头函数时的行为，与作用在其他函数上完全一致。</p>
<p>就像对待其他函数那样，你仍然可以对箭头函数使用 call() 、 apply() 与 bind() 方法，只是箭头函数的 this 绑定并不会受影响。这里有几个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class="line"><span class="built_in">console</span>.log(sum.call(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(sum.apply(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>])); <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">var</span> boundSum = sum.bind(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(boundSum()); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<p>sum() 函数被使用 call() 与 apply() 方法调用并传入了参数。 bind() 方法被用于创建 boundSum() ，后者的两个参数已被绑定为 1 与 2 ，因此调用时不再需要传入这两个参数。</p>
<p>箭头函数能在任意位置，包括使用回调函数时，替代你当前使用的匿名函数。下一节介绍的内容是 ES6 的另一项主要改进，不过该内容完全是内部实现，并没有使用新语法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>函数在 ES6 中并未经历巨大变化，然而一系列增量改进使得函数更易使用。</p>
<p>在特定参数未被传入时，函数的默认参数允许你更容易指定需要使用的值。而在 ES6 之前，为了检查参数是已否已提供，并在未提供时为其分配一个预设值，需要在函数内书写一些额外代码。</p>
<p>剩余参数允许你将余下的所有参数放入指定数组。使用真正的数组，并可以根据需要指定包含哪些参数，让剩余参数成为比 arguments 更为灵活的解决方案。</p>
<p>扩展运算符是剩余参数的好伙伴，允许在调用函数时将数组解构为分离的参数。在 ES6 之前，要将数组的元素用作独立参数传给函数只有两种办法：手动指定每一个参数，或者使用apply() 方法。有了扩展运算符，你就能轻易将数组传递给函数而无须顾虑该函数的 this绑定。</p>
<p>新增的 name 属性让你在调试与执行方面能更容易地识别函数。此外， ES6 正式定义了块级函数的行为，因此在严格模式下它们不再是语法错误。</p>
<p>在 ES6 中，函数的行为被 [[Call]] 与 [[Construct]] 方法所定义，前者对应普通的函数执行，后者则对应着使用了 new 的调用。 new.target 元属性也能用于判断函数被调用时是否使用了 new 。</p>
<p>ES6 函数的最大变化就是增加了箭头函数。箭头函数被设计用于替代匿名函数表达式，它拥有更简洁的语法、词法级的 this 绑定，并且没有 arguments 对象。此外，箭头函数不能修改它们的 this 绑定，因此不能被用作构造器。、</p>
<p>尾调用优化允许某些函数的调用被优化，以保持更小的调用栈、使用更少的内存，并防止堆栈溢出。当能进行安全优化时，它会由引擎自动应用。不过你可以考虑重写递归函数，以便利用这种优化。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/11/21/深入-ES6-03-Promise-与异步编程/">深入-ES6-03 Promise 与异步编程</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-11-21
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="异步编程的背景"><a href="#异步编程的背景" class="headerlink" title="异步编程的背景"></a>异步编程的背景</h2><p>JS 引擎建立在单线程事件循环的概念上。单线程（Single-threaded ） 意味着同一时刻只能执行一段代码，与 Java 或 C++ 这种允许同时执行多段不同代码的多线程语言形成了反差。</p>
<p>多段代码可以同时访问或修改状态，维护并保护这些状态就变成了难题，这也是基于多线程的软件中出现 bug 的常见根源之一。<br>JS 引擎在同一时刻只能执行一段代码，所以引擎无须留意那些“可能”运行的代码。代码会被放置在作业队列（job queue ） 中，每当一段代码准备被执行，它就会被添加到作业队列。当 JS 引擎结束当前代码的执行后，事件循环就会执行队列中的下一个作业。事件循环（ event loop ） 是 JS 引擎的一个内部处理进程，能监视代码的执行并管理作业队列。要记住既然是一个队列，作业就会从队列中的第一个开始，依次运行到最后一个。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/11/21/深入-ES6-02-解构/">深入 ES6-02 解构</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-11-21
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h1 id="第五章-解构：更方便的数据访问"><a href="#第五章-解构：更方便的数据访问" class="headerlink" title="第五章 解构：更方便的数据访问"></a>第五章 解构：更方便的数据访问</h1><h2 id="解构为何有用？"><a href="#解构为何有用？" class="headerlink" title="解构为何有用？"></a>解构为何有用？</h2><p>在 ES5 及更早版本中，从对象或数组中获取信息，并将特定数据存入本地变量，需要书写许多相似的代码。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">  repeat: <span class="literal">true</span>,</span><br><span class="line">  save: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 从对象中提取数据</span></span><br><span class="line"><span class="keyword">let</span> repeat = options.repeat,</span><br><span class="line">    save = options.save;</span><br></pre></td></tr></table></figure></p>
<p>此代码提取了 options 对象的 repeat 与 save 值，并将其存在同名的本地变量上。这段代码虽然看似简单，但想象一下若有大量变量需要处理，就必须逐个为其赋值；并且若需要遍历一个嵌套的数据结构以寻找信息，有可能会为了一点数据而挖掘整个结构。</p>
<p>这就是 ES6 为何要给对象与数组添加解构。当把数据结构分解为更小的部分时，从中提取所需数据就会变得容易许多。很多语言都能用精简的语法来实现解构，让它更易使用。实际上ddxxES6 的解构使用了你早已熟悉的语法，也就是对象与数组的字面量语法。</p>
<h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><p>对象解构语法在赋值语句的左侧使用了对象字面量，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">  type: <span class="string">"Identifier"</span>,</span><br><span class="line">  name: <span class="string">"foo"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; type, name &#125; = node;</span><br><span class="line"><span class="built_in">console</span>.log(type); <span class="comment">// "Identifier"</span></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// "foo</span></span><br></pre></td></tr></table></figure></p>
<p>在此代码中， node.type 的值被存储到 type 本地变量中， node.name 的值则存储到name 变量中。此语法与第四章介绍过的属性简写相同。 type 与 name 标识符既声明了本地变量，也读取了对象的相应属性值。</p>
<h3 id="切勿遗忘初始化器"><a href="#切勿遗忘初始化器" class="headerlink" title="切勿遗忘初始化器"></a>切勿遗忘初始化器</h3><p>当使用解构配合 var 、 let 或 const 来声明变量时，必须提供初始化器（ 即等号右边的值） 。下面的代码都会因为缺失初始化器而抛出错误：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法错误！</span></span><br><span class="line"><span class="keyword">var</span> &#123; type, name &#125;;</span><br><span class="line"><span class="comment">// 语法错误！</span></span><br><span class="line"><span class="keyword">let</span> &#123; type, name &#125;;</span><br><span class="line"><span class="comment">// 语法错误！</span></span><br><span class="line"><span class="keyword">const</span> &#123; type, name &#125;;</span><br></pre></td></tr></table></figure></p>
<p>无论是否使用解构， const 始终要求为变量提供初始化器；而 var 与 let 则仅在使用解构时才作此要求。</p>
<h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>以上对象解构示例都用于变量声明。不过，也可以在赋值的时候使用解构。有时或许会在变量声明之后再更改它们的值，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">      type: <span class="string">"Identifier"</span>,</span><br><span class="line">      name: <span class="string">"foo"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    type = <span class="string">"Literal"</span>,</span><br><span class="line">    name = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 使用解构来分配不同的值</span></span><br><span class="line">(&#123; type, name &#125; = node);</span><br><span class="line"><span class="built_in">console</span>.log(type); <span class="comment">// "Identifier"</span></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// "foo</span></span><br></pre></td></tr></table></figure></p>
<p>在本例中， node 对象的 type 与 name 属性在声明时被初始化，而两个同名变量也被声明并初始化为其他值。接下来一行使用了解构表达式，通过读取 node 对象来更改这两个变量的值。</p>
<p>注意你必须用圆括号包裹解构赋值语句，这是因为暴露的花括号会被解析为代码块语句，而块语句不允许在赋值操作符（ 即等号） 左侧出现。圆括号标示了内部的花括号并不是块语句、而应该被解释为表达式，从而完成赋值操作。</p>
<p>解构赋值表达式的值为表达式右侧（ 在 = 之后） 的值。也就是说在任何需要使用值的位置，都可以使用解构赋值表达式。例如，传递值给函数:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">      type: <span class="string">"Identifier"</span>,</span><br><span class="line">      name: <span class="string">"foo"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    type = <span class="string">"Literal"</span>,</span><br><span class="line">    name = <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputInfo</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value === node); <span class="comment">// true</span></span><br><span class="line">&#125; </span><br><span class="line">outputInfo(&#123; type, name &#125; = node);</span><br><span class="line"><span class="built_in">console</span>.log(type); <span class="comment">// "Identifier"</span></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// "foo"</span></span><br></pre></td></tr></table></figure></p>
<p>outputInfo() 函数被调用时使用了一个解构赋值表达式作为参数。该表达式计算结果为node ，也就是表达式右侧的值。</p>
<p>对 type 与 name 的赋值正常进行，同时 node 也被传入了 outputInfo() 函数。<br>当解构赋值表达式的右侧（ = 后面的表达式） 的计算结果为 null 或 undefined 时，会抛出错误。因为任何读取 null 或 undefined 的属性的企图都会导致“运行时”错误（ runtime error ） 。</p>
<h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>当你使用解构赋值语句时，如果所指定的本地变量在对象中没有找到同名属性，那么该变量会被赋值为 undefined 。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">      type: <span class="string">"Identifier"</span>,</span><br><span class="line">      name: <span class="string">"foo"</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; type, name, value &#125; = node;</span><br><span class="line"><span class="built_in">console</span>.log(type); <span class="comment">// "Identifier"</span></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// "foo"</span></span><br><span class="line"><span class="built_in">console</span>.log(value); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p>
<p>此代码定义了一个额外的本地变量 value ，并试图对其赋值。然而 node 对象中不存在同名属性，因此 value 不出预料地被赋值为 undefined 。</p>
<p>你可以选择性地定义一个默认值，以便在指定属性不存在时使用该值。若要这么做，需要在属性名后面添加一个等号并指定默认值，就像这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">      type: <span class="string">"Identifier"</span>,</span><br><span class="line">      name: <span class="string">"foo"</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; type, name, value = <span class="literal">true</span> &#125; = node;</span><br><span class="line"><span class="built_in">console</span>.log(type); <span class="comment">// "Identifier"</span></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// "foo"</span></span><br><span class="line"><span class="built_in">console</span>.log(value); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>在此例中，变量 value 被指定了一个默认值 true ，只有在 node 的对应属性缺失、或对应的属性值为 undefined 的情况下，该默认值才会被使用。由于此处不存在 node.value 属性，变量 value 就使用了该默认值。这种工作方式很像函数参数的默认值（ 详见第三章）</p>
<h2 id="赋值给非同名本地变量"><a href="#赋值给非同名本地变量" class="headerlink" title="赋值给非同名本地变量"></a>赋值给非同名本地变量</h2><p>至此的每个解构赋值示例都使用了对象中的属性名作为本地变量的名称，例如，把<br>node.type 的值存储到 type 变量上。使用相同名称时这么做没问题，但若希望使用其他名称呢？ ES6 有一个扩展语法，允许你在给本地变量赋值时使用一个不同的名称，而且该语法看上去就像是使用对象字面量的非简写的属性初始化。此处有个示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">      type: <span class="string">"Identifier"</span>,</span><br><span class="line">      name: <span class="string">"foo"</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">type</span>: localType, <span class="attr">name</span>: localName &#125; = node;</span><br><span class="line"><span class="built_in">console</span>.log(localType); <span class="comment">// "Identifier"</span></span><br><span class="line"><span class="built_in">console</span>.log(localName); <span class="comment">// "foo</span></span><br></pre></td></tr></table></figure></p>
<p>此代码使用了解构赋值来声明 localType 与 localName 变量，分别赋予了 node.type 与 node.name 属性的值。 </p>
<p>type: localType 这种语法表示欲读取名为 type 的属性，并将它的值存储在变量 localType 上。该语法实际上与传统对象字面量语法相反，传统语法将名称放在冒号左侧、值放在冒号右侧；而在本例中，则是名称在右侧，需要读取的位置（ 对象属性<br>名） 则被放在了左侧</p>
<p>你也可以给变量别名添加默认值，依然是在本地变量名称后添加等号与默认值，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">      type: <span class="string">"Identifier"</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">type</span>: localType, <span class="attr">name</span>: localName = <span class="string">"bar"</span> &#125; = node;</span><br><span class="line"><span class="built_in">console</span>.log(localType); <span class="comment">// "Identifier"</span></span><br><span class="line"><span class="built_in">console</span>.log(localName); <span class="comment">// "bar"</span></span><br></pre></td></tr></table></figure></p>
<p>此处的 localName 变量拥有一个默认值，由于 node.name 属性并不存在，该变量最终被赋为默认值 “bar” 。</p>
<p>到此为止，你已经看到如何对属性值为基本类型值的对象进行解构，而对象解构也可被用于从嵌套的对象结构中提取属性值。（ 嵌套对象表示对象的属性可能还是一个对象）</p>
<h2 id="嵌套的对象解构"><a href="#嵌套的对象解构" class="headerlink" title="嵌套的对象解构"></a>嵌套的对象解构</h2><p>使用类似于对象字面量的语法，可以深入到嵌套的对象结构中去提取所需数据。此处有个示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">      type: <span class="string">"Identifier"</span>,</span><br><span class="line">      name: <span class="string">"foo"</span>,</span><br><span class="line">      loc: &#123;</span><br><span class="line">        start: &#123;</span><br><span class="line">          line: <span class="number">1</span>,</span><br><span class="line">          column: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        end: &#123;</span><br><span class="line">          line: <span class="number">1</span>,</span><br><span class="line">          column: <span class="number">4</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">loc</span>: &#123; start &#125;&#125; = node;</span><br><span class="line"><span class="built_in">console</span>.log(start.line); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(start.column); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p>本例中的解构模式使用了花括号，表示应当下探到 node 对象的 loc 属性内部去寻找<br>start 属性。记住上一节介绍过的，每当有一个冒号在解构模式中出现，就意味着冒号之前的标识符代表需要检查的位置，而冒号右侧则是赋值的目标。当冒号右侧存在花括号时，表示目标被嵌套在对象的更深层次中。</p>
<p>更进一步，在对象的嵌套解构中同样能为本地变量使用不同的名称：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">      type: <span class="string">"Identifier"</span>,</span><br><span class="line">      name: <span class="string">"foo"</span>,</span><br><span class="line">      loc: &#123;</span><br><span class="line">        start: &#123;</span><br><span class="line">          line: <span class="number">1</span>,</span><br><span class="line">          column: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        end: &#123;</span><br><span class="line">          line: <span class="number">1</span>,</span><br><span class="line">          column: <span class="number">4</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">// 提取 node.loc.start</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">loc</span>: &#123; <span class="attr">start</span>: localStart &#125;&#125; = node;</span><br><span class="line"><span class="built_in">console</span>.log(localStart.line); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(localStart.column); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p>在此版本的代码中， node.loc.start 的值被存储到一个新的本地变量 localStart 上，解构模式可以被嵌套在任意深度的层级，并且在每个层级的功能都一致.</p>
<p>对象解构十分强大并有很多可用形式，而数组解构则提供了一些独特的能力，用于提取数组中的信息。</p>
<h3 id="语法陷阱"><a href="#语法陷阱" class="headerlink" title="语法陷阱"></a>语法陷阱</h3><p>使用嵌套的解构时需要小心，因为你可能无意中就创建了一个没有任何效果的语句。空<br>白花括号在对象解构中是合法的，然而它不会产生任何效果。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有变量被声明！</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">loc</span>: &#123;&#125; &#125; = node;</span><br></pre></td></tr></table></figure></p>
<p>在此语句中并未声明任何变量绑定。由于花括号在右侧， loc 被作为需检查的位置来使用，并不会创建变量绑定。这种情况更应当用等号来定义一个默认值，而不是用冒号来定义一个位置。这种语法将来可能会被定义为无效语法，然而现在它只是需要规避的一个陷阱。</p>
<h2 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h2><p>数组解构的语法看起来与对象解构非常相似，只是将对象字面量替换成了数组字面量。数组解构时，解构作用在数组内部的位置上，而不是作用在对象的属性名上，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</span><br><span class="line"><span class="keyword">let</span> [ firstColor, secondColor ] = colors;</span><br><span class="line"><span class="built_in">console</span>.log(firstColor); <span class="comment">// "red"</span></span><br><span class="line"><span class="built_in">console</span>.log(secondColor); <span class="comment">// "green"</span></span><br></pre></td></tr></table></figure></p>
<p>此处数组解构从 colors 数组中取出了 “red” 与 “green” ，并将它们赋值给 fristColor 与 secondColor 变量。这些值根据它们在数组中的位置被选择，实际的变量名称是随意的，与位置无关。任何没有在解构模式中明确指定的项都会被忽略。记住，数组本身并没有发生任何改变</p>
<p>你也可以在解构模式中忽略一些项，只给所需的项提供变量名。例如，若只想获取数组中的第三个元素，那么不必给前两项提供变量名。如下所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</span><br><span class="line"><span class="keyword">let</span> [ , , thirdColor ] = colors;</span><br><span class="line"><span class="built_in">console</span>.log(thirdColor); <span class="comment">// "blue"</span></span><br></pre></td></tr></table></figure></p>
<p>此代码使用了解构赋值来获取 colors 的第三个项。模式中 thirdColor 之前的逗号，是为数组前面的项提供的占位符。使用这种方法，你就可以轻易从数组任意位置取出值，而无须给其他项提供变量名。</p>
<p>与对象解构相似，在使用 var 、 let 、 const 进行数组解构时，必须提供初始化<br>器。</p>
<h2 id="解构赋值-1"><a href="#解构赋值-1" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>你可以在赋值表达式中使用数组解构，但是与对象解构不同，不必将表达式包含在圆括号内，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ],</span><br><span class="line">firstColor = <span class="string">"black"</span>,</span><br><span class="line">secondColor = <span class="string">"purple"</span>;</span><br><span class="line">[ firstColor, secondColor ] = colors;</span><br><span class="line"><span class="built_in">console</span>.log(firstColor); <span class="comment">// "red"</span></span><br><span class="line"><span class="built_in">console</span>.log(secondColor); <span class="comment">// "green"</span></span><br></pre></td></tr></table></figure></p>
<p>此代码中解构赋值的工作方式与上例相似，唯一区别是 firstColor 与secondColor 变量已经被声明过了。大多数情况下，对数组解构赋值仅需了解以上知识，但还有一个实用的小技巧。</p>
<p>数组解构赋值有一个非常独特的用法，能轻易地互换两个变量的值。互换变量值在排序算法中十分常用，而在 ES5 中需要使用第三个变量作为临时变量，正如下例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 ES5 中互换值</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>,</span><br><span class="line">    b = <span class="number">2</span>,</span><br><span class="line">    tmp;</span><br><span class="line">tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p>其中的 tmp 变量对于互换 a 与 b 的值来说是必要的。然而若使用数组解构赋值，就不再需要这个额外变量。以下演示了在 ES6 中如何互换变量值：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 ES6 中互换值</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>,</span><br><span class="line">    b = <span class="number">2</span>;</span><br><span class="line">[ a, b ] = [ b, a ];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p>本例中的数组解构赋值看起来如同镜像。赋值语句左侧（ 即等号之前） 的解构模式如同其他数组解构的范例，右侧则是为了互换而临时创建的数组字面量。 b 与 a 的值分别被复制到临时数组的第一个与第二个位置，对该数组进行解构，于是两个变量就互换了它们的值。</p>
<p>与对象解构赋值相同，若等号右侧的计算结果为 null 或 undefined ，那么数组解构赋值表达式也会抛出错误。</p>
<h2 id="默认值-1"><a href="#默认值-1" class="headerlink" title="默认值"></a>默认值</h2><p>数组解构赋值同样允许在数组任意位置指定默认值。当指定位置的项不存在、或其值为<br>undefined ，那么该默认值就会被使用。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span> ];</span><br><span class="line"><span class="keyword">let</span> [ firstColor, secondColor = <span class="string">"green"</span> ] = colors;</span><br><span class="line"><span class="built_in">console</span>.log(firstColor); <span class="comment">// "red"</span></span><br><span class="line"><span class="built_in">console</span>.log(secondColor); <span class="comment">// "green"</span></span><br></pre></td></tr></table></figure></p>
<p>此代码的 colors 数组只有一个项，因此没有能与 secondColor 匹配的项，又由于此处有个默认值， secondColor 的值就被设置为 “green” 而非 undefined 。</p>
<h2 id="嵌套的解构"><a href="#嵌套的解构" class="headerlink" title="嵌套的解构"></a>嵌套的解构</h2><p>与解构嵌套的对象相似，可以用类似的方式来解构嵌套的数组。在整个解构模式中插入另一个数组模式，解构操作就会下探到嵌套的数组中，就像这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, [ <span class="string">"green"</span>, <span class="string">"lightgreen"</span> ], <span class="string">"blue"</span> ];</span><br><span class="line"><span class="comment">// 随后</span></span><br><span class="line"><span class="keyword">let</span> [ firstColor, [ secondColor ] ] = colors;</span><br><span class="line"><span class="built_in">console</span>.log(firstColor); <span class="comment">// "red"</span></span><br><span class="line"><span class="built_in">console</span>.log(secondColor); <span class="comment">// "green"</span></span><br></pre></td></tr></table></figure></p>
<h2 id="剩余项"><a href="#剩余项" class="headerlink" title="剩余项"></a>剩余项</h2><p>第三章介绍过函数的剩余参数，而数组解构有个类似的、名为剩余项（rest items ）的概念，它使用 … 语法来将剩余的项目赋值给一个指定的变量，此处有个范例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</span><br><span class="line"><span class="keyword">let</span> [ firstColor, ...restColors ] = colors;</span><br><span class="line"><span class="built_in">console</span>.log(firstColor); <span class="comment">// "red"</span></span><br><span class="line"><span class="built_in">console</span>.log(restColors.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(restColors[<span class="number">0</span>]); <span class="comment">// "green"</span></span><br><span class="line"><span class="built_in">console</span>.log(restColors[<span class="number">1</span>]); <span class="comment">// "blue"</span></span><br></pre></td></tr></table></figure></p>
<p>colors 数组的第一项被赋值给了 firstColor 变量，而剩余的则赋值给了一个新的 restColors 数组； restColors 数组有两个项： “green” 与 “blue” 。若要在取出特定项之余保留剩余的值，则剩余项就会非常有用，但它还有另一个有用的功能。</p>
<p>在 JS 中，方便地克隆数组是个明显被遗漏的功能。在 ES5 中开发者往往使用一个简单的方式来克隆数组，也就是用 concat() 方法，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 ES5 中克隆数组</span></span><br><span class="line"><span class="keyword">var</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</span><br><span class="line"><span class="keyword">var</span> clonedColors = colors.concat();</span><br><span class="line"><span class="built_in">console</span>.log(clonedColors); <span class="comment">//"[red,green,blue]"</span></span><br></pre></td></tr></table></figure></p>
<p>尽管 concat() 方法的本意是合并两个数组，但若不使用任何参数来调用此方法，就会获得原数组的一个克隆品。而在 ES6 中，你可以使用剩余项的语法来达到同样效果。实现如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 ES6 中克隆数组</span></span><br><span class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</span><br><span class="line"><span class="keyword">let</span> [ ...clonedColors ] = colors;</span><br><span class="line"><span class="built_in">console</span>.log(clonedColors); <span class="comment">//"[red,green,blue]"</span></span><br></pre></td></tr></table></figure></p>
<p>在本例中，剩余项被用于将 colors 数组的值复制到 clonedColors 数组中。虽然从表面上来看，这么做未必能让开发者复制数组的意图体现得比使用 concat() 方法更明显，但这依然是个值得关注的技巧。</p>
<p>剩余项必须是数组解构模式中最后的部分，之后不能再有逗号，否则就会有语法错误。</p>
<h2 id="混合解构"><a href="#混合解构" class="headerlink" title="混合解构"></a>混合解构</h2><p>对象与数组解构能被组合使用，以创建更复杂的解构表达式。在对象与数组混合而成的结构中，能在其中准确提取所需的信息片段。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">      type: <span class="string">"Identifier"</span>,</span><br><span class="line">      name: <span class="string">"foo"</span>,</span><br><span class="line">      loc: &#123;</span><br><span class="line">        start: &#123;</span><br><span class="line">          line: <span class="number">1</span>,</span><br><span class="line">          column: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        end: &#123;</span><br><span class="line">          line: <span class="number">1</span>,</span><br><span class="line">          column: <span class="number">4</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      range: [<span class="number">0</span>, <span class="number">3</span>]</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">loc</span>: &#123; start &#125;, <span class="attr">range</span>: [ startIndex ] &#125; = node;</span><br><span class="line"><span class="built_in">console</span>.log(start.line); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(start.column); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(startIndex); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></p>
<p>此代码将 node.loc.start 与 node.range[0] 提取出来，并将它们的值分别存储到 start 与 startIndex 上。要记住解构模式中的 loc: 与 range: 只是对应于 node 对象中属性的位置。混合使用对象与数组解构， node 的任何部分都能提取出来。对于从 JOSN 配置结构中抽取数据来说，这种方法尤其有用，因为它不需要探索整个结构.</p>
<h2 id="参数解构"><a href="#参数解构" class="headerlink" title="参数解构"></a>参数解构</h2><p>解构还有一个特别有用的场景，即在传递函数参数时。当 JS 的函数接收大量可选参数时，一种常用模式是创建一个包含附加参数的 options 对象，就像这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// options 上的属性表示附加参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value,  options</span>) </span>&#123;</span><br><span class="line">  options = options || &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> secure = options.secure,</span><br><span class="line">      path = options.path,</span><br><span class="line">      domain = options.domain,</span><br><span class="line">      expires = options.expires;</span><br><span class="line"><span class="comment">// 设置 cookie 的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第三个参数映射到 options</span></span><br><span class="line">setCookie(<span class="string">"type"</span>, <span class="string">"js"</span>, &#123;</span><br><span class="line">  secure: <span class="literal">true</span>,</span><br><span class="line">  expires: <span class="number">60000</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>很多 JS 库都包含了与此例 setCookie()类似的函数。在此函数内， name 与 value 参数是必需的，而 secure 、 path 、 domain 与 expires 则可选。并且由于此处对其余数据并没有顺序要求，将它们作为 options 对象的特定属性会更有效，避免列出一堆额外的具名参数。虽然这种方法有用，但无法仅通过查看函数定义就判断出函数所期望的输入，你必须阅读函数体的代码。</p>
<p>参数解构提供了更清楚标明函数期望输入的替代方案。它使用对象或数组解构的模式替代了具名参数。请查看下例中重写版本的 setCookie() 函数以了解实际效果：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, &#123; secure, path, domain, expires &#125;</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 设置 cookie 的代码</span></span><br><span class="line">&#125;</span><br><span class="line">setCookie(<span class="string">"type"</span>, <span class="string">"js"</span>, &#123;</span><br><span class="line">secure: <span class="literal">true</span>,</span><br><span class="line">expires: <span class="number">60000</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>此函数的行为类似上例，但此时第三个参数使用了解构来抽取必要的数据。现在对于<br>setCookie() 函数的使用者来说，解构参数之外的参数明显是必需的；而可选项目存在于额外的参数对象中，这同样显而易见；同时，若使用了第三个参数，其中应当包含什么值也相当明确。解构参数在未传递值的情况下会被设为 undefined ，类似于常规参数</p>
<p>参数解构拥有此前你在本章已经学过的其他解构方式的所有能力。可以在其中使用默认<br>参数、混合解构，或为变量重命名</p>
<h2 id="解构参数不可缺失"><a href="#解构参数不可缺失" class="headerlink" title="解构参数不可缺失"></a>解构参数不可缺失</h2><p>参数解构有一个怪异之处，在默认情况下，调用函数时未给参数解构传值会抛出错误。例如，用以下方式调用上例中的 setCookie() 函数就会出错：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 出错！</span></span><br><span class="line">setCookie(<span class="string">"type"</span>, <span class="string">"js"</span>);</span><br></pre></td></tr></table></figure></p>
<p>调用时第三个参数缺失了，它的值就变成了 undefined 。这导致了一个错误，因为参数解构实际上只是解构声明的简写。当 setCookie() 函数被调用时， JS 引擎实际上是这么做的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, options</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> &#123; secure, path, domain, expires &#125; = options;</span><br><span class="line"><span class="comment">// 设置 cookie 的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>既然解构在右侧的值为 null 或  undefined 时会抛出错误，那么未向 setCookie() 函数传递第三个参数也就同样会出错</p>
<p>若解构的参数是必选参数，那么上述特性并不会令人困扰。但若期望它是可选的，就需要给解构的参数提供默认值来解决问题，就像这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, &#123; secure, path, domain, expires &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此例为第三个参数提供了一个空对象作为其默认值，也就意味着若未向 setCookie() 函数传递第三个参数，则 secure 、path 、 domain 与 expires 的值全都会是 undefined ，此时不会有错误被抛出。</p>
<h2 id="参数解构的默认值"><a href="#参数解构的默认值" class="headerlink" title="参数解构的默认值"></a>参数解构的默认值</h2><p>你可以为参数解构提供可解构的默认值，就像在解构赋值时所做的那样，只需在其中每个参数后面添加等号并指定默认值即可。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value,</span></span></span><br><span class="line"><span class="function"><span class="params">  &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    secure = false,</span></span></span><br><span class="line"><span class="function"><span class="params">    path = <span class="string">"/"</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    domain = <span class="string">"example.com"</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    expires = new Date(Date.now(</span>) + 360000000)</span></span><br><span class="line"><span class="function">  &#125; = </span>&#123;&#125;</span><br><span class="line">) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此代码中参数解构给每个属性都提供了默认值，所以你可以避免检查指定属性是否已被传入。而整个解构的参数同样有一个默认值，即一个空对象，令该参数成为可选参数。这么做使得函数声明看起来比平时要复杂一些，但只是为确保每个参数都有可用的值而付出的微小代价.</p>
<p>译注：<br>上面的参数解构只有一个缺点，也就是当传入参数值为 null 时会引发程序异常。只有<br>null 与 undefined 是无法被解构的，而传入 undefined 会触发默认参数的使用条<br>件，从而避免了异常；但传入 null 就不会有这么幸运了，它既不会触发默认参数，也<br>不能被解构，从而导致异常。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>解构让 JS 操作对象与数组变得更容易。使用熟悉的对象字面量与数组字面量语法，可以将数据结构分离并只获取所需信息。对象解构模式允许你从对象中进行提取，而数组模式则能用于数组。<br>对象与数组解构都能在属性或项未定义时为其提供默认值；在赋值表达式右侧的值为 null 或 undefined 时，两种模式都会抛出错误。你也可以在深层嵌套的数据结构中使用对象与数组解构，下探到该结构的任意深度。</p>
<p>使用 var 、 let 或 const 的解构声明来创建变量，就必须提供初始化器。解构赋值能替代其他赋值，并且允许解构到对象属性或已有变量上。参数解构使用解构语法作为函数的参数，让“选项”（options ） 对象更加清晰透明，实际所需数据可以与具名参数一并列出。解构的参数可以是对象模式、数组模式或混合模式，并能使用解构的所有特性。</p>

        
      
    </div>

    

    

  </article>

    
  </section>

  
  <nav class="pagination">
    
      <a class="prev" href="/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">上一页</span>
      </a>
    
    
      <a class="next" href="/page/3/">
        <span class="next-text">下一页</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


          </div>
          

        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    
    
      
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2017

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">我是你豆子欧巴</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  </body>
</html>
