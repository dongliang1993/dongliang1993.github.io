<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">















  <link rel="alternate" href="/default" title="我是你豆子欧巴">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0" />



<link rel="canonical" href="http://yoursite.com/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />




  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>





  <script src="//cdn1.lncld.net/static/js/3.1.1/av-min.js"></script>
  <script id="leancloud">
    AV.init({
      appId: "BFBKC2C7jVkD7w4SCRF57xom-gzGzoHsz",
      appKey: "elTqQP3tDP3wAwIFKyE57fHe"
    });
  </script>





    <title> 我是你豆子欧巴 </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">我是你豆子欧巴</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            Home
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            Categories
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            About
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">我是你豆子欧巴</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              Home
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              Archives
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              Tags
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              Categories
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              About
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/04/12/面向对象编程-笔记/">面向对象编程 -- 笔记</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-04-12
        </span>
        
        
        <div class="post-visits"
             data-url="/2018/04/12/面向对象编程-笔记/"
             data-title="面向对象编程 -- 笔记">
            阅读次数
          </div>
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="构造函数与-new-命令"><a href="#构造函数与-new-命令" class="headerlink" title="构造函数与 new 命令"></a>构造函数与 new 命令</h2><h3 id="1-对象是什么"><a href="#1-对象是什么" class="headerlink" title="1. 对象是什么"></a>1. 对象是什么</h3><ul>
<li>面向对象编程（Object Oriented Programming，缩写为 OOP）</li>
<li>“对象”（object）到底是什么<ul>
<li>对象是单个实物的抽象</li>
<li>对象是一个容器，封装了属性（property）和方法（method）</li>
</ul>
</li>
</ul>
<h3 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2. 构造函数"></a>2. 构造函数</h3><ul>
<li>典型的面向对象编程语言（比如 C++ 和 Java），都有“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。但是，JavaScript 语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。</li>
<li>JavaScript 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。</li>
<li>构造函数就是一个普通的函数，为了与普通函数区别，构造函数名字的第一个字母通常大写</li>
</ul>
<h3 id="3-new-命令"><a href="#3-new-命令" class="headerlink" title="3. new 命令"></a>3. new 命令</h3><ul>
<li>基本用法<ul>
<li>new 命令的作用，就是执行构造函数，返回一个实例对象</li>
<li>使用 new 命令时，根据需要，构造函数也可以接受参数</li>
<li>new 命令本身就可以执行构造函数，所以后面的构造函数可以带括号，也可以不带括号。但是为了表示这里是函数调用，推荐使用括号</li>
<li>如果忘了使用 new 命令，直接调用构造函数，这种情况下，构造函数就变成了普通函数，并不会生成实例对象。</li>
<li>为了保证构造函数必须与 new 命令一起使用<ol>
<li>构造函数内部使用严格模式，即第一行加上 use strict。这样的话，一旦忘了使用 new 命令，直接调用构造函数，由于严格模式中，函数内部的 this 不能指向全局对象，默认等于 undefined，导致不加 new 调用会报错（JavaScript 不允许对 undefined 添加属性）。</li>
<li>构造函数内部判断是否使用 new 命令，如果发现没有使用，则直接返回一个实例对象</li>
</ol>
</li>
</ul>
</li>
<li><p>new 命令的原理</p>
<ul>
<li>使用 new 命令时，它后面的函数依次执行下面的步骤。<ol>
<li>创建一个空对象，作为将要返回的对象实例。</li>
<li>将这个空对象的原型，指向构造函数的 prototype 属性，将这个空对象赋值给函数内部的 this 关键字。</li>
<li>开始执行构造函数内部的代码。</li>
<li>return 对象</li>
</ol>
</li>
<li>如果构造函数内部有 return 语句，而且 return 后面跟着一个对象，new 命令会返回 return 语句指定的对象；否则，就会不管 return 语句，返回 this 对象</li>
<li>如果对普通函数（内部没有 this 关键字的函数）使用 new 命令，则会返回一个空对象。</li>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span> (<span class="params">constructor, params</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将 arguments 对象转为数组</span></span><br><span class="line">  <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// 取出构造函数</span></span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">constructor</span> = args.shift();</span><br><span class="line">  // 创建一个空对象，继承构造函数的 prototype 属性</span><br><span class="line">  var context = Object.create(<span class="keyword">constructor</span>.prototype);</span><br><span class="line">  // 执行构造函数</span><br><span class="line">  var result = <span class="keyword">constructor</span>.apply(context, args);</span><br><span class="line">  // 如果返回结果是对象，就直接返回，否则返回 context 对象</span><br><span class="line">  return (typeof result === 'object' &amp;&amp; result != null) ? result : context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实例</span><br><span class="line">var actor = _new(Person, '张三', 28);</span><br></pre></td></tr></table></figure>
</li>
<li><p>new.target</p>
<ul>
<li>函数内部可以使用 new.target 属性。如果当前函数是 new 命令调用，new.target 指向当前函数，否则为 undefined</li>
<li>使用这个属性，可以判断函数调用的时候，是否使用 new 命令。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-Object-create-创建实例对象"><a href="#4-Object-create-创建实例对象" class="headerlink" title="4. Object.create() 创建实例对象"></a>4. Object.create() 创建实例对象</h3><ul>
<li>以一个现有的对象作为模板，生成新的实例对象</li>
</ul>
<h2 id="绑定-this-的方法"><a href="#绑定-this-的方法" class="headerlink" title="绑定 this 的方法"></a>绑定 this 的方法</h2><ul>
<li>Function.prototype.call()<ul>
<li>call 方法的参数，应该是一个对象。如果参数为空、null 和 undefined，则默认传入全局对象</li>
<li>如果 call 方法的参数是一个原始值，那么这个原始值会自动转成对应的包装对象，然后传入 call 方法</li>
<li>call 方法还可以接受多个参数，第一个参数就是 this 所要指向的那个对象，后面的参数则是函数调用时所需的参数</li>
</ul>
</li>
<li>Function.prototype.apply()<ul>
<li>apply 方法的作用与 call 方法类似，也是改变 this 指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数</li>
</ul>
</li>
<li>Function.prototype.bind()<ul>
<li>bind 方法用于将函数体内的 this 绑定到某个对象，然后返回一个新函数</li>
<li>bind 还可以接受更多的参数，将这些参数绑定原函数的参数。</li>
<li>如果 bind 方法的第一个参数是 null 或 undefined，等于将 this 绑定到全局对象，函数运行时 this 指向顶层对象（浏览器为 window）。</li>
<li>bind 方法每运行一次，就返回一个新函数，这会产生一些问题</li>
</ul>
</li>
</ul>
<h2 id="prototype-对象"><a href="#prototype-对象" class="headerlink" title="prototype 对象"></a>prototype 对象</h2><h3 id="1-原型对象概述"><a href="#1-原型对象概述" class="headerlink" title="1. 原型对象概述"></a>1. 原型对象概述</h3><ul>
<li>构造函数的缺点<ul>
<li>通过构造函数为实例对象定义属性，虽然很方便，但是同一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费。</li>
</ul>
</li>
<li>prototype 属性的作用<ul>
<li>JavaScript 继承机制的设计思想就是，原型对象的所有属性和方法，都能被实例对象共享。也就是说，如果属性和方法定义在原型上，那么所有实例对象就能共享，不仅节省了内存，还体现了实例对象之间的联系</li>
<li>JavaScript 规定，每个函数都有一个 prototype 属性，指向一个对象， 对于构造函数来说，生成实例的时候，该属性会自动成为实例对象的原型</li>
<li>原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在所有实例对象上。</li>
<li>当实例对象本身没有某个属性或方法的时候，它会到原型对象去寻找该属性或方法。如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法</li>
<li>原型对象的作用，就是定义所有实例对象共享的属性和方法。这也是它被称为原型对象的原因，而实例对象可以视作从原型对象衍生出来的子对象</li>
</ul>
</li>
<li>原型链<ul>
<li>JavaScript 规定，所有对象都有自己的原型对象（prototype）。一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（prototype chain）：对象到原型，再到原型的原型……</li>
<li>如果一层层地上溯，所有对象的原型最终都可以上溯到 Object.prototype，即 Object 构造函数的 prototype 属性。也就是说，所有对象都继承了 Object.prototype 的属性。这就是所有对象都有 valueOf 和 toString 方法的原因，因为这是从 Object.prototype 继承的。</li>
<li>Object.prototype 的原型是 null。null 没有任何属性和方法，也没有自己的原型。因此，原型链的尽头就是 null。</li>
<li>读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的 Object.prototype 还是找不到，则返回 undefined。如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overriding）。</li>
</ul>
</li>
<li>constructor 属性<ul>
<li>prototype 对象有一个 constructor 属性，默认指向 prototype 对象所在的构造函数。</li>
<li>constructor 属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的</li>
<li>constructor 属性表示原型对象与构造函数之间的关联关系，如果修改了原型对象，一般会同时修改 constructor 属性，防止引用的时候出错<h3 id="2-instanceof-运算符"><a href="#2-instanceof-运算符" class="headerlink" title="2. instanceof 运算符"></a>2. instanceof 运算符</h3></li>
</ul>
<ul>
<li>instanceof 运算符返回一个布尔值，表示对象是否为某个构造函数的实例。</li>
<li>instanceof 运算符的左边是实例对象，右边是构造函数。它会检查右边构建函数的原型对象（prototype），是否在左边对象的原型链上</li>
<li>由于 instanceof 检查整个原型链，因此同一个实例对象，可能会对多个构造函数都返回 true</li>
<li>instanceof 运算符的一个用处，是判断对象的类型</li>
<li>利用 instanceof 运算符，还可以巧妙地解决，调用构造函数时，忘了加 new 命令的问题（无 new 调用)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fubar</span> (<span class="params">foo, bar</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Fubar) &#123;</span><br><span class="line">    <span class="keyword">this</span>._foo = foo;</span><br><span class="line">    <span class="keyword">this</span>._bar = bar;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Fubar(foo, bar);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="Object-对象的相关方法"><a href="#Object-对象的相关方法" class="headerlink" title="Object 对象的相关方法"></a>Object 对象的相关方法</h3><ul>
<li>Object.getPrototypeOf()<ul>
<li>返回参数对象的原型</li>
</ul>
</li>
<li>Object.setPrototypeOf()<ul>
<li>为参数对象设置原型，返回该参数对象。它接受两个参数，第一个是现有对象，第二个是原型对象。</li>
</ul>
</li>
<li><p>Object.create()</p>
<ul>
<li>该方法接受一个对象作为参数，然后以它为原型，返回一个实例对象。该实例完全继承原型对象的属性。</li>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Object</span>.create !== <span class="string">'function'</span>) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果想要生成一个不继承任何属性（比如没有toString和valueOf方法）的对象，可以将Object.create的参数设为null。</p>
</li>
<li>使用Object.create方法的时候，必须提供对象原型，即参数不能为空，或者不是对象，否则会报错。</li>
<li>object.create方法生成的新对象，动态继承了原型。在原型上添加或修改任何方法，会立刻反映在新对象之上。</li>
</ul>
</li>
<li>Object.prototype.isPrototypeOf()<ul>
<li>实例对象的isPrototypeOf方法，用来判断该对象是否为参数对象的原型。</li>
</ul>
</li>
<li>Object.prototype.<strong>proto</strong><ul>
<li>实例对象的<strong>proto</strong>属性（前后各两个下划线），返回该对象的原型。该属性可读写。</li>
</ul>
</li>
<li>获取原型对象方法的比较<ul>
<li>obj.<strong>proto</strong><ul>
<li>只有浏览器才需要部署，其他环境可以不部署</li>
</ul>
</li>
<li>obj.constructor.prototype<ul>
<li>在手动改变原型对象时，可能会失效, 一般要同时设置constructor属性</li>
</ul>
</li>
<li>Object.getPrototypeOf(obj)</li>
</ul>
</li>
<li>Object.getOwnPropertyNames()<ul>
<li>返回一个数组，成员是参数对象本身的所有属性的键名，不包含继承的属性键名, 不管键名是否可以遍历</li>
</ul>
</li>
<li>Object.prototype.hasOwnProperty()<ul>
<li>对象实例的hasOwnProperty方法返回一个布尔值，用于判断某个属性定义在对象自身，还是定义在原型链上</li>
</ul>
</li>
<li>in 运算符和 for…in 循环<ul>
<li>in运算符返回一个布尔值，表示一个对象是否具有某个属性。它不区分该属性是对象自身的属性，还是继承的属性</li>
<li>获得对象的所有可遍历属性（不管是自身的还是继承的），可以使用for…in循环</li>
<li>为了在for…in循环中获得对象自身的属性，可以采用hasOwnProperty方法判断一下。</li>
</ul>
</li>
<li>对象的拷贝<ul>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyObject</span>(<span class="params">orig</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> copy = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(orig));</span><br><span class="line">  copyOwnPropertiesFrom(copy, orig);</span><br><span class="line">  <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyOwnPropertiesFrom</span>(<span class="params">target, source</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span></span><br><span class="line">    .getOwnPropertyNames(source)</span><br><span class="line">    .forEach(<span class="function"><span class="keyword">function</span> (<span class="params">propKey</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(source, propKey);</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(target, propKey, desc);</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="面向对象编程的模式"><a href="#面向对象编程的模式" class="headerlink" title="面向对象编程的模式"></a>面向对象编程的模式</h2><h3 id="1-构造函数的继承"><a href="#1-构造函数的继承" class="headerlink" title="1. 构造函数的继承"></a>1. 构造函数的继承</h3><ul>
<li></li>
</ul>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/04/12/同源策略-笔记/">同源策略--笔记</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-04-12
        </span>
        
        
        <div class="post-visits"
             data-url="/2018/04/12/同源策略-笔记/"
             data-title="同源策略--笔记">
            阅读次数
          </div>
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><ul>
<li>含义<ul>
<li>所谓“同源”指的是”三个相同“。<ul>
<li>协议相同</li>
<li>域名相同</li>
<li>端口相同</li>
</ul>
</li>
<li>举例来说，<a href="http://www.example.com/dir/page.html" target="_blank" rel="noopener">http://www.example.com/dir/page.html</a> 这个网址，协议是 <a href="http://，域名是" target="_blank" rel="noopener">http://，域名是</a> www.example.com，端口是80（默认端口可以省略），它的同源情况如下。<ul>
<li><a href="http://www.example.com/dir2/other.html：" target="_blank" rel="noopener">http://www.example.com/dir2/other.html：</a> 同源</li>
<li><a href="http://example.com/dir/other.html：" target="_blank" rel="noopener">http://example.com/dir/other.html：</a> 不同源（域名不同）</li>
<li><a href="http://v2.www.example.com/dir/other.html：" target="_blank" rel="noopener">http://v2.www.example.com/dir/other.html：</a> 不同源（域名不同）</li>
<li><a href="http://www.example.com:81/dir/other.html：" target="_blank" rel="noopener">http://www.example.com:81/dir/other.html：</a> 不同源（端口不同）</li>
<li><a href="https://www.example.com/dir/page.html：" target="_blank" rel="noopener">https://www.example.com/dir/page.html：</a> 不同源（协议不同）</li>
</ul>
</li>
</ul>
</li>
<li>目的<ul>
<li>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据</li>
</ul>
</li>
<li>限制范围<ul>
<li>随着互联网的发展，同源政策越来越严格。目前，如果非同源，共有三种行为受到限制。<ul>
<li>无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB。</li>
<li>无法接触非同源网页的 DOM。</li>
<li>无法向非同源地址发送 AJAX 请求（可以发送，但浏览器会拒绝接受响应）。</li>
</ul>
</li>
<li>虽然这些限制是必要的，但是有时很不方便，合理的用途也受到影响。下面介绍如何规避上面的限制。</li>
</ul>
</li>
</ul>
<h3 id="2-Cookie"><a href="#2-Cookie" class="headerlink" title="2. Cookie"></a>2. Cookie</h3><ul>
<li><p>Cookie 是服务器写入浏览器的一小段信息，只有同源的网页才能共享。如果两个网页一级域名相同，只是次级域名不同，浏览器允许通过设置document.domain共享 Cookie。</p>
</li>
<li><p>举例来说，A 网页的网址是 <a href="http://w1.example.com/a.html，" target="_blank" rel="noopener">http://w1.example.com/a.html，</a> B 网页的网址是 <a href="http://w2.example.com/b.html，那么只要设置相同的document.domain，两个网页就可以共享" target="_blank" rel="noopener">http://w2.example.com/b.html，那么只要设置相同的document.domain，两个网页就可以共享</a> Cookie。因为浏览器通过document.domain属性来检查是否同源。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个网页都需要设置</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">'example.com'</span>;</span><br></pre></td></tr></table></figure>
<p>注意，A 和 B 两个网页都需要设置document.domain属性，才能达到同源的目的。因为设置document.domain的同时，会把端口重置为null，因此如果只设置一个网页的document.domain，会导致两个网址的端口不同，还是达不到同源的目的。</p>
</li>
<li>注意，这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexedDB 无法通过这种方法，规避同源政策，而要使用下文介绍 PostMessage API</li>
</ul>
<h3 id="3-iframe"><a href="#3-iframe" class="headerlink" title="3. iframe"></a>3. iframe</h3><ul>
<li>iframe元素可以在当前网页之中，嵌入其他网页。每个iframe元素形成自己的窗口，即有自己的window对象。iframe窗口之中的脚本，可以获得父窗口和子窗口。但是，只有在同源的情况下，父窗口和子窗口才能通信；如果跨域，就无法拿到对方的 DOM。</li>
<li>如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的document.domain属性，就可以规避同源政策，拿到 DOM。对于完全不同源的网站，目前有两种方法，可以解决跨域窗口的通信问题。</li>
<li>片段识别符</li>
<li>window.postMessage()<ul>
<li>window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源</li>
<li>postMessage方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即“协议 + 域名 + 端口”。也可以设为*，表示不限制域名，向所有窗口发送。</li>
<li>父窗口和子窗口都可以通过message事件，监听对方的消息。</li>
<li>message事件的参数是事件对象event，提供以下三个属性。<ul>
<li>event.source：发送消息的窗口</li>
<li>event.origin: 消息发向的网址</li>
<li>event.data: 消息内容</li>
</ul>
</li>
</ul>
</li>
<li>LocalStorage<ul>
<li>通过window.postMessage，读写其他窗口的 LocalStorage 也成为了可能</li>
</ul>
</li>
</ul>
<h3 id="4-AJAX"><a href="#4-AJAX" class="headerlink" title="4. AJAX"></a>4. AJAX</h3><ul>
<li>同源政策规定，AJAX 请求只能发给同源的网址，否则就报错。除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。<ul>
<li>JSONP</li>
<li>WebSocket</li>
<li>CORS</li>
</ul>
</li>
<li><p>JSONP</p>
<ul>
<li>它的基本思想是，网页通过添加一个 script 元素，向服务器请求 JSON 数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。</li>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addScriptTag</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">  script.setAttribute(<span class="string">"type"</span>,<span class="string">"text/javascript"</span>);</span><br><span class="line">  script.src = src;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  addScriptTag(<span class="string">'http://example.com/ip?callback=foo'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Your public IP address is: '</span> + data.ip);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>WebSocket</p>
<ul>
<li>WebSocket 是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信</li>
</ul>
</li>
<li>CORS</li>
</ul>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/04/12/history对象-笔记/">history 对象 -- 笔记</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-04-12
        </span>
        
        
        <div class="post-visits"
             data-url="/2018/04/12/history对象-笔记/"
             data-title="history 对象 -- 笔记">
            阅读次数
          </div>
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="history-对象"><a href="#history-对象" class="headerlink" title="history 对象"></a>history 对象</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><ul>
<li>浏览器窗口有一个 history 对象，用来保存浏览历史，比如当前窗口先后访问了三个网址，那么 history.length 属性等于 3</li>
<li>history 对象提供了一系列方法，允许在浏览历史之间移动。<ul>
<li>back()：移动到上一个访问页面，等同于浏览器的后退键。</li>
<li>forward()：移动到下一个访问页面，等同于浏览器的前进键。</li>
<li>go()：接受一个整数作为参数，移动到该整数指定的页面，比如 go(1) 相当于 forward()，go(-1) 相当于 back(), go(0) 相当于刷新当前页面。</li>
<li>如果移动的位置超出了访问历史的边界，以上三个方法并不报错，而是默默的失败。<h3 id="2-history-pushState"><a href="#2-history-pushState" class="headerlink" title="2. history.pushState()"></a>2. history.pushState()</h3></li>
</ul>
</li>
<li>HTML5 为 history 对象添加了两个新方法，history.pushState() 和 history.replaceState()，用来在浏览历史中添加和修改记录。</li>
<li>history.pushState 方法接受三个参数，依次为：<ul>
<li>state：一个与指定网址相关的状态对象，popstate 事件触发时，该对象会传入回调函数。如果不需要这个对象，此处可以填 null。</li>
<li>title：新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填 null。</li>
<li>url：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。</li>
</ul>
</li>
<li>添加新记录后，浏览器地址栏立刻显示 example.com/2.html，但并不会跳转到 2.html，甚至也不会检查 2.html 是否存在，它只是成为浏览历史中的最新记录。这时，你在地址栏输入一个新的地址（比如访问 google.com)，然后点击了倒退按钮，页面的 URL 将显示 2.html；你再点击一次倒退按钮，URL 将显示 1.html。</li>
<li>总之，pushState 方法不会触发页面刷新，只是导致 history 对象发生变化，地址栏会有反应。</li>
<li>如果 pushState 的 url 参数，设置了一个新的锚点值（即 hash），并不会触发 hashchange 事件。如果设置了一个跨域网址，则会报错。</li>
</ul>
<h3 id="3-history-replaceState"><a href="#3-history-replaceState" class="headerlink" title="3. history.replaceState()"></a>3. history.replaceState()</h3><ul>
<li>history.replaceState 方法的参数与 pushState 方法一模一样，区别是它修改浏览历史中当前纪录<h3 id="4-history-state-属性"><a href="#4-history-state-属性" class="headerlink" title="4. history.state 属性"></a>4. history.state 属性</h3></li>
<li>history.state 属性返回当前页面的 state 对象<h3 id="5-popstate-事件"><a href="#5-popstate-事件" class="headerlink" title="5. popstate 事件"></a>5. popstate 事件</h3></li>
<li>调用 pushState 方法或 replaceState 方法 ，并不会触发该事件，只有用户点击浏览器倒退按钮和前进按钮，或者使用 JavaScript 调用 back、forward、go 方法时才会触发。另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。</li>
<li>使用的时候，可以为 popstate 事件指定回调函数。</li>
<li>回调函数的参数是一个event事件对象，它的state属性指向pushState和replaceState方法为当前 URL 所提供的状态对象（即这两个方法的第一个参数）。</li>
<li>注意，页面第一次加载的时候，浏览器不会触发 popstate 事件。</li>
</ul>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/04/11/前端路由浅解析/">前端路由浅解析</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-04-11
        </span>
        
        
        <div class="post-visits"
             data-url="/2018/04/11/前端路由浅解析/"
             data-title="前端路由浅解析">
            阅读次数
          </div>
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/03/24/react-基础知识/">react 基础知识</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-03-24
        </span>
        
        
        <div class="post-visits"
             data-url="/2018/03/24/react-基础知识/"
             data-title="react 基础知识">
            阅读次数
          </div>
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <ul>
<li>React 的首要思想是通过组件（ Component ）来开发应用 。 </li>
<li>所谓组件，简单说，指的是能完成某个特定功能的独立的 、 可重用的代码 </li>
<li>这个错误信息的含义是：“在使用 JSX 的范围内必须要有 React。 ”<br>也就是说，在使用 JSX 的代码文件中，即使代码中并没有直接使用 React，也一定<br>要导人这个 React ，这是因为 JSX 最终会被转译成依赖于 React 的表达式 。</li>
</ul>
<h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h3><ul>
<li>所谓 JSX ，是 JavaScript 的语法扩展（ extension ），让我们在 JavaScript 中可以编写<br>像 HTML 一样的代码 。 </li>
<li>特点<ul>
<li>首先，在 JSX 中使用的“元素”不局限于 HTML 中的元素，可以是任何一个 React<br>组件。</li>
<li>React 判断一个元素是 HTML 元素还是 React 组件的原则就是看第一个字母是否大<br>写，如果在 JSX 中我们不用 ClickCounter 而是用 clickCounter，那就得不到我们想要的<br>结果 。</li>
<li>其次，在 JSX 中可以通过 onClick 这样的方式给一个元素添加一个事件处理函数，<br>当然，在 HTML 中也可以用 onclick （注意和 onClick 拼写有区别），但在 HTML 中直接<br>书写 onclick 一直就是为人垢病的写法，网页应用开发界一直倡导的是用 jQuery 的方法<br>添加事件处理函数，直接写 onclick 会带来代码混乱的问题。</li>
<li>onClick 挂载的每个函数，都可以控制在组件范围内，不会污染全局空间 。<br>我们在 JSX 中看到一个组件使用了 onClick，但并没有产生直接使用 onclick （注意<br>是 onclick 不是 onClick）的 HTML ，而是使用了事件委托（event delegation）的方式处理<br>点击事件，无论有多少个 onClick 出现，其实最后都只在 DOM 树上添加了一个事件处理<br>函数，挂在最顶层的 DOM 节点上。所有的点击事件都被这个事件处理函数捕获，然后<br>根据具体组件分配给特定函数，使用事件委托的性能当然要比为每个 onClick 都挂载一<br>个事件处理函数要高 </li>
</ul>
</li>
</ul>
<p>## </p>
<ul>
<li>eject （弹射）命令做的事情，就是把潜藏在 react-scripts 中的一系列技术找配置<br>都“弹射”到应用的顶层，然后我们就可以研究这些配置细节了，而且可以更灵活地定<br>制应用的配置 。机t命令是不可逆的</li>
</ul>
<h2 id="React-的理念"><a href="#React-的理念" class="headerlink" title="React 的理念"></a>React 的理念</h2><ul>
<li>归结为一个公式，就像下面这样 ：UI=render(data)</li>
<li>让我们来看看这个公式表达的含义，用户看到的界面（ UI)，应该是一个函数（在这<br>里叫 render）的执行结果，只接受数据（ data）作为参数 。 这个函数是一个纯函数，所谓<br>纯函数，指的是没有任何副作用，输出完全依赖于输入的函数，两次函数调用如果输人<br>相同，得到的结果也绝对相同 。 如此一来，最终的用户界面，在 render 函数确定的情况<br>下完全取决于输入数据 。</li>
<li>对于开发者来说，重要的是区分开哪些属于 data，哪些属于 render，想要更新用户<br>界面，要做的就是更新 data，用户界面自然会做出响应，</li>
</ul>
<h2 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h2><ul>
<li>Virtual DOM 就是对 DOM 树的抽象。 Virutal DOM 不会触及浏览器的部分，只是存在于 JavaScript 空间的树形结构，每次自上而下渲染 React 组件时，会对比这一次产生的 Virtual DOM 和上一次渲染的 Virtual DOM ，对比就会发现差别，然后修改真正的 DOM 树时就只需要触及差别中的部分就行 。</li>
</ul>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/03/07/js-设计模式笔记/">js 设计模式笔记</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-03-07
        </span>
        
        
        <div class="post-visits"
             data-url="/2018/03/07/js-设计模式笔记/"
             data-title="js 设计模式笔记">
            阅读次数
          </div>
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="面向对象的-javascript"><a href="#面向对象的-javascript" class="headerlink" title="面向对象的 javascript"></a>面向对象的 javascript</h2><h3 id="动态类型语言"><a href="#动态类型语言" class="headerlink" title="动态类型语言"></a>动态类型语言</h3><ul>
<li>编程语言按照<strong>数据类型</strong>大体可以分为两类，一类是静态类型语言，另一类是动态类型语言。</li>
<li>静态类型语言<ul>
<li>在编译时便已确定变量的类型</li>
<li>好处<ul>
<li>在编译时就能发现类型不匹配的错误</li>
<li>编译优化，提高程序执行速度</li>
</ul>
</li>
<li>缺点<ul>
<li>束缚性</li>
<li>增加更多的代码</li>
</ul>
</li>
</ul>
</li>
<li>动态类型语言<ul>
<li>变量类型要到程序运行的时候，待变量被赋予某个值之后，才会具有某种类型</li>
<li>优点<ul>
<li>代码数量少</li>
</ul>
</li>
<li>缺点<ul>
<li>无法保证变量的类型</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h3><ul>
<li>如果它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子</li>
<li>动态类型语言的面向对象设计中，鸭子类型的概念至关重要</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul>
<li>同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。</li>
<li>换句话说，给不同的对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同的<br>反馈</li>
</ul>
<h2 id="this、call和apply"><a href="#this、call和apply" class="headerlink" title="this、call和apply"></a>this、call和apply</h2><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>直接看 你不知道的js</p>
<p>call 是包装在 apply 上面的一颗语法糖<br>当使用 call 或者 apply 的时候，如果我们传入的第一个参数为 null，函数体内的 this 会指<br>向默认的宿主对象，在浏览器中则是 window</p>
<h3 id="变量的生存周期"><a href="#变量的生存周期" class="headerlink" title="变量的生存周期"></a>变量的生存周期</h3><ul>
<li>对于全局变量来说，全局变量的生存周期是永久的，除非我们主动销毁这个全局变量。</li>
<li>对于在函数内用 var 关键字声明的局部变量来说，当退出函数时，它们都会随着函数调用的结束而被销毁</li>
<li>f 返回了一个匿名函数的引用，它可以访问到 func()被调用时产生的环境，而局部变量 a 一直处在这个<br>环境里。既然局部变量所在的环境还能被外界访问，这个局部变量就有了不被销毁的理由。在这里产生了一个闭包结构，局部变量的生命看起来被延续了</li>
</ul>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><ul>
<li>高阶函数是指至少满足下列条件之一的函数：<ul>
<li>函数可以作为参数被传递；<ul>
<li>回调函数</li>
</ul>
</li>
<li>函数可以作为返回值输出</li>
</ul>
</li>
<li>函数柯里化<ul>
<li>currying 又称部分求值。一个 currying 的函数首先会接受一些参数，接受了这些参数之后，<br>该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保<br>存起来。待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。</li>
<li></li>
</ul>
</li>
<li><p>函数节流(throttle)</p>
<ul>
<li>函数被频繁调用的场景<ul>
<li>window.onresize 事件</li>
<li>mousemove 事件</li>
<li>上传进度</li>
</ul>
</li>
<li>函数节流的原理<ul>
<li>需要我们按时间段来忽略掉一些事件请求，比如确保在 500ms 内只打印一次</li>
</ul>
</li>
<li>函数节流的代码实现<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span> (<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>, isFirst = <span class="literal">true</span>, self = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isFirst) &#123;</span><br><span class="line">      fn.apply(self, <span class="built_in">arguments</span>)</span><br><span class="line">      isFirst = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">      timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line">    timer = <span class="literal">null</span></span><br><span class="line">        fn.apply(self, <span class="built_in">arguments</span>)</span><br><span class="line">      &#125;, wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onscroll = throttle(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="number">1</span> );</span><br><span class="line">&#125;, <span class="number">2000</span> );</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>分时函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timeChunk = <span class="function"><span class="keyword">function</span>(<span class="params"> ary, fn, count </span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj, t;</span><br><span class="line">  <span class="keyword">var</span> len = ary.length;</span><br><span class="line">  <span class="keyword">var</span> start = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">Math</span>.min( count || <span class="number">1</span>, ary.length ); i++ )&#123;</span><br><span class="line">      <span class="keyword">var</span> obj = ary.shift();</span><br><span class="line">      fn( obj );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    t = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> ( ary.length === <span class="number">0</span> )&#123; <span class="comment">// 如果全部节点都已经被创建好</span></span><br><span class="line">        <span class="keyword">return</span> clearInterval( t );</span><br><span class="line">      &#125;</span><br><span class="line">      start();</span><br><span class="line">    &#125;, <span class="number">200</span> ); <span class="comment">// 分批执行的时间间隔，也可以用参数的形式传入</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>惰性加载函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addEvent = <span class="function"><span class="keyword">function</span>(<span class="params"> elem, type, handler </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">window</span>.addEventListener )&#123;</span><br><span class="line">    addEvent = <span class="function"><span class="keyword">function</span>(<span class="params"> elem, type, handler </span>)</span>&#123;</span><br><span class="line">      elem.addEventListener( type, handler, <span class="literal">false</span> );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">window</span>.attachEvent )&#123;</span><br><span class="line">    addEvent = <span class="function"><span class="keyword">function</span>(<span class="params"> elem, type, handler </span>)</span>&#123;</span><br><span class="line">      elem.attachEvent( <span class="string">'on'</span> + type, handler );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  addEvent( elem, type, handler );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="第二部分-设计模式"><a href="#第二部分-设计模式" class="headerlink" title="第二部分 设计模式"></a>第二部分 设计模式</h1><ul>
<li>单例模式的定义是： 保证一个类仅有一个实例，并提供一个访问它的全局访问点</li>
</ul>
<h3 id="避免全局变量"><a href="#避免全局变量" class="headerlink" title="避免全局变量"></a>避免全局变量</h3><ul>
<li>使用命名空间<ul>
<li>把一些方法定义为对象的属性</li>
</ul>
</li>
<li>使用闭包封装私有变量</li>
</ul>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/03/06/promise-笔记/">promise 笔记</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-03-06
        </span>
        
        
        <div class="post-visits"
             data-url="/2018/03/06/promise-笔记/"
             data-title="promise 笔记">
            阅读次数
          </div>
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <ul>
<li>Promise 是一个构造函数，接收一个函数作为参数，这个参数可以传入两个参数：resolve，reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。其实这里用“成功”和“失败”来描述并不准确，按照标准来讲，resolve 是将 Promise 的状态置为 fullfiled，reject 是将 Promise 的状态置为 rejected。不过在我们开始阶段可以先这么理解，后面再细究概念。</li>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span> <span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 做一些异步操作</span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random()*<span class="number">10</span>);<span class="comment">// 生成 1-10 的随机数</span></span><br><span class="line">    <span class="keyword">if</span>(num&lt;=<span class="number">5</span>)&#123;</span><br><span class="line">      resolve(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      reject(<span class="string">'数字太大了'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>new 了一个对象，并没有调用它，我们传进去的函数就已经执行了，这是需要注意的一个细节，所以我们用 Promise 的时候一般是包在一个函数中</p>
<ul>
<li><p>执行这个函数我们得到了一个 Promise 对象，其原型上有 then、catch 方法</p>
</li>
<li><p>then 接收两个参数，注册当 resolve（成功)/reject（失败) 的回调函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onFulfilled 是用来接收 promise 成功的值</span></span><br><span class="line"><span class="comment">// onRejected 是用来接收 promise 失败的原因</span></span><br><span class="line">promise.then(onFulfilled, onRejected);</span><br></pre></td></tr></table></figure>
<ul>
<li>then 方法中如果直接 return 数据，会包装成 promise</li>
</ul>
</li>
<li>catch 用来指定 reject 的回调。而且在执行 resolve 的回调（也就是上面 then 中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死 js，而是会进到这个 catch 方法中</li>
<li>all 的用法<ul>
<li>提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调</li>
</ul>
</li>
<li>race 的用法<ul>
<li>谁跑的快，以谁为准执行回调</li>
</ul>
</li>
</ul>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li>Promise<ul>
<li>promise 是一个拥有 then 方法的对象或函数，其行为符合本规范；</li>
</ul>
</li>
<li>thenable<ul>
<li>是一个定义了 then 方法的对象或函数，文中译作“拥有 then 方法”；</li>
</ul>
</li>
<li>值（value）<ul>
<li>指任何 JavaScript 的合法值（包括 undefined , thenable 和 promise）；</li>
</ul>
</li>
<li>异常（exception）<ul>
<li>是使用 throw 语句抛出的一个值。</li>
</ul>
</li>
<li>拒绝原因（reason）<ul>
<li>表示一个 promise 的拒绝原因。</li>
</ul>
</li>
</ul>
<h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><h3 id="Promise-的状态"><a href="#Promise-的状态" class="headerlink" title="Promise 的状态"></a>Promise 的状态</h3><p>一个 Promise 的当前状态必须为以下三种状态中的一种：等待态（Pending）、完成态（Fulfilled）和拒绝态（Rejected）。</p>
<ul>
<li>等待态（Pending）<ul>
<li>处于等待态时，promise 需满足以下条件：<ul>
<li>可以迁移至完成态或拒绝态</li>
</ul>
</li>
</ul>
</li>
<li>完成态（Fulfilled）<ul>
<li>处于完成态时，promise 需满足以下条件：<ul>
<li>不能迁移至其他任何状态</li>
<li>必须拥有一个不可变的终值</li>
</ul>
</li>
</ul>
</li>
<li>拒绝态（Rejected）<ul>
<li>处于拒绝态时，promise 需满足以下条件：<ul>
<li>不能迁移至其他任何状态</li>
<li>必须拥有一个不可变的据因</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>这里的不可变指的是恒等（即可用 === 判断相等），而不是意味着更深层次的不可变（译者注： 盖指当 value 或 reason 不是基本值时，只要求其引用地址相等，但属性值可被更改）。</p>
<h3 id="Then-方法"><a href="#Then-方法" class="headerlink" title="Then 方法"></a>Then 方法</h3><p>一个 promise 必须提供一个 then 方法以访问其当前值、终值和据因。</p>
<p>promise 的 then 方法接受两个参数：</p>
<p>promise.then(onFulfilled, onRejected)</p>
<ul>
<li>参数可选<ul>
<li>onFulfilled 和 onRejected 都是可选参数。</li>
<li>如果 onFulfilled 不是函数，其必须被忽略</li>
<li>如果 onRejected 不是函数，其必须被忽略</li>
</ul>
</li>
</ul>
<p>注：如果我们只想传 onRejected 而不想传 onFulfilled，可以这么写：pormise.then(null, onRejected)</p>
<ul>
<li>onFulfilled 特性<ul>
<li>如果 onFulfilled 是函数：<ul>
<li>当 promise 执行结束后其必须被调用，其第一个参数为 promise 的终值</li>
<li>在 promise 执行结束前其不可被调用</li>
<li>其调用次数不可超过一次</li>
</ul>
</li>
</ul>
</li>
<li><p>onRejected 特性</p>
<ul>
<li>如果 onRejected 是函数：<ul>
<li>当 promise 被拒绝执行后其必须被调用，其第一个参数为 promise 的据因</li>
<li>在 promise 被拒绝执行前其不可被调用</li>
<li>其调用次数不可超过一次</li>
</ul>
</li>
</ul>
</li>
<li><p>调用时机</p>
</li>
</ul>
<p>onFulfilled 和 onRejected 只有在执行环境堆栈仅包含平台代码时才可被调用 注 1</p>
<ul>
<li>调用要求</li>
</ul>
<p>onFulfilled 和 onRejected 必须被作为函数调用（即没有 this 值）注 2</p>
<p>注：也就是说，我们在 promise 中就别用 this 了。</p>
<ul>
<li>多次调用</li>
</ul>
<p>then 方法可以被同一个 promise 调用多次</p>
<ul>
<li>当 promise 成功执行时，所有 onFulfilled 需按照其注册顺序依次回调</li>
<li>当 promise 被拒绝执行时，所有的 onRejected 需按照其注册顺序依次回调</li>
</ul>
<p>注：这里解释了我们可以链式调用，promise.then().then().then()</p>
<ul>
<li>返回</li>
</ul>
<p>then 方法必须返回一个 promise 对象 注 3</p>
<p>promise2 = promise1.then(onFulfilled, onRejected);</p>
<p>注：这就是我们能够进行链式调用的原因，因为 then 方法返回的还是一个 promise 对象。</p>
<ul>
<li>如果 onFulfilled 或者 onRejected 返回一个值 x ，则运行下面的 Promise 解决过程：<a href="promise2, x">[Resolve]</a></li>
<li>如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 必须拒绝执行，并返回拒因 e</li>
<li>如果 onFulfilled 不是函数且 promise1 成功执行， promise2 必须成功执行并返回相同的值</li>
<li>如果 onRejected 不是函数且 promise1 拒绝执行， promise2 必须拒绝执行并返回相同的据因</li>
</ul>
<h3 id="Promise-解决过程"><a href="#Promise-解决过程" class="headerlink" title="Promise 解决过程"></a>Promise 解决过程</h3><p>Promise 解决过程 是一个抽象的操作，其需输入一个 promise 和一个值，我们表示为 <a href="promise, x">[Resolve]</a>，如果 x 有 then 方法且看上去像一个 Promise ，解决程序即尝试使 promise 接受 x 的状态；否则其用 x 的值来执行 promise 。</p>
<p>这种 thenable 的特性使得 Promise 的实现更具有通用性：只要其暴露出一个遵循 Promise/A+ 协议的 then 方法即可；这同时也使遵循 Promise/A+ 规范的实现可以与那些不太规范但可用的实现能良好共存。</p>
<p>运行 <a href="promise, x">[Resolve]</a> 需遵循以下步骤：</p>
<ul>
<li>x 与 promise 相等</li>
</ul>
<p>如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise</p>
<ul>
<li>x 为 Promise</li>
</ul>
<p>如果 x 为 Promise ，则使 promise 接受 x 的状态 注 4：</p>
<ul>
<li>如果 x 处于等待态， promise 需保持为等待态直至 x 被执行或拒绝</li>
<li>如果 x 处于完成态，用相同的值执行 promise</li>
<li>如果 x 处于拒绝态，用相同的据因拒绝 promise<br>注：这里就是解释我们链式调用 then 时，可以继续进行异步操作，只要在 onFulfilled 中继续返回一个 promise 对象即可。例如：<br>runAsync1()<br>.then(function(data){<br>  console.log(data);<br>  return runAsync2(); // 返回值为 promise 对象<br>})<br>.then(function(data){<br>  console.log(data);<br>  return runAsync3();<br>})</li>
</ul>
<p>x 为对象或函数<br>如果 x 为对象或者函数：</p>
<p>把 x.then 赋值给 then 注 5<br>如果取 x.then 的值时抛出错误 e ，则以 e 为据因拒绝 promise<br>如果 then 是函数，将 x 作为函数的作用域 this 调用之。传递两个回调函数作为参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise:<br>如果 resolvePromise 以值 y 为参数被调用，则运行 <a href="promise, y">[Resolve]</a><br>如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise<br>如果 resolvePromise 和 rejectPromise 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用<br>如果调用 then 方法抛出了异常 e：<br>如果 resolvePromise 或 rejectPromise 已经被调用，则忽略之<br>否则以 e 为据因拒绝 promise<br>如果 then 不是函数，以 x 为参数执行 promise<br>如果 x 不为对象或者函数，以 x 为参数执行 promise<br>如果一个 promise 被一个循环的 thenable 链中的对象解决，而 <a href="promise, thenable">[Resolve]</a> 的递归性质又使得其被再次调用，根据上述的算法将会陷入无限递归之中。算法虽不强制要求，但也鼓励施者检测这样的递归是否存在，若检测到存在则以一个可识别的 TypeError 为据因来拒绝 promise 注 6。</p>
<p>Promise 实现代码</p>
<p>function Promise (executor) {<br>  let self = this // 缓存当前 promise 实例对象<br>  self.status = ‘pending’ // Promise 当前的状态<br>  self.data = undefined  // Promise 的值</p>
<p>  // Promise resolve 时的回调函数集，<br>  // 因为在 Promise 结束之前有可能有多个回调添加到它上面<br>  self.onResolvedCallback = [] </p>
<p>  // Promise reject 时的回调函数集，<br>  // 因为在 Promise 结束之前有可能有多个回调添加到它上面<br>  self.onRejectedCallback = [] </p>
<p>  function resolve(value) {<br>    if (value instanceof Promise) {<br>      return value.then(resolve, reject)<br>    }<br>    setTimeout(function() { // 异步执行所有的回调函数<br>      if (self.status === ‘pending’) {<br>        self.status = ‘resolved’<br>        self.data = value<br>        for (var i = 0; i &lt; self.onResolvedCallback.length; i++) {<br>          self.onResolvedCallback<a href="value">i</a><br>        }<br>      }<br>    })<br>  }</p>
<p>  function reject(reason) {<br>    setTimeout(function() { // 异步执行所有的回调函数<br>      if (self.status === ‘pending’) {<br>        self.status = ‘rejected’<br>        self.data = reason<br>        for (var i = 0; i &lt; self.onRejectedCallback.length; i++) {<br>          self.onRejectedCallback<a href="reason">i</a><br>        }<br>      }<br>    }<br>  }</p>
<p>  // 执行 executor 并传入相应的参数<br>  // new 的时候就已经调用了<br>  // 考虑到执行 executor 的过程中有可能出错，<br>  // 所以我们用 try/catch 块给包起来，<br>  // 并且在出错后以 catch 到的值 reject 掉这个 Promise<br>  try {<br>    // 执行 executor<br>    executor(resolve, reject)<br>  } catch(e) {<br>    reject(e)<br>  }<br>}</p>
<p>// then 方法接收两个参数，onResolved，onRejected，分别为 Promise 成功或失败后的回调<br>Promise.prototype.then = function(onResolved, onRejected) {<br>  var self = this<br>  var promise2</p>
<p>  // 根据标准，如果 then 的参数不是 function，则我们需要忽略它，此处以如下方式处理<br>  onResolved = typeof onResolved === ‘function’ ? onResolved : function(value) {return value}<br>  onRejected = typeof onRejected === ‘function’ ? onRejected : function(reason) {throw reason}</p>
<p>  if (self.status === ‘resolved’) {<br>    // 如果 promise1（此处即为 this/self) 的状态已经确定并且是 resolved，我们调用 onResolved<br>    // 因为考虑到有可能 throw，所以我们将其包在 try/catch 块里<br>    return promise2 = new Promise(function(resolve, reject) {<br>      try {<br>        var x = onResolved(self.data)<br>        if (x instanceof Promise) {<br>          // 如果 onResolved 的返回值是一个 Promise 对象，<br>          // 直接取它的结果做为 promise2 的结果<br>          x.then(resolve, reject)<br>        }<br>        resolve(x) // 否则，以它的返回值做为 promise2 的结果<br>      } catch (e) {<br>        reject(e) // 如果出错，以捕获到的错误做为 promise2 的结果<br>      }<br>    })<br>  }</p>
<p>  if (self.status === ‘rejected’) {<br>    return promise2 = new Promise(function(resolve, reject) {<br>      try {<br>        var x = onRejected(self.data)<br>        if (x instanceof Promise) {<br>          x.then(resolve, reject)<br>        }<br>      } catch (e) {<br>        reject(e)<br>      }<br>    })<br>  }</p>
<p>  if (self.status === ‘pending’) {<br>    // 如果当前的 Promise 还处于 pending 状态，我们并不能确定调用 onResolved 还是 onRejected，<br>    // 只能等到 Promise 的状态确定后，才能确实如何处理。<br>    // 所以我们需要把我们的<strong>两种情况</strong>的处理逻辑做为 callback 放入 promise1（此处即 this/self) 的回调数组里<br>    // 逻辑本身跟第一个 if 块内的几乎一致，此处不做过多解释<br>    return promise2 = new Promise(function(resolve, reject) {<br>      self.onResolvedCallback.push(function(value) {<br>        try {<br>          var x = onResolved(self.data)<br>          if (x instanceof Promise) {<br>            x.then(resolve, reject)<br>          }<br>        } catch (e) {<br>          reject(e)<br>        }<br>      })</p>
<pre><code>  self.onRejectedCallback.push(function(reason) {
    try {
      var x = onRejected(self.data)
      if (x instanceof Promise) {
        x.then(resolve, reject)
      }
    } catch (e) {
      reject(e)
    }
  })
})
</code></pre><p>  }<br>}<br>// 为了下文方便，我们顺便实现一个 catch 方法<br>Promise.prototype.catch = function(onRejected) {<br>  return this.then(null, onRejected)<br>}</p>
<p>/<em><br>resolvePromise 函数即为根据 x 的值来决定 promise2 的状态的函数<br>也即标准中的 <a href="https://promisesaplus.com/#point-47" target="_blank" rel="noopener">Promise Resolution Procedure</a><br>x 为<code>promise2 = promise1.then(onResolved, onRejected)</code>里<code>onResolved/onRejected</code>的返回值<br><code>resolve</code>和<code>reject</code>实际上是<code>promise2</code>的<code>executor</code>的两个实参，因为很难挂在其它的地方，所以一并传进来。<br>相信各位一定可以对照标准把标准转换成代码，这里就只标出代码在标准中对应的位置，只在必要的地方做一些解释
</em>/<br>function resolvePromise(promise2, x, resolve, reject) {<br>  var then<br>  var thenCalledOrThrow = false</p>
<p>  if (promise2 === x) { // 对应标准 2.3.1 节<br>    return reject(new TypeError(‘Chaining cycle detected for promise!’))<br>  }</p>
<p>  if (x instanceof Promise) { // 对应标准 2.3.2 节<br>    // 如果 x 的状态还没有确定，那么它是有可能被一个 thenable 决定最终状态和值的<br>    // 所以这里需要做一下处理，而不能一概的以为它会被一个“正常”的值 resolve<br>    if (x.status === ‘pending’) {<br>      x.then(function(value) {<br>        resolvePromise(promise2, value, resolve, reject)<br>      }, reject)<br>    } else { // 但如果这个 Promise 的状态已经确定了，那么它肯定有一个“正常”的值，而不是一个 thenable，所以这里直接取它的状态<br>      x.then(resolve, reject)<br>    }<br>    return<br>  }</p>
<p>  if ((x !== null) &amp;&amp; ((typeof x === ‘object’) || (typeof x === ‘function’))) { // 2.3.3<br>    try {</p>
<pre><code>  // 2.3.3.1 因为 x.then 有可能是一个 getter，这种情况下多次读取就有可能产生副作用
  // 即要判断它的类型，又要调用它，这就是两次读取
  then = x.then 
  if (typeof then === &apos;function&apos;) { // 2.3.3.3
    then.call(x, function rs(y) { // 2.3.3.3.1
      if (thenCalledOrThrow) return // 2.3.3.3.3 即这三处谁选执行就以谁的结果为准
      thenCalledOrThrow = true
      return resolvePromise(promise2, y, resolve, reject) // 2.3.3.3.1
    }, function rj(r) { // 2.3.3.3.2
      if (thenCalledOrThrow) return // 2.3.3.3.3 即这三处谁选执行就以谁的结果为准
      thenCalledOrThrow = true
      return reject(r)
    })
  } else { // 2.3.3.4
    resolve(x)
  }
} catch (e) { // 2.3.3.2
  if (thenCalledOrThrow) return // 2.3.3.3.3 即这三处谁选执行就以谁的结果为准
  thenCalledOrThrow = true
  return reject(e)
}
</code></pre><p>  } else { // 2.3.4<br>    resolve(x)<br>  }<br>}</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/03/06/Flex-布局笔记/">Flex 布局笔记</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-03-06
        </span>
        
        
        <div class="post-visits"
             data-url="/2018/03/06/Flex-布局笔记/"
             data-title="Flex 布局笔记">
            阅读次数
          </div>
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>一 、Flex 布局是什么？</p>
<ul>
<li>flex 是 Flexible Box 的缩写，意为”弹性布局”</li>
<li><p>任何一个容器都可以指定为 Flex 布局：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 行内元素 */</span></span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。</p>
</li>
</ul>
<p>二、基本概念</p>
<ul>
<li>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</li>
<li>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。</li>
<li>默认是从左上角到右下角，还是 normal flow</li>
<li>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</li>
</ul>
<p>三、容器的属性</p>
<ul>
<li>flex-direction<ul>
<li>决定主轴的方向（即项目的排列方向）</li>
<li>flex-direction: row | row-reverse | column | column-reverse;</li>
</ul>
</li>
<li>flex-wrap<ul>
<li>如果当主轴尺寸固定时，当空间不足时，如何换行</li>
<li>flex-wrap: nowrap | wrap | wrap-reverse;</li>
<li>wrap-reverse 会将 main start 定位下方</li>
</ul>
</li>
<li>flex-flow<ul>
<li>是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap</li>
</ul>
</li>
<li>justify-content<ul>
<li>定义项目在主轴上的对齐方式</li>
<li>不会改变 main start 的位置</li>
<li>justify-content: flex-start | flex-end | center | space-between | space-around;</li>
</ul>
</li>
<li>align-items<ul>
<li>定义项目在交叉轴上如何对齐</li>
<li>align-items: flex-start | flex-end | center | baseline | stretch;</li>
<li>只有一排项目的时候才能生效</li>
</ul>
</li>
<li>align-content<ul>
<li>定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用</li>
<li>align-content: flex-start | flex-end | center | space-between | space-around | stretch;</li>
</ul>
</li>
</ul>
<p>四、项目的属性</p>
<ul>
<li>order<ul>
<li>定义项目的排列顺序。数值越小，排列越靠前，默认为0</li>
</ul>
</li>
<li>flex-grow<ul>
<li>定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大</li>
<li>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</li>
</ul>
</li>
<li>flex-shrink<ul>
<li>定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小</li>
</ul>
</li>
<li>flex-basis<ul>
<li>定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</li>
<li>当主轴为水平方向的时候，当设置了 flex-basis，项目的宽度设置值会失效，flex-basis 需要跟 flex-grow 和 flex-shrink 配合使用才能发挥效果。</li>
</ul>
</li>
<li>flex<ul>
<li>是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选</li>
<li>快捷值：<ul>
<li>auto (1 1 auto)</li>
<li>none (0 0 auto)</li>
<li>flex: 1;（num, 1 0%）</li>
</ul>
</li>
</ul>
</li>
<li>align-self<ul>
<li>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</li>
<li>align-self: auto | flex-start | flex-end | center | baseline | stretch;</li>
</ul>
</li>
</ul>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/02/26/《把你的英语用起来》笔记/">《把你的英语用起来》笔记</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-02-26
        </span>
        
        
        <div class="post-visits"
             data-url="/2018/02/26/《把你的英语用起来》笔记/"
             data-title="《把你的英语用起来》笔记">
            阅读次数
          </div>
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="如何选择适合自己的原"><a href="#如何选择适合自己的原" class="headerlink" title="如何选择适合自己的原"></a>如何选择适合自己的原</h2><h3 id="什么才是真正的英文原著"><a href="#什么才是真正的英文原著" class="headerlink" title="什么才是真正的英文原著"></a>什么才是真正的英文原著</h3><ul>
<li>中文版往往有不少删节</li>
<li>翻译错误</li>
<li>如果你读的是中文翻译版而非英文原著， 最好不要说读了这本书</li>
<li>英文原著也不包括简写版和中英对照版<ul>
<li>简写版省略掉大量地道的表达， 甚至直接改变细节。</li>
</ul>
</li>
<li>狭义上说， 英文原著主要是指以英语为母语人士的文字著作， 也包括了其他语种著作的英译版。</li>
<li>把英语用起来， 就是在真实的生活<br>中使用这门语言， 要求听、 说、 读、<br>写全部实现英文原著化：<ul>
<li>听， 就听实时的英语新闻， 从BBC、 CNN到Al Jazeera[1]；</li>
<li>说， 就用英语聊天， 从身边的熟人到网络另一端的老外；</li>
<li>读， 就读老外的英文版， 从短信、邮件到大部头的专著；</li>
<li>写， 就写英文邮件、 短信给亲友同事乃至生意上的伙伴</li>
</ul>
</li>
</ul>
<h3 id="从哪里可以获得英文原著"><a href="#从哪里可以获得英文原著" class="headerlink" title="从哪里可以获得英文原著"></a>从哪里可以获得英文原著</h3><ul>
<li>透析入门时凭的是兴趣， 读的多是小说， 上手后读书是满足自己的需要， 到时你自然会经常跑去图书馆借阅专业书了</li>
<li>Kindle</li>
<li>www.gutenberg.org</li>
<li>www.manybooks.net</li>
<li>www.feedbooks.com</li>
<li><a href="http://www.en8848.com.cn/soft/" target="_blank" rel="noopener">http://www.en8848.com.cn/soft/</a></li>
<li>www.qcenglish.com</li>
<li>www.cnepub.com/</li>
<li>选定原著之后， 需从一而终， 一读到底， 浅尝辄止是读书的大忌。 如果要换书， 请在10页内做出决定。 每本英文原著只读1次， 切忌读完又读， 除非你要研究它， 这个世界信息爆炸， 绝大多数信息你只接触一次，所以要习惯永不回头。</li>
</ul>
<h3 id="英文原著的技术瓶颈：生词太多"><a href="#英文原著的技术瓶颈：生词太多" class="headerlink" title="英文原著的技术瓶颈：生词太多"></a>英文原著的技术瓶颈：生词太多</h3><ul>
<li>以为不把所有生词、 知识点弄清楚就是懒惰、 “对知识不负责任”：</li>
<li>对一本英文原著而言， “读下去”比“学生词”的意义大得多。</li>
</ul>
<h3 id="生词量：-看首万词不重复词数"><a href="#生词量：-看首万词不重复词数" class="headerlink" title="生词量： 看首万词不重复词数"></a>生词量： 看首万词不重复词数</h3><ul>
<li>一本书的词汇量多少不是阅读难度的决定性因素（专业知识）<h3 id="蓝思值：-句子复杂程度的科学测算"><a href="#蓝思值：-句子复杂程度的科学测算" class="headerlink" title="蓝思值： 句子复杂程度的科学测算"></a>蓝思值： 句子复杂程度的科学测算</h3></li>
<li>www.lexile.com<h3 id="兴趣选书：-“The-endjustifies-the-means-”"><a href="#兴趣选书：-“The-endjustifies-the-means-”" class="headerlink" title="兴趣选书： “The endjustifies the means.”"></a>兴趣选书： “The endjustifies the means.”</h3></li>
<li>在选原著的时候， 除了考虑客观的难度数据， 还要看个人兴趣。</li>
</ul>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/02/09/啊哈！算法-笔记/">啊哈！算法 笔记</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-02-09
        </span>
        
        
        <div class="post-visits"
             data-url="/2018/02/09/啊哈！算法-笔记/"
             data-title="啊哈！算法 笔记">
            阅读次数
          </div>
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h3 id="第-1-节-最快最简单的排序——桶排序"><a href="#第-1-节-最快最简单的排序——桶排序" class="headerlink" title="第 1 节 最快最简单的排序——桶排序"></a>第 1 节 最快最简单的排序——桶排序</h3>
        
      
    </div>

    

    

  </article>

    
  </section>

  
  <nav class="pagination">
    
    
      <a class="next" href="/page/2/">
        <span class="next-text">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


          </div>
          

        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    
    
      
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2018

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">我是你豆子欧巴</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  </body>
</html>
