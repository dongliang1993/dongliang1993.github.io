<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="面试整理 JavaScript 篇"/>













  <link rel="alternate" href="/default" title="我是你豆子欧巴">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0" />



<link rel="canonical" href="http://yoursite.com/2018/01/23/面试整理-JavaScript-篇/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />




  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>





  <script src="//cdn1.lncld.net/static/js/3.1.1/av-min.js"></script>
  <script id="leancloud">
    AV.init({
      appId: "BFBKC2C7jVkD7w4SCRF57xom-gzGzoHsz",
      appKey: "elTqQP3tDP3wAwIFKyE57fHe"
    });
  </script>





    <title> 面试整理 JavaScript 篇 - 我是你豆子欧巴 </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">我是你豆子欧巴</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            标签
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            分类
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            关于
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">我是你豆子欧巴</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              标签
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              分类
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          面试整理 JavaScript 篇
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-01-23
        </span>
        
        
        <div class="post-visits"
             data-url="/2018/01/23/面试整理-JavaScript-篇/"
             data-title="面试整理 JavaScript 篇">
            阅读次数
          </div>
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#标识符"><span class="toc-text"><a href="#&#x6807;&#x8BC6;&#x7B26;" class="headerlink" title="&#x6807;&#x8BC6;&#x7B26;"></a>&#x6807;&#x8BC6;&#x7B26;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#严格模式"><span class="toc-text"><a href="#&#x4E25;&#x683C;&#x6A21;&#x5F0F;" class="headerlink" title="&#x4E25;&#x683C;&#x6A21;&#x5F0F;"></a>&#x4E25;&#x683C;&#x6A21;&#x5F0F;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关键字和保留字"><span class="toc-text"><a href="#&#x5173;&#x952E;&#x5B57;&#x548C;&#x4FDD;&#x7559;&#x5B57;" class="headerlink" title="&#x5173;&#x952E;&#x5B57;&#x548C;&#x4FDD;&#x7559;&#x5B57;"></a>&#x5173;&#x952E;&#x5B57;&#x548C;&#x4FDD;&#x7559;&#x5B57;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS-中基本的数据类型"><span class="toc-text"><a href="#JS-&#x4E2D;&#x57FA;&#x672C;&#x7684;&#x6570;&#x636E;&#x7C7B;&#x578B;" class="headerlink" title="JS &#x4E2D;&#x57FA;&#x672C;&#x7684;&#x6570;&#x636E;&#x7C7B;&#x578B;"></a>JS &#x4E2D;&#x57FA;&#x672C;&#x7684;&#x6570;&#x636E;&#x7C7B;&#x578B;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#typeof-操作符"><span class="toc-text"><a href="#typeof-&#x64CD;&#x4F5C;&#x7B26;" class="headerlink" title="typeof &#x64CD;&#x4F5C;&#x7B26;"></a>typeof &#x64CD;&#x4F5C;&#x7B26;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关于-null-类型的注意点"><span class="toc-text"><a href="#&#x5173;&#x4E8E;-null-&#x7C7B;&#x578B;&#x7684;&#x6CE8;&#x610F;&#x70B9;" class="headerlink" title="&#x5173;&#x4E8E; null &#x7C7B;&#x578B;&#x7684;&#x6CE8;&#x610F;&#x70B9;"></a>&#x5173;&#x4E8E; null &#x7C7B;&#x578B;&#x7684;&#x6CE8;&#x610F;&#x70B9;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Boolean类型"><span class="toc-text"><a href="#Boolean&#x7C7B;&#x578B;" class="headerlink" title="Boolean&#x7C7B;&#x578B;"></a>Boolean&#x7C7B;&#x578B;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Number类型"><span class="toc-text"><a href="#Number&#x7C7B;&#x578B;" class="headerlink" title="Number&#x7C7B;&#x578B;"></a>Number&#x7C7B;&#x578B;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String类型"><span class="toc-text"><a href="#String&#x7C7B;&#x578B;" class="headerlink" title="String&#x7C7B;&#x578B;"></a>String&#x7C7B;&#x578B;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#操作符（很多细节）"><span class="toc-text"><a href="#&#x64CD;&#x4F5C;&#x7B26;&#xFF08;&#x5F88;&#x591A;&#x7EC6;&#x8282;&#xFF09;" class="headerlink" title="&#x64CD;&#x4F5C;&#x7B26;&#xFF08;&#x5F88;&#x591A;&#x7EC6;&#x8282;&#xFF09;"></a>&#x64CD;&#x4F5C;&#x7B26;&#xFF08;&#x5F88;&#x591A;&#x7EC6;&#x8282;&#xFF09;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#label-语句"><span class="toc-text"><a href="#label-&#x8BED;&#x53E5;" class="headerlink" title="label &#x8BED;&#x53E5;"></a>label &#x8BED;&#x53E5;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#with语句"><span class="toc-text"><a href="#with&#x8BED;&#x53E5;" class="headerlink" title="with&#x8BED;&#x53E5;"></a>with&#x8BED;&#x53E5;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数"><span class="toc-text"><a href="#&#x51FD;&#x6570;" class="headerlink" title="&#x51FD;&#x6570;"></a>&#x51FD;&#x6570;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本类型和引用类型的值"><span class="toc-text"><a href="#&#x57FA;&#x672C;&#x7C7B;&#x578B;&#x548C;&#x5F15;&#x7528;&#x7C7B;&#x578B;&#x7684;&#x503C;" class="headerlink" title="&#x57FA;&#x672C;&#x7C7B;&#x578B;&#x548C;&#x5F15;&#x7528;&#x7C7B;&#x578B;&#x7684;&#x503C;"></a>&#x57FA;&#x672C;&#x7C7B;&#x578B;&#x548C;&#x5F15;&#x7528;&#x7C7B;&#x578B;&#x7684;&#x503C;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#检测类型"><span class="toc-text"><a href="#&#x68C0;&#x6D4B;&#x7C7B;&#x578B;" class="headerlink" title="&#x68C0;&#x6D4B;&#x7C7B;&#x578B;"></a>&#x68C0;&#x6D4B;&#x7C7B;&#x578B;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#执行环境及作用域"><span class="toc-text"><a href="#&#x6267;&#x884C;&#x73AF;&#x5883;&#x53CA;&#x4F5C;&#x7528;&#x57DF;" class="headerlink" title="&#x6267;&#x884C;&#x73AF;&#x5883;&#x53CA;&#x4F5C;&#x7528;&#x57DF;"></a>&#x6267;&#x884C;&#x73AF;&#x5883;&#x53CA;&#x4F5C;&#x7528;&#x57DF;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#垃圾收集"><span class="toc-text"><a href="#&#x5783;&#x573E;&#x6536;&#x96C6;" class="headerlink" title="&#x5783;&#x573E;&#x6536;&#x96C6;"></a>&#x5783;&#x573E;&#x6536;&#x96C6;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#引用类型"><span class="toc-text"><a href="#&#x5F15;&#x7528;&#x7C7B;&#x578B;" class="headerlink" title="&#x5F15;&#x7528;&#x7C7B;&#x578B;"></a>&#x5F15;&#x7528;&#x7C7B;&#x578B;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-类型"><span class="toc-text"><a href="#Object-&#x7C7B;&#x578B;" class="headerlink" title="Object &#x7C7B;&#x578B;"></a>Object &#x7C7B;&#x578B;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Array-类型"><span class="toc-text"><a href="#Array-&#x7C7B;&#x578B;" class="headerlink" title="Array &#x7C7B;&#x578B;"></a>Array &#x7C7B;&#x578B;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Date-和正则没有看"><span class="toc-text"><a href="#Date-&#x548C;&#x6B63;&#x5219;&#x6CA1;&#x6709;&#x770B;" class="headerlink" title="(Date &#x548C;&#x6B63;&#x5219;&#x6CA1;&#x6709;&#x770B; )"></a>(Date &#x548C;&#x6B63;&#x5219;&#x6CA1;&#x6709;&#x770B; )</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Function"><span class="toc-text"><a href="#Function" class="headerlink" title="Function"></a>Function</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本包装类型"><span class="toc-text"><a href="#&#x57FA;&#x672C;&#x5305;&#x88C5;&#x7C7B;&#x578B;" class="headerlink" title="&#x57FA;&#x672C;&#x5305;&#x88C5;&#x7C7B;&#x578B;"></a>&#x57FA;&#x672C;&#x5305;&#x88C5;&#x7C7B;&#x578B;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Global-对象"><span class="toc-text"><a href="#Global-&#x5BF9;&#x8C61;" class="headerlink" title="Global &#x5BF9;&#x8C61;"></a>Global &#x5BF9;&#x8C61;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Math对象"><span class="toc-text"><a href="#Math&#x5BF9;&#x8C61;" class="headerlink" title="Math&#x5BF9;&#x8C61;"></a>Math&#x5BF9;&#x8C61;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象"><span class="toc-text"><a href="#&#x9762;&#x5411;&#x5BF9;&#x8C61;" class="headerlink" title="&#x9762;&#x5411;&#x5BF9;&#x8C61;"></a>&#x9762;&#x5411;&#x5BF9;&#x8C61;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数表达式"><span class="toc-text"><a href="#&#x51FD;&#x6570;&#x8868;&#x8FBE;&#x5F0F;" class="headerlink" title="&#x51FD;&#x6570;&#x8868;&#x8FBE;&#x5F0F;"></a>&#x51FD;&#x6570;&#x8868;&#x8FBE;&#x5F0F;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XMLHttpRequest"><span class="toc-text"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#兼容"><span class="toc-text"><a href="#&#x517C;&#x5BB9;" class="headerlink" title="&#x517C;&#x5BB9;"></a>&#x517C;&#x5BB9;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#XHR-的用法"><span class="toc-text"><a href="#XHR-&#x7684;&#x7528;&#x6CD5;" class="headerlink" title="XHR &#x7684;&#x7528;&#x6CD5;"></a>XHR &#x7684;&#x7528;&#x6CD5;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GET-请求"><span class="toc-text"><a href="#GET-&#x8BF7;&#x6C42;" class="headerlink" title="GET &#x8BF7;&#x6C42;"></a>GET &#x8BF7;&#x6C42;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#POST-请求"><span class="toc-text"><a href="#POST-&#x8BF7;&#x6C42;" class="headerlink" title="POST &#x8BF7;&#x6C42;"></a>POST &#x8BF7;&#x6C42;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XMLHttpRequest-2-级"><span class="toc-text"><a href="#XMLHttpRequest-2-&#x7EA7;" class="headerlink" title="XMLHttpRequest 2 &#x7EA7;"></a>XMLHttpRequest 2 &#x7EA7;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进度事件"><span class="toc-text"><a href="#&#x8FDB;&#x5EA6;&#x4E8B;&#x4EF6;" class="headerlink" title="&#x8FDB;&#x5EA6;&#x4E8B;&#x4EF6;"></a>&#x8FDB;&#x5EA6;&#x4E8B;&#x4EF6;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#长轮询是传统轮询（也称为短轮询）的一个翻版，即浏览器定时向服务器发送请求，看有没有更新的数据"><span class="toc-text"><a href="#&#x957F;&#x8F6E;&#x8BE2;&#x662F;&#x4F20;&#x7EDF;&#x8F6E;&#x8BE2;&#xFF08;&#x4E5F;&#x79F0;&#x4E3A;&#x77ED;&#x8F6E;&#x8BE2;&#xFF09;&#x7684;&#x4E00;&#x4E2A;&#x7FFB;&#x7248;&#xFF0C;&#x5373;&#x6D4F;&#x89C8;&#x5668;&#x5B9A;&#x65F6;&#x5411;&#x670D;&#x52A1;&#x5668;&#x53D1;&#x9001;&#x8BF7;&#x6C42;&#xFF0C;&#x770B;&#x6709;&#x6CA1;&#x6709;&#x66F4;&#x65B0;&#x7684;&#x6570;&#x636E;" class="headerlink" title="&#x957F;&#x8F6E;&#x8BE2;&#x662F;&#x4F20;&#x7EDF;&#x8F6E;&#x8BE2;&#xFF08;&#x4E5F;&#x79F0;&#x4E3A;&#x77ED;&#x8F6E;&#x8BE2;&#xFF09;&#x7684;&#x4E00;&#x4E2A;&#x7FFB;&#x7248;&#xFF0C;&#x5373;&#x6D4F;&#x89C8;&#x5668;&#x5B9A;&#x65F6;&#x5411;&#x670D;&#x52A1;&#x5668;&#x53D1;&#x9001;&#x8BF7;&#x6C42;&#xFF0C;&#x770B;&#x6709;&#x6CA1;&#x6709;&#x66F4;&#x65B0;&#x7684;&#x6570;&#x636E;"></a>&#x957F;&#x8F6E;&#x8BE2;&#x662F;&#x4F20;&#x7EDF;&#x8F6E;&#x8BE2;&#xFF08;&#x4E5F;&#x79F0;&#x4E3A;&#x77ED;&#x8F6E;&#x8BE2;&#xFF09;&#x7684;&#x4E00;&#x4E2A;&#x7FFB;&#x7248;&#xFF0C;&#x5373;&#x6D4F;&#x89C8;&#x5668;&#x5B9A;&#x65F6;&#x5411;&#x670D;&#x52A1;&#x5668;&#x53D1;&#x9001;&#x8BF7;&#x6C42;&#xFF0C;&#x770B;&#x6709;&#x6CA1;&#x6709;&#x66F4;&#x65B0;&#x7684;&#x6570;&#x636E;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Web-Sockets"><span class="toc-text"><a href="#Web-Sockets" class="headerlink" title="Web Sockets"></a>Web Sockets</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事-件"><span class="toc-text"><a href="#&#x4E8B;-&#x4EF6;" class="headerlink" title="&#x4E8B; &#x4EF6;"></a>&#x4E8B; &#x4EF6;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#事件流"><span class="toc-text"><a href="#&#x4E8B;&#x4EF6;&#x6D41;" class="headerlink" title="&#x4E8B;&#x4EF6;&#x6D41;"></a>&#x4E8B;&#x4EF6;&#x6D41;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件处理程序"><span class="toc-text"><a href="#&#x4E8B;&#x4EF6;&#x5904;&#x7406;&#x7A0B;&#x5E8F;" class="headerlink" title="&#x4E8B;&#x4EF6;&#x5904;&#x7406;&#x7A0B;&#x5E8F;"></a>&#x4E8B;&#x4EF6;&#x5904;&#x7406;&#x7A0B;&#x5E8F;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件对象"><span class="toc-text"><a href="#&#x4E8B;&#x4EF6;&#x5BF9;&#x8C61;" class="headerlink" title="&#x4E8B;&#x4EF6;&#x5BF9;&#x8C61;"></a>&#x4E8B;&#x4EF6;&#x5BF9;&#x8C61;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件类型"><span class="toc-text"><a href="#&#x4E8B;&#x4EF6;&#x7C7B;&#x578B;" class="headerlink" title="&#x4E8B;&#x4EF6;&#x7C7B;&#x578B;"></a>&#x4E8B;&#x4EF6;&#x7C7B;&#x578B;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件委托"><span class="toc-text"><a href="#&#x4E8B;&#x4EF6;&#x59D4;&#x6258;" class="headerlink" title="&#x4E8B;&#x4EF6;&#x59D4;&#x6258;"></a>&#x4E8B;&#x4EF6;&#x59D4;&#x6258;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#移除事件处理程序"><span class="toc-text"><a href="#&#x79FB;&#x9664;&#x4E8B;&#x4EF6;&#x5904;&#x7406;&#x7A0B;&#x5E8F;" class="headerlink" title="&#x79FB;&#x9664;&#x4E8B;&#x4EF6;&#x5904;&#x7406;&#x7A0B;&#x5E8F;"></a>&#x79FB;&#x9664;&#x4E8B;&#x4EF6;&#x5904;&#x7406;&#x7A0B;&#x5E8F;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模拟事件"><span class="toc-text"><a href="#&#x6A21;&#x62DF;&#x4E8B;&#x4EF6;" class="headerlink" title="&#x6A21;&#x62DF;&#x4E8B;&#x4EF6;"></a>&#x6A21;&#x62DF;&#x4E8B;&#x4EF6;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不在块中定义函数时，先提升函数，再提升变量声明。"><span class="toc-text"><a href="#&#x4E0D;&#x5728;&#x5757;&#x4E2D;&#x5B9A;&#x4E49;&#x51FD;&#x6570;&#x65F6;&#xFF0C;&#x5148;&#x63D0;&#x5347;&#x51FD;&#x6570;&#xFF0C;&#x518D;&#x63D0;&#x5347;&#x53D8;&#x91CF;&#x58F0;&#x660E;&#x3002;" class="headerlink" title="&#x4E0D;&#x5728;&#x5757;&#x4E2D;&#x5B9A;&#x4E49;&#x51FD;&#x6570;&#x65F6;&#xFF0C;&#x5148;&#x63D0;&#x5347;&#x51FD;&#x6570;&#xFF0C;&#x518D;&#x63D0;&#x5347;&#x53D8;&#x91CF;&#x58F0;&#x660E;&#x3002;"></a>&#x4E0D;&#x5728;&#x5757;&#x4E2D;&#x5B9A;&#x4E49;&#x51FD;&#x6570;&#x65F6;&#xFF0C;&#x5148;&#x63D0;&#x5347;&#x51FD;&#x6570;&#xFF0C;&#x518D;&#x63D0;&#x5347;&#x53D8;&#x91CF;&#x58F0;&#x660E;&#x3002;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-相关"><span class="toc-text"><a href="#React-&#x76F8;&#x5173;" class="headerlink" title="React &#x76F8;&#x5173;"></a>React &#x76F8;&#x5173;</span></a></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ul>
<li>定义：指变量、函数、属性的名字，或者函数的参数</li>
<li>规则<ul>
<li>第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；</li>
<li>其他字符可以是字母、下划线、美元符号或数字。</li>
</ul>
</li>
<li>不能把关键字、保留字、 true、 false 和 null 用作标识符。 </li>
</ul>
<h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><ul>
<li>严格模式是为 JavaScript 定义了一种不同的<br>解析与执行模型</li>
<li>在顶部或者函数内部的上方 “use strict”;</li>
</ul>
<h2 id="关键字和保留字"><a href="#关键字和保留字" class="headerlink" title="关键字和保留字"></a>关键字和保留字</h2><ul>
<li>关键字<ul>
<li>定义：可用于表示控制语句的开始或结束，或者用于执行特定操作字符</li>
</ul>
</li>
<li>保留字<ul>
<li>定义：有可能在将来被用作关键字的字符</li>
</ul>
</li>
<li>不要使用关键字和保留字作为标识符和属性名</li>
</ul>
<h2 id="JS-中基本的数据类型"><a href="#JS-中基本的数据类型" class="headerlink" title="JS 中基本的数据类型"></a>JS 中基本的数据类型</h2><p>ECMAScript 中有 5 种简单数据类型（也称为基本数据类型）：Undefined、Null、Boolean、Number 和 String。还有 1 种复杂数据类型——Object</p>
<h2 id="typeof-操作符"><a href="#typeof-操作符" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h2><ul>
<li>typeof 是一个操作符而不是函数，因此例子中的圆括号尽管可以使用，但不是必需的</li>
<li>对一个值使用 typeof 操作符可能返回下列某个字符串：<ul>
<li>“undefined”——如果这个值未定义；</li>
<li>“boolean”——如果这个值是布尔值；</li>
<li>“string”——如果这个值是字符串；</li>
<li>“number”——如果这个值是数值；</li>
<li>“object”——如果这个值是对象或 null；</li>
<li>“function”——如果这个值是函数</li>
</ul>
</li>
<li>对未初始化（即未赋值）的变量执行 typeof 操作符会返回 undefined 值，而对未声明的变量执行 typeof 操作符同样也会返回 undefined 值。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message; <span class="comment">// 这个变量声明之后默认取得了 undefined 值</span></span><br><span class="line"><span class="comment">// 下面这个变量并没有声明</span></span><br><span class="line"><span class="comment">// var age</span></span><br><span class="line">alert(<span class="keyword">typeof</span> message); <span class="comment">// "undefined"</span></span><br><span class="line">alert(<span class="keyword">typeof</span> age); <span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="关于-null-类型的注意点"><a href="#关于-null-类型的注意点" class="headerlink" title="关于 null 类型的注意点"></a>关于 null 类型的注意点</h2><ul>
<li>从逻辑角度来看， null 值表示一个空对象指针，而这也正是使用 typeof 操作符检测 null 值时会返回”object”的原因</li>
<li>undefined 值是派生自 null 值的，因此 null == undefined // true</li>
</ul>
<h2 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h2><ul>
<li>转换为false的值：false, ‘’（空字符串），0，NaN，null，undefined</li>
<li>注意 负数其实是转换成 true 的</li>
</ul>
<h2 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h2><ul>
<li>八进制<ul>
<li>第一位必须是零（0） ，然后是八进制数字序列（0～7） 。</li>
<li>如果字面值中的数值超出了范围，那么前导零将被忽略，后面的数值将被当作十进制数值解析</li>
</ul>
</li>
<li>十六进制<ul>
<li>前两位必须是 0x，后跟任何十六进制数字（0～9 及 A～F）。其中，字母 A～F可以大写，也可以小写。</li>
</ul>
</li>
<li>浮点数值计算会产生舍入误差</li>
<li>数值范围<ul>
<li>ECMAScript 能够表示的最小数值保存在 Number.MIN_VALUE<br>中；能够表示的最大数值保存在Number.MAX_VALUE 如果某次计算的结果得到了一个超出 JavaScript 数值范围的值，那么这个数值将被自动转换成特殊的 Infinity 值。具体来说，如果这个数值是负数，则会被转换成-Infinity（负无穷），如果这个数值是正数，则会被转换成 Infinity（正无穷）。</li>
<li>isFinite</li>
</ul>
</li>
<li>NaN<ul>
<li>任何涉及 NaN 的操作（例如 NaN/10）都会返回 NaN，</li>
<li>NaN 与任何值都不相等，包括 NaN 本身。</li>
<li>isNaN 来判断<ul>
<li>isNaN()在接收到一个值之后，会尝试<br>将这个值转换为数值。某些不是数值的值会直接转换为数值，例如字符串”10”或 Boolean 值。而任何<br>不能被转换为数值的值都会导致这个函数返回 true</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><ul>
<li>数值、布尔值、对象和字符串值都有 toString()方法。但 null 和 undefined 值没有这个方法。</li>
<li>在调用数值的 toString()方法时，可<br>以传递一个参数：输出数值的基数</li>
</ul>
<h2 id="操作符（很多细节）"><a href="#操作符（很多细节）" class="headerlink" title="操作符（很多细节）"></a>操作符（很多细节）</h2><ul>
<li>在应用于对象时，相应的操作符通常都会先后调用对象的 valueOf()和（或） toString()方法，以便取得可以操作的值</li>
<li>位操作符（未看完）<ul>
<li>按内存中表示数值的位来操作数值</li>
<li></li>
</ul>
</li>
</ul>
<h2 id="label-语句"><a href="#label-语句" class="headerlink" title="label 语句"></a>label 语句</h2><ul>
<li>break 和 continue 语句都可以与 label 语句联合使用，从而返回代码中特定的位置<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">outermost:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span> outermost;</span><br><span class="line">    &#125;</span><br><span class="line">    num++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">alert(num); <span class="comment">//55</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a>with语句</h2><ul>
<li>with 语句的作用是将代码的作用域设置到一个特定的对象中。 </li>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> qs = location.search.substring(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> hostName = location.hostname;</span><br><span class="line"><span class="keyword">var</span> url = location.href;</span><br><span class="line"><span class="comment">// 上面几行代码都包含 location 对象。如果使用 with 语句，可以把上面的代码改写成如下所示：</span></span><br><span class="line"><span class="keyword">with</span>(location) &#123;</span><br><span class="line">  <span class="keyword">var</span> qs = search.substring(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">var</span> hostName = hostname;</span><br><span class="line">  <span class="keyword">var</span> url = href;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在这个重写后的例子中，使用 with 语句关联了 location 对象。这意味着在 with 语句的代码块<br>内部，每个变量首先被认为是一个局部变量，而如果在局部环境中找不到该变量的定义，就会查询<br>location 对象中是否有同名的属性。如果发现了同名属性， 则以 location 对象属性的值作为变量的值</p>
</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li>ECMAScript 函数不介意传递进来多少个参数，也不在乎传进来参数是什么数据类型</li>
<li>在函数体内可以通过 arguments 对象来访问这个参数数组，从而获取传递给函数的每一个参数<ul>
<li>arguments.length 可以获得实参个数</li>
<li>它的值永远与对应命名参数的值保持同步。</li>
<li>没有传递值的命名参数将自动被赋予undefined 值。</li>
</ul>
</li>
<li>签名：接受的参数的类型和数量</li>
</ul>
<h2 id="基本类型和引用类型的值"><a href="#基本类型和引用类型的值" class="headerlink" title="基本类型和引用类型的值"></a>基本类型和引用类型的值</h2><ul>
<li>ECMAScript 变量可能包含两种不同数据类型的值：基本类型值和引用类型值。 基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。</li>
<li>基本数据类型： Undefined、 Null、 Boolean、 Number 和 String。这 5 种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。保存在栈中</li>
<li>引用类型的值是保存在内存中的对象。在操作对象时，实际上是在操作对象的引用而不是实际的对象。保存在堆中</li>
<li>如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制<br>到为新变量分配的位置上。当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另一个变量</li>
<li>传递参数<ul>
<li>ECMAScript 中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。基本类型值的传递如同基本类型变量的复制一样，而引用类型值的传递，则如同引用类型变量的复制一样。</li>
<li>在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数，或者用<br>ECMAScript 的概念来说，就是 arguments 对象中的一个元素）。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部</li>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  num += <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> result = addTen(count);</span><br><span class="line">alert(count); <span class="comment">//20，没有变化</span></span><br><span class="line">alert(result); <span class="comment">//30</span></span><br><span class="line"><span class="comment">// 个人理解，可以改写成</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 赋值成局部变量</span></span><br><span class="line">  <span class="comment">// 以把 ECMAScript 函数的参数想象成局部变量。</span></span><br><span class="line">  <span class="keyword">var</span> num = num</span><br><span class="line">  num += <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h2><ul>
<li>检测一个变量是不是基本数据类型<ul>
<li>typeof 检测基本数据类型，不能检查不 null</li>
<li>instanceof 检查引用类型</li>
</ul>
</li>
</ul>
<h2 id="执行环境及作用域"><a href="#执行环境及作用域" class="headerlink" title="执行环境及作用域"></a>执行环境及作用域</h2><ul>
<li>执行环境（也称为作用域）的类型总共只有两种：全局和局部（函数）</li>
<li>标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。如果在局部环境中找到了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味着该变量尚未声明。</li>
<li>内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性、有次序的。每个环境都<br>可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个<br>执行环境。</li>
<li>访问局部变量要比访问全局变量更快，因<br>为不用向上搜索作用域链</li>
<li>延长作用域链<ul>
<li>with 语句</li>
<li>try…catch</li>
</ul>
</li>
</ul>
<h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><ul>
<li>局部变量只在函数执行的过程中存在。然后在函数中使用这些变量，直至函数执行结束。此时，局部变量就没有存在的必要了，因此可以释放它们的内存以供将来使用。垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。</li>
<li>分类<ul>
<li>标记清除<ul>
<li>给当前不使用的值加上标记，然后再回收其内存</li>
</ul>
</li>
<li>引用计数（不常用）<ul>
<li>循环引用</li>
</ul>
</li>
</ul>
</li>
<li>一旦数据不再有用，最好通过将其值设置为 null 来释放其引用——这个做法叫做解除引用（dereferencing）。</li>
</ul>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><ul>
<li>Object, Array</li>
</ul>
<h2 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h2><ul>
<li>创建 Object 实例的方式有两种: 使用 new 操作符后跟 Object 构造函数 , 对象字面量</li>
<li>在通过对象字面量定义对象时，实际上不会调用 Object 构造函数</li>
</ul>
<h2 id="Array-类型"><a href="#Array-类型" class="headerlink" title="Array 类型"></a>Array 类型</h2><ul>
<li>数组的每一项可以保存任何类型的数据</li>
<li>与对象一样，在使用数组字面量表示法时，也不会调用 Array 构造函数</li>
<li>检测数组：Array.isArray</li>
<li>调用数组的 toString() 方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。</li>
<li>alert() 要接收字符串参数，所以它会在后台调用 toString() 方法，由此会得到与直接调用 toString() 方法相同的结果。</li>
<li>如果数组中的某一项的值是 null 或者 undefined，那么该值在 join()、toLocaleString()、 toString()和 valueOf()方法返回的结果中以空字符串表示。</li>
<li>数组可以用来模拟栈和队列<ul>
<li>栈(LIFO)：后进先出<ul>
<li>push: 返回修改后数组的长度</li>
<li>pop: 返回移除的项</li>
</ul>
</li>
<li>队列(FIFO)：先进先出<ul>
<li>push: 返回修改后数组的长度</li>
<li>shift: 返回移除的项</li>
<li>unshift: 返回修改后数组的长度</li>
</ul>
</li>
</ul>
</li>
<li><p>重排序方法</p>
<ul>
<li>reverse</li>
<li>sort 方法：<ul>
<li>在默认情况下， sort() 方法按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。为了实现排序， sort() 方法会调用每个数组项的 toString() 转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值， sort() 方法比较的也是字符串</li>
<li>sort() 方法可以接收一个比较函数作为参数。比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回 0，如果第一个参数应该位于第二个之后则返回一个正数。</li>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value2 - value1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>splice 方法：</p>
<ul>
<li>删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。例如， splice(0,2) 会删除数组中的前两项。</li>
<li>插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。例如，splice(2,0,”red”,”green”) 会从当前数组的位置 2 开始插入字符串”red”和”green”。</li>
<li>替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，splice (2,1,”red”,”green”) 会删除当前数组位置 2 的项，然后再从位置 2 开始插入字符串”red”和”green”。</li>
</ul>
</li>
</ul>
<h2 id="Date-和正则没有看"><a href="#Date-和正则没有看" class="headerlink" title="(Date 和正则没有看 )"></a>(Date 和正则没有看 )</h2><h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><ul>
<li>函数实际上是对象。每个函数都是 Function 类型的实例，而且都与其他引用类型一样具有属性和方法</li>
<li>由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定</li>
<li>不推荐使用 Function 构造函数定义函数，因为这种语法会导致解析两次代码（第一次是解析常规 ECMAScript 代码，第二次是解析传入构造函数中的字符串），从而影响性能。</li>
<li>解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行</li>
<li>arguments <ul>
<li>主要用途是保存函数参数，但这个对象还有一个名叫 callee 的属性，该属性是一个指针，指向拥有这个 arguments 对象的函数。</li>
<li>caller 保存着调用当前函数的函数的引用</li>
</ul>
</li>
<li>每个函数都包含两个属性：length 和 prototype。<ul>
<li>length 属性表示函数形参的个数</li>
<li>对于引用类型而言， prototype 是保存它们所有实例方法的真正所在。换句话说，诸如 toString()和 valueOf()等方法实际上都保存在 prototype 名下，只不过是通过各自对象的实例访问。在 ECMAScript 5 中， prototype 属性是不可枚举的，因此使用 for-in 无法发现</li>
</ul>
</li>
</ul>
<h2 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h2><ul>
<li>ECMAScript 提供了 3 个特殊的引用类型： Boolean、 Number 和 String。</li>
<li>实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">"some text"</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这个例子中的变量 s1 包含一个字符串，字符串当然是基本类型值。而下一行调用了 s1 的 substring() 方法，并将返回的结果保存在了 s2 中。我们知道，基本类型值不是对象，因而从逻辑上讲它们不应该有方法（尽管如我们所愿，它们确实有方法）。</p>
<p>其实，为了让我们实现这种直观的操作，后台已经自动完成了一系列的处理。当第二行代码访问 s1 时，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台都会自动完成下列处理<br>(1) 创建 String 类型的一个实例；<br>(2) 在实例上调用指定的方法；<br>(3) 销毁这个实例。<br>可以将以上三个步骤想象成是执行了下列 ECMAScript 代码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"some text"</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">2</span>);</span><br><span class="line">s1 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></p>
<p>经过此番处理，基本的字符串值就变得跟对象一样了。而且，上面这三个步骤也分别适用于 Boolean 和 Number 类型对应的布尔值和数字值。</p>
<ul>
<li><p>自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。</p>
</li>
<li><p>Number 类型</p>
<ul>
<li>toString 方法：传递一个表示基数的参数，告诉它返回几进制字符串格式</li>
<li>toFixed: 按照指定的小数位返回数值的字符串。会有自动舍入</li>
<li>toExponential：以指数表示法（也称 e 表示法）表示的数值的字符串形式</li>
</ul>
</li>
<li><p>String 类型</p>
<ul>
<li>charAt() 方法：返回给定位置的那个字符</li>
<li>charCodeAt()：返回指定位置字字符编码</li>
<li>使用方括号加数字索引来访问字符串中的特定字符</li>
<li>concat()： 用于将一或多个字符串拼接起来，返回拼接得到的新字符串</li>
<li>slice</li>
<li>substring：基本用法和 slice 一样<ul>
<li>substring()方法会把所有负值参数都转换为 0。</li>
</ul>
</li>
<li>substr：第二个参数指定的则是返回的字符个数<ul>
<li>substr()方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为 0。</li>
</ul>
</li>
<li>trim</li>
<li>toLowerCase()、 toLocaleLowerCase()、 toUpperCase()和 toLocaleUpperCase()</li>
<li>字符串的模式匹配方法（没看）<ul>
<li>match：只接受一个参数，要么是一个正则表达式，要么是一个 RegExp 对象，返回一个数组</li>
<li>search: 接受一个正则，返回字符串中第一个匹配项的索引</li>
<li>replace<ul>
<li>第一个参数可以是一个 RegExp 对象或者一个字符串，第二个参数可以是一个字符串或者一个函数。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Global-对象"><a href="#Global-对象" class="headerlink" title="Global 对象"></a>Global 对象</h2><ul>
<li>不属于任何其他对象的属性和方法，最终都是它的属性和方法</li>
<li>诸如 isNaN()、isFinite()、parseInt()以及 parseFloat()，实际上全都是 Global 对象的方法</li>
<li>URI 编码方法<ul>
<li>encodeURI：不会对本身属于 URI 的特殊字符进行编码，例如冒号、正斜杠、问号和井字号</li>
<li>encodeURIComponent()：会对它发现的任何非标准字符进行编码。</li>
</ul>
</li>
<li><p>eval</p>
<ul>
<li><p>只接受一个参数，即要执行的 ECMAScript （或 JavaScript）字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">"alert('hi')"</span>);</span><br><span class="line"><span class="comment">// 这行代码的作用等价于下面这行代码：</span></span><br><span class="line">alert(<span class="string">"hi"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 eval()中创建的任何变量或函数都不会被提升，因为在解析代码的时候，它们被包含在一个字符串中；它们只在 eval()执行的时候创建</p>
</li>
</ul>
</li>
</ul>
<h2 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h2><ul>
<li>min()和 max()方法用于确定一组数值中的最小值和最大值。这两个方法都可以接收任意多个数值参数，</li>
<li>舍入方法<ul>
<li>Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数；</li>
<li>Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数；</li>
<li>Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数</li>
</ul>
</li>
<li>Math.random()方法返回大于等于 0 小于 1 的一个随机数</li>
</ul>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ul>
<li>ECMAScript 中没有类的概念，因此它的对象也与基于类的语言中的对象有所不同</li>
<li>我们可以把 ECMAScript 的对象想象成散列表：就是一组名值对，其中值可以是数据或函数</li>
<li>属性类型<ul>
<li>定义这些特性是为了实现 JavaScript 引擎用的，因此在 JavaScript 中不能直接访问它们。为了表示特性是内部值，该规范把它们放在了两对儿方括号中，例如[[Enumerable]]</li>
<li>ECMAScript 中有两种属性：数据属性和访问器属性。</li>
<li>数据属性<ul>
<li>[[Configurable]]：是否可删除、是否可配置</li>
<li>[[Enumerable]]：能否通过 for-in 循环返回属性</li>
<li>[[Writable]]：能否修改属性的值。</li>
<li>[[Value]]：包含这个属性的数据值</li>
</ul>
</li>
<li>要修改属性默认的特性，必须使用 ECMAScript 5 的 Object.defineProperty()方法<ul>
<li>Object.defineProperty()<ul>
<li>修改属性默认的特性</li>
<li>可以多次调用 Object.defineProperty() 方法修改同一个属性，但在把 configurable 特性设置为 false 之后就会有限制了。</li>
</ul>
</li>
</ul>
</li>
<li>访问器属性：getter 和 setter<ul>
<li>[[Configurable]]：是否可删除、是否可配置</li>
<li>[[Enumerable]]：能否通过 for-in 循环返回属性</li>
<li>[[Get]]：在读取属性时调用的函数</li>
<li>[[Set]]：在写入属性时调用的函数</li>
</ul>
</li>
<li>Object.defineProperties<ul>
<li>这个方法可以通过描述符一次定义多个属性</li>
<li>这个方法接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应</li>
</ul>
</li>
<li>Object.getOwnPropertyDescriptor</li>
</ul>
</li>
<li><p>创建对象</p>
<ul>
<li><p>工厂模式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.job = job;</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数模式</p>
<ul>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>以这种方式调用构造函数实际上会经历以下 4 个步骤：</p>
<ol>
<li>创建一个新对象；</li>
<li>将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；</li>
<li>执行构造函数中的代码（为这个新对象添加属性）；</li>
<li>返回新对象。</li>
</ol>
</li>
<li>使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍</li>
</ul>
</li>
<li><p>原型模式</p>
<ul>
<li>每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向一个对象，包含所有实例共享的属性和方法。所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性指向 prototype 属性所在函数</li>
<li>实例自身有一个 [[Prototype]]，指向构造函数的 prototype （原型对象）。可以通过 <strong>proto</strong> 访问</li>
<li>isPrototypeOf，Object.getPrototypeOf 可以用来判断原型对象</li>
<li>每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。</li>
<li>虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。</li>
<li>无论该属性存在于实例中还是存在于原型中，调用 in 始终都返回 true， 使用 hasOwnProperty() 方法可以检测一个属性是存在于实例中，还是存在于原型中。</li>
<li>在使用 for-in 循环时，返回的是所有能够通过对象访问的、可枚举的（enumerated）属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。</li>
<li><p>IE 早期版本的实现中存在一个 bug，即屏蔽不可枚举属性的实例属性不会出现在 for-in 循环中</p>
<ul>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  toString : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"My Object"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> o)&#123;</span><br><span class="line">  <span class="keyword">if</span> (prop == <span class="string">"toString"</span>)&#123;</span><br><span class="line">    alert(<span class="string">"Found toString"</span>); <span class="comment">//在 IE 中不会显示</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>要取得对象上所有可枚举的实例属性，不包含原型上的，可以使用 Object.keys() 方法</p>
</li>
<li>如果你想要得到所有实例属性，无论它是否可枚举，都可以使用 Object.getOwnPropertyNames()方法。</li>
</ul>
</li>
<li><p>组合使用构造函数模式和原型模式</p>
<ul>
<li>实例属性都是在构造函数中定义的，而由所有实例共享的属性 constructor 和方法则是在原型中定义的</li>
</ul>
</li>
<li>动态原型模式</li>
<li>寄生构造函数模式  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.job = job;</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>继承</p>
<ul>
<li>原型链<ul>
<li>其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法</li>
<li>实现的本质是重写原型对象，代之以一个新类型的实例。</li>
<li>所有函数的默认原型都是 Object 的实例，因此默认原型都会包含一个内部指针，指向 Object.prototype。</li>
<li>确定原型和实例的关系<ul>
<li>instanceof 操作符</li>
<li>isPrototypeOf() 方法</li>
</ul>
</li>
</ul>
</li>
<li><p>借用构造函数</p>
<ul>
<li>即在子类型构造函数的内部调用超类型构造函数。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 继承了 SuperType</span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance2.colors); <span class="comment">//"red,blue,green"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>组合继承</p>
<ul>
<li>指的是将原型链和借用构造函数的技术组合到一块。其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 继承属性</span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>原型式继承</p>
<ul>
<li><p>从本质上讲， object()对传入其中的对象执行了一次浅复制</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Object.create()方法规范化了原型式继承</p>
</li>
</ul>
</li>
<li><p>寄生式继承</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clone = object(original); <span class="comment">//通过调用函数创建一个新对象</span></span><br><span class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//以某种方式来增强这个对象</span></span><br><span class="line">  alert(<span class="string">"hi"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">  <span class="keyword">return</span> clone; <span class="comment">//返回这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>寄生组合式继承</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prototype = object(superType.prototype); <span class="comment">//创建对象</span></span><br><span class="line">  prototype.constructor = subType; <span class="comment">//增强对象</span></span><br><span class="line">  subType.prototype = prototype; <span class="comment">//指定对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个例子的高效率体现在它只调用了一次 SuperType 构造函数，并且因此避免了在 SubType.prototype 上面创建不必要的、多余的属性</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h2><ul>
<li>通过 name 属性可以访问到给函数指定的名字</li>
<li>函数声明提升：可以把函数声明放在调用它的语句后面。</li>
<li>匿名函数</li>
<li>递归<ul>
<li>递归函数是在一个函数通过名字调用自身的情况下构成的</li>
<li>arguments.callee 是一个指向正在执行的函数的指针，因此可以用它来实现对函数的递归调用</li>
</ul>
</li>
<li><p>闭包</p>
<ul>
<li>闭包是指有权访问另一个函数作用域中的变量的函数</li>
<li>在函数执行过程中，为读取和写入变量的值，就需要在作用域链中查找变量。</li>
<li>当某个函数被调用时，会创建一个执行环境（execution context）及相应的作用域链。然后，使用 arguments 和其他命名参数的值来初始化函数的活动对象（activation object）。但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，……直至作为作用域链终点的全局执行环境。在函数执行过程中，为读取和写入变量的值，就需要在作用域链中查找变量。</li>
<li>我们知道， this 对象是在运行时基于函数的执行环境绑定的：在全局函数中， this 等于 window，而当函数被作为某个对象的方法调用时， this 等<br>于那个对象</li>
<li><a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html</a></li>
<li>内存泄漏<ul>
<li>IE9 之前如果闭包的作用域链中保存着一个HTML 元素，那么就意味着该元素将无法被销毁</li>
</ul>
</li>
<li><p>模仿块级作用域</p>
<ul>
<li><p>匿名函数可以用来模仿块级作用域</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//这里是块级作用域</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
</li>
<li><p>这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。一般来说，我们都应该尽量少向全局作用域中添加变量和函数</p>
</li>
</ul>
</li>
<li><p>私有变量</p>
<ul>
<li>任何在函数中定义的变量，都可以认为是私有变量</li>
<li>利用私有和特权成员，可以隐藏那些不应该被直接修改的数据，<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    name = value;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>);</span><br><span class="line">alert(person.getName()); <span class="comment">//"Nicholas"</span></span><br><span class="line">person.setName(<span class="string">"Greg"</span>);</span><br><span class="line">alert(person.getName()); <span class="comment">//"Greg"</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>模块模式（单例模式）</p>
<ul>
<li>指的就是只有一个实例的对象</li>
<li>模块模式通过为单例添加私有变量和特权方法能够使其得到增强<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">  <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 特权 / 公有方法和属性</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    publicProperty: <span class="literal">true</span>,</span><br><span class="line">    publicMethod : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      privateVariable++;</span><br><span class="line">      <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h2><h2 id="兼容"><a href="#兼容" class="headerlink" title="兼容"></a>兼容</h2><ul>
<li>IE10/IE11 部分支持</li>
<li>new ActiveXObject(“Microsoft.XMLHTTP”)</li>
</ul>
<h3 id="XHR-的用法"><a href="#XHR-的用法" class="headerlink" title="XHR 的用法"></a>XHR 的用法</h3><ul>
<li>创建 xhr 对象 var xhr = new XMLHttpRequest();</li>
<li>xhr.open(“get”, “example.php”, false);<ul>
<li>接受 3 个参数：要发送的请求的类型（”get”、 “post”等） 、请求的 URL 和表示是否异步发送请求的布尔值</li>
<li>URL 相对于执行代码的当前页面（当然也可以使用绝对路径）</li>
<li>调用 open() 方法并不会真正发送请求，而只是启动一个请求以备发送</li>
</ul>
</li>
<li>xhr.send(null);<ul>
<li>这里的 send() 方法接收一个参数，即要作为请求主体发送的数据。如果不需要通过请求主体发送数据，则必须传入 null</li>
</ul>
</li>
<li>xhr.setRequestHeader<ul>
<li>可以设置自定义的请求头部信息</li>
</ul>
</li>
<li>响应<ul>
<li>readyState<ul>
<li>表示请求 / 响应过程的当前活动阶段</li>
<li>0：未初始化。尚未调用 open() 方法。</li>
<li>1：启动。已经调用 open() 方法，但尚未调用 send() 方法。</li>
<li>2：发送。已经调用 send() 方法，但尚未接收到响应。</li>
<li>3：接收。已经接收到部分响应数据。</li>
<li>4：完成。已经接收到全部响应数据，而且已经可以在客户端使用了。</li>
<li>只要 readyState 属性的值由一个值变成另一个值，都会触发一次 readystatechange 事件。</li>
</ul>
</li>
<li>responseText：作为响应主体被返回的文本。</li>
<li>responseXML：如果响应的内容类型是”text/xml”或”application/xml”，这个属性中将保存包含着响应数据的 XML DOM 文档。</li>
<li>status：响应的 HTTP 状态。</li>
<li>statusText： HTTP 状态的说明</li>
</ul>
</li>
</ul>
<h3 id="GET-请求"><a href="#GET-请求" class="headerlink" title="GET 请求"></a>GET 请求</h3><ul>
<li>查询字符串中每个参数的名称和值都必须使用 encodeURIComponent() 进行编码，然后才能放到 URL 的末尾</li>
</ul>
<h3 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h3><ul>
<li>使用 XHR 来模仿表单提交：首先将 Content-Type 头部信息设置为 application/x-www-form-urlencoded，</li>
</ul>
<h2 id="XMLHttpRequest-2-级"><a href="#XMLHttpRequest-2-级" class="headerlink" title="XMLHttpRequest 2 级"></a>XMLHttpRequest 2 级</h2><ul>
<li><p>FormData</p>
<ul>
<li>append() 方法接收两个参数：键和值<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> FormData();</span><br><span class="line">data.append(<span class="string">"name"</span>, <span class="string">"Nicholas"</span>);</span><br><span class="line">xhr.send(data);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>超时设定</p>
<ul>
<li>表示请求在等待响应多少毫秒之后就终止</li>
<li>在给 timeout 设置一个数值后，如果在规定的时间内浏览器还没有接收到响应，那么就会触发 timeout 事件，进而会调用 ontimeout 事件处理程序<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xhr.timeout = <span class="number">1000</span>; <span class="comment">// 将超时设置为 1 秒钟（仅适用于 IE8+）</span></span><br><span class="line">xhr.ontimeout = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">"Request did not return in a second."</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>overrideMimeType() 方法</p>
<ul>
<li>重写 XHR 响应的 MIME 类型</li>
<li>调用 overrideMimeType() 必须在 send() 方法之前，才能保证重写响应的 MIME 类 xhr.overrideMimeType(“text/xml”);</li>
</ul>
</li>
</ul>
<h2 id="进度事件"><a href="#进度事件" class="headerlink" title="进度事件"></a>进度事件</h2><ul>
<li><p>load 事件</p>
<ul>
<li>响应接收完毕后将触发 load 事件，因此也就没有必要去检查 readyState 属性了<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = createXHR();</span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>)&#123;</span><br><span class="line">  alert(xhr.responseText);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  alert(<span class="string">"Request was unsuccessful: "</span> + xhr.status);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"altevents.php"</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>progress 事件</p>
<ul>
<li>这个事件会在浏览器接收新数据期间周期性地触发</li>
<li>lengthComputable 是一个表示进度信息是否可用的布尔值， position 表示已经接收的字节数， totalSize 表示根据 Content-Length 响应头部确定的预期字节数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xhr.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> divStatus = <span class="built_in">document</span>.getElementById(<span class="string">"status"</span>);</span><br><span class="line"><span class="keyword">if</span> (event.lengthComputable)&#123;</span><br><span class="line">  divStatus.innerHTML = <span class="string">"Received "</span> + event.position + <span class="string">" of "</span> +</span><br><span class="line">  event.totalSize +<span class="string">" bytes"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="长轮询是传统轮询（也称为短轮询）的一个翻版，即浏览器定时向服务器发送请求，看有没有更新的数据"><a href="#长轮询是传统轮询（也称为短轮询）的一个翻版，即浏览器定时向服务器发送请求，看有没有更新的数据" class="headerlink" title="长轮询是传统轮询（也称为短轮询）的一个翻版，即浏览器定时向服务器发送请求，看有没有更新的数据"></a>长轮询是传统轮询（也称为短轮询）的一个翻版，即浏览器定时向服务器发送请求，看有没有更新的数据</h2><h2 id="Web-Sockets"><a href="#Web-Sockets" class="headerlink" title="Web Sockets"></a>Web Sockets</h2><ul>
<li>Web Sockets API<ul>
<li>var socket = new WebSocket(“ws://www.example.com/server.php”);<br>必须给 WebSocket 构造函数传入绝对 URL。</li>
</ul>
</li>
<li>发送和接收数据<ul>
<li>socket.send(“Hello world!”)</li>
<li>Web Sockets 只能通过连接发送纯文本数据，所以对于复杂的数据结构，在通过连接发送之前，必须进行序列化</li>
<li>当服务器向客户端发来消息时， WebSocket 对象就会触发 message 事件</li>
</ul>
</li>
<li>其他事件<ul>
<li>open，error，close</li>
<li>WebSocket 对象不支持 DOM 2 级事件侦听器，因此必须使用 DOM 0 级语法分别定义每个事件处（onopen）</li>
</ul>
</li>
</ul>
<h2 id="事-件"><a href="#事-件" class="headerlink" title="事 件"></a>事 件</h2><h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><ul>
<li>事件流描述的是从页面中接收事件的顺序<ul>
<li>分类<ul>
<li>IE 的事件流是事件冒泡流</li>
<li>Netscape Communicator 的事件流是事件捕获流</li>
</ul>
</li>
</ul>
</li>
<li>事件冒泡<ul>
<li>IE 的事件流叫做事件冒泡（event bubbling），即事件开始时由最具体的元素（可以认为是你点击的那个元素）接收，然后逐级向上传播到较为不具体的节点（文档）</li>
</ul>
</li>
<li>事件捕获<ul>
<li>事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件</li>
</ul>
</li>
<li>DOM 事件流<ul>
<li>“DOM2 级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。</li>
</ul>
</li>
</ul>
<h3 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h3><ul>
<li>响应某个事件的函数就叫做事件处理程序（或事件侦听器）。事件处理程序的名字以”on”开头</li>
<li>HTML 事件处理程序<ul>
<li><input type="button" value="Click Me" onclick="alert('Clicked')"></li>
<li><input type="button" value="Click Me" onclick="showMessage()"></li>
</ul>
</li>
<li><p>DOM0 级事件处理程序</p>
<ul>
<li>通过 JavaScript 指定事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性</li>
<li><p>每个元素（包括 window 和 document）都有自己的事件处理程序属性，这些属性通常全部小写</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">"Clicked"</span>);</span><br><span class="line">  alert(<span class="keyword">this</span>.id);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>程序中的 this 引用当前元素</p>
</li>
<li>删除通过 DOM0 级方法指定的事件处理程序只要将事件处理程序属性的值设置为 null 即可</li>
</ul>
</li>
<li><p>DOM2 级事件处理程序</p>
<ul>
<li>定义了两个方法，用于处理指定和删除事件处理程序的操作： addEventListener() 和 removeEventListener()。</li>
<li>接受 3 个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是 true，表示在捕获阶段调用事件处理程序；如果是 false，表示在冒泡阶段调用事件处理程序</li>
<li>程序中的 this 引用当前元素</li>
<li>使用 DOM2 级方法添加事件处理程序的主要好处是可以添加多个事件处理程序</li>
<li>通过 addEventListener() 添加的匿名函数将无法移除</li>
</ul>
</li>
<li><p>IE 事件处理程序</p>
<ul>
<li>IE 实现了与 DOM 中类似的两个方法： attachEvent() 和 detachEvent()。</li>
<li>这两个方法接受相同的两个参数：事件处理程序名称与事件处理程序函数。</li>
<li>由于 IE8 及更早版本只支持事件冒泡，所以通过 attachEvent() 添加的事件处理程序都会被添加到冒泡阶段</li>
<li>attachEvent() 的第一个参数是”onclick”</li>
<li>在使用 attachEvent() 方法的情况下，事件处理程序会在全局作用域中运行，因此 this 等于 window</li>
</ul>
</li>
</ul>
<h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><ul>
<li><p>DOM 中的事件对象</p>
<ul>
<li>无论指定事件处理程序时使用什么方法（DOM0 级或 DOM2 级） ，都会传入 event 对象</li>
<li>在事件处理程序内部，对象 this 始终等于 currentTarget 的值（就是当前这个元素），而 target 则只包含事件的实际目标（真正触发的目标)</li>
<li>在需要通过一个函数处理多个事件时，可以使用 type 属性</li>
<li>要阻止特定事件的默认行为，可以使用 preventDefault() 方法<ul>
<li>链接的默认行为就是在被单击时会导航到其 href 特性指定的 URL</li>
</ul>
</li>
<li>stopPropagation() 方法用于立即停止事件在 DOM 层次中的传播，即取消进一步的事件捕获或冒泡</li>
<li>事件对象的 eventPhase 属性，可以用来确定事件当前正位于事件流的哪个阶段。<ul>
<li>在捕获阶段 eventPhase 等于 1；处于目标对象上 eventPhase 等于 2；冒泡阶段 eventPhase 等于 3。</li>
</ul>
</li>
</ul>
</li>
<li><p>IE 中的事件对象</p>
<ul>
<li>在使用 DOM0 级方法添加事件处理程序时， event 对象作为 window 对象的一个属性存在，可是，如果事件处理程序是使用 attachEvent() 添加的，那么就会有一个 event 对象作为参数被传入事件处理程序函数中</li>
<li>returnValue 属性相当于 DOM 中的 preventDefault() 方法，它们的作用都是取消给定事件的默认行为。</li>
<li>cancelBubble 属性与 DOM 中的 stopPropagation() 方法作用相同，都是用来停止事件冒泡的</li>
</ul>
</li>
</ul>
<h3 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h3><ul>
<li><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3></li>
<li>事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件<ul>
<li>整个页面占用的内存空间更少，能够提升整体性能。</li>
</ul>
</li>
</ul>
<h3 id="移除事件处理程序"><a href="#移除事件处理程序" class="headerlink" title="移除事件处理程序"></a>移除事件处理程序</h3><ul>
<li>如果你知道某个元素即将被移除，那么最好手工移除事件处理程序</li>
</ul>
<h3 id="模拟事件"><a href="#模拟事件" class="headerlink" title="模拟事件"></a>模拟事件</h3><ul>
<li>DOM 中的事件模拟</li>
</ul>
<h2 id="不在块中定义函数时，先提升函数，再提升变量声明。"><a href="#不在块中定义函数时，先提升函数，再提升变量声明。" class="headerlink" title="不在块中定义函数时，先提升函数，再提升变量声明。"></a>不在块中定义函数时，先提升函数，再提升变量声明。</h2><h2 id="React-相关"><a href="#React-相关" class="headerlink" title="React 相关"></a>React 相关</h2><ul>
<li>setState<ul>
<li>不会立刻改变 React 组件中 state 的值；<ul>
<li>render 函数被重新执行时 this.state 才被改变。</li>
</ul>
</li>
<li>多次 setState 函数调用产生的效果会合并。</li>
<li>setState 通过引发一次组件的更新过程来引发重新绘制；</li>
<li>同步更新 state 的方法<ul>
<li>传递给 this.setState 一个函数</li>
<li>在React中，如果是由React引发的事件处理（比如通过onClick引发的事件处理），调用setState不会同步更新this.state，除此之外的setState调用会同步执行this.state。所谓“除此之外”，指的是绕过React通过addEventListener直接添加的事件处理函数，还有通过setTimeout/setInterval产生的异步调用。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>每个函数都有一个属性叫做prototype。</li>
<li>这个prototype的属性值是一个对象（属性的集合，再次强调！），默认的只有一个叫做constructor的属性，指向这个函数本身。</li>
<li>每个对象都有一个隐藏的属性——“<strong>proto</strong>”，这个属性引用了创建这个对象的函数的prototype。即：fn.<strong>proto</strong> === Fn.prototype。这里的”<strong>proto</strong>“成为“隐式原型”</li>
<li>Instanceof运算符的第一个变量是一个对象，暂时称为A；第二个变量一般是一个函数，暂时称为B。<br>Instanceof的判断队则是：沿着A的<strong>proto</strong>这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。</li>
</ul>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="http://yoursite.com">我是你豆子欧巴</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="http://yoursite.com/2018/01/23/面试整理-JavaScript-篇/">http://yoursite.com/2018/01/23/面试整理-JavaScript-篇/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span>
      
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>



      
      
    

    
      <footer class="post-footer">
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2018/01/25/for-in-循环顺序的问题/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">for in 循环顺序的问题</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2018/01/02/二分查找/">
        <span class="next-text nav-default">二分查找</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    
    
      
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2018

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">我是你豆子欧巴</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  



    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  </body>
</html>
