<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="面试整理 JavaScript 篇"/>













  <link rel="alternate" href="/default" title="我是你豆子欧巴">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0" />



<link rel="canonical" href="http://yoursite.com/2018/01/23/面试整理-JavaScript-篇/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />




  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>





  <script src="//cdn1.lncld.net/static/js/3.1.1/av-min.js"></script>
  <script id="leancloud">
    AV.init({
      appId: "BFBKC2C7jVkD7w4SCRF57xom-gzGzoHsz",
      appKey: "elTqQP3tDP3wAwIFKyE57fHe"
    });
  </script>





    <title> 面试整理 JavaScript 篇 - 我是你豆子欧巴 </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">我是你豆子欧巴</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            标签
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            分类
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            关于
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">我是你豆子欧巴</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              标签
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              分类
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          面试整理 JavaScript 篇
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-01-23
        </span>
        
        
        <div class="post-visits"
             data-url="/2018/01/23/面试整理-JavaScript-篇/"
             data-title="面试整理 JavaScript 篇">
            阅读次数
          </div>
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是关键字和保留字"><span class="toc-text"><a href="#&#x4EC0;&#x4E48;&#x662F;&#x5173;&#x952E;&#x5B57;&#x548C;&#x4FDD;&#x7559;&#x5B57;" class="headerlink" title="&#x4EC0;&#x4E48;&#x662F;&#x5173;&#x952E;&#x5B57;&#x548C;&#x4FDD;&#x7559;&#x5B57;"></a>&#x4EC0;&#x4E48;&#x662F;&#x5173;&#x952E;&#x5B57;&#x548C;&#x4FDD;&#x7559;&#x5B57;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS-中基本的数据类型"><span class="toc-text"><a href="#JS-&#x4E2D;&#x57FA;&#x672C;&#x7684;&#x6570;&#x636E;&#x7C7B;&#x578B;" class="headerlink" title="JS &#x4E2D;&#x57FA;&#x672C;&#x7684;&#x6570;&#x636E;&#x7C7B;&#x578B;"></a>JS &#x4E2D;&#x57FA;&#x672C;&#x7684;&#x6570;&#x636E;&#x7C7B;&#x578B;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#typeof-操作符"><span class="toc-text"><a href="#typeof-&#x64CD;&#x4F5C;&#x7B26;" class="headerlink" title="typeof &#x64CD;&#x4F5C;&#x7B26;"></a>typeof &#x64CD;&#x4F5C;&#x7B26;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关于-null-类型的注意点"><span class="toc-text"><a href="#&#x5173;&#x4E8E;-null-&#x7C7B;&#x578B;&#x7684;&#x6CE8;&#x610F;&#x70B9;" class="headerlink" title="&#x5173;&#x4E8E; null &#x7C7B;&#x578B;&#x7684;&#x6CE8;&#x610F;&#x70B9;"></a>&#x5173;&#x4E8E; null &#x7C7B;&#x578B;&#x7684;&#x6CE8;&#x610F;&#x70B9;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本类型和引用类型的值"><span class="toc-text"><a href="#&#x57FA;&#x672C;&#x7C7B;&#x578B;&#x548C;&#x5F15;&#x7528;&#x7C7B;&#x578B;&#x7684;&#x503C;" class="headerlink" title="&#x57FA;&#x672C;&#x7C7B;&#x578B;&#x548C;&#x5F15;&#x7528;&#x7C7B;&#x578B;&#x7684;&#x503C;"></a>&#x57FA;&#x672C;&#x7C7B;&#x578B;&#x548C;&#x5F15;&#x7528;&#x7C7B;&#x578B;&#x7684;&#x503C;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#检测类型"><span class="toc-text"><a href="#&#x68C0;&#x6D4B;&#x7C7B;&#x578B;" class="headerlink" title="&#x68C0;&#x6D4B;&#x7C7B;&#x578B;"></a>&#x68C0;&#x6D4B;&#x7C7B;&#x578B;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#延长作用域链"><span class="toc-text"><a href="#&#x5EF6;&#x957F;&#x4F5C;&#x7528;&#x57DF;&#x94FE;" class="headerlink" title="&#x5EF6;&#x957F;&#x4F5C;&#x7528;&#x57DF;&#x94FE;"></a>&#x5EF6;&#x957F;&#x4F5C;&#x7528;&#x57DF;&#x94FE;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#垃圾收集"><span class="toc-text"><a href="#&#x5783;&#x573E;&#x6536;&#x96C6;" class="headerlink" title="&#x5783;&#x573E;&#x6536;&#x96C6;"></a>&#x5783;&#x573E;&#x6536;&#x96C6;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-类型"><span class="toc-text"><a href="#Object-&#x7C7B;&#x578B;" class="headerlink" title="Object &#x7C7B;&#x578B;"></a>Object &#x7C7B;&#x578B;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Array-类型"><span class="toc-text"><a href="#Array-&#x7C7B;&#x578B;" class="headerlink" title="Array &#x7C7B;&#x578B;"></a>Array &#x7C7B;&#x578B;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Function-类型"><span class="toc-text"><a href="#Function-&#x7C7B;&#x578B;" class="headerlink" title="Function &#x7C7B;&#x578B;"></a>Function &#x7C7B;&#x578B;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本包装类型"><span class="toc-text"><a href="#&#x57FA;&#x672C;&#x5305;&#x88C5;&#x7C7B;&#x578B;" class="headerlink" title="&#x57FA;&#x672C;&#x5305;&#x88C5;&#x7C7B;&#x578B;"></a>&#x57FA;&#x672C;&#x5305;&#x88C5;&#x7C7B;&#x578B;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Global-对象"><span class="toc-text"><a href="#Global-&#x5BF9;&#x8C61;" class="headerlink" title="Global &#x5BF9;&#x8C61;"></a>Global &#x5BF9;&#x8C61;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象"><span class="toc-text"><a href="#&#x9762;&#x5411;&#x5BF9;&#x8C61;" class="headerlink" title="&#x9762;&#x5411;&#x5BF9;&#x8C61;"></a>&#x9762;&#x5411;&#x5BF9;&#x8C61;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承"><span class="toc-text"><a href="#&#x7EE7;&#x627F;" class="headerlink" title="&#x7EE7;&#x627F;"></a>&#x7EE7;&#x627F;</span></a></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <h2 id="什么是关键字和保留字"><a href="#什么是关键字和保留字" class="headerlink" title="什么是关键字和保留字"></a>什么是关键字和保留字</h2><ul>
<li>关键字<ul>
<li>定义：可用于表示控制语句的开始或结束，或者用于执行特定操作字符</li>
</ul>
</li>
<li>保留字<ul>
<li>定义：有可能在将来被用作关键字的字符</li>
</ul>
</li>
</ul>
<p>不要使用关键字和保留字作为标识符和属性名</p>
<h2 id="JS-中基本的数据类型"><a href="#JS-中基本的数据类型" class="headerlink" title="JS 中基本的数据类型"></a>JS 中基本的数据类型</h2><p>ECMAScript 中有 5 种简单数据类型（也称为基本数据类型）：Undefined、Null、Boolean、Number 和 String。还有 1 种复杂数据类型——Object</p>
<h2 id="typeof-操作符"><a href="#typeof-操作符" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h2><ul>
<li>typeof 是一个操作符而不是函数，因此例子中的圆括号尽管可以使用，但不是必需的</li>
<li>对一个值使用 typeof 操作符可能返回下列某个字符串：<ul>
<li>“undefined”——如果这个值未定义；</li>
<li>“boolean”——如果这个值是布尔值；</li>
<li>“string”——如果这个值是字符串；</li>
<li>“number”——如果这个值是数值；</li>
<li>“object”——如果这个值是对象或 null；</li>
<li>“function”——如果这个值是函数</li>
</ul>
</li>
<li>对未初始化的变量执行 typeof 操作符会返回 undefined 值，而对未声明<br>的变量执行 typeof 操作符同样也会返回 undefined 值。</li>
</ul>
<h2 id="关于-null-类型的注意点"><a href="#关于-null-类型的注意点" class="headerlink" title="关于 null 类型的注意点"></a>关于 null 类型的注意点</h2><ul>
<li>从逻辑角度来看， null 值表示一个空对象指针，而这也正是使用 typeof 操作符检测 null 值时会返回”object”的原因</li>
<li>undefined 值是派生自 null 值的，因此 null == undefined // true</li>
</ul>
<h2 id="基本类型和引用类型的值"><a href="#基本类型和引用类型的值" class="headerlink" title="基本类型和引用类型的值"></a>基本类型和引用类型的值</h2><p>ECMAScript 变量可能包含两种不同数据类型的值：基本类型值和引用类型值。 基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。</p>
<p>基本数据类型： Undefined、 Null、 Boolean、 Number 和 String。这 5 种基本数据类型是按值访问<br>的，因为可以操作保存在变量中的实际的值。保存在栈中</p>
<p>引用类型的值是保存在内存中的对象。在操作对象时，实际上是在操作对象的引用而不是实际的对象。保存在堆中</p>
<h2 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h2><ul>
<li>typeof 不能检查不 null</li>
<li>instanceof 适合检查引用类型</li>
</ul>
<h2 id="延长作用域链"><a href="#延长作用域链" class="headerlink" title="延长作用域链"></a>延长作用域链</h2><ul>
<li>with 语句</li>
<li>try…catch</li>
</ul>
<h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><p>JavaScript 的解释器可以检测到何时程序不再使用一个对象了，当他确定了一个对象是无用的时候，他就知道不再需要这个对象，可以把它所占用的内存释放掉了。</p>
<ul>
<li>标记清除</li>
<li>引用计数（不常用）</li>
</ul>
<p>确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为 null 来释放其引用——这个做法叫做解除引用（dereferencing）。</p>
<h2 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h2><ul>
<li>在通过对象字面量定义对象时，实际上不会调用 Object 构造函数</li>
</ul>
<h2 id="Array-类型"><a href="#Array-类型" class="headerlink" title="Array 类型"></a>Array 类型</h2><ul>
<li>检测数组：Array.isArray</li>
<li>调用数组的 toString()方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。</li>
<li>alert()要接收字符串参数，所以它会在后台调用 toString()方法，由此会得到与直接调用 toString()方法相同的结果。</li>
<li>数组可以用来模拟栈和队列，栈：后进先出.队列：先进先出</li>
<li>sort 方法：<ul>
<li>在默认情况下， sort()方法按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。为了实现排序， sort()方法会调用每个数组项的 toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值， sort()方法比较的也是字符串</li>
<li>sort()方法可以接收一个比较函数作为参数。比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回 0，如果第一个参数应该位于第二个之后则返回一个正数。</li>
</ul>
</li>
<li>splice 方法：<ul>
<li>删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。例如， splice(0,2)会删除数组中的前两项。</li>
<li>插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。例如，splice(2,0,”red”,”green”)会从当前数组的位置 2 开始插入字符串”red”和”green”。</li>
<li>替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，splice (2,1,”red”,”green”)会删除当前数组位置 2 的项，然后再从位置 2 开始插入字符串”red”和”green”。</li>
</ul>
</li>
</ul>
<h2 id="Function-类型"><a href="#Function-类型" class="headerlink" title="Function 类型"></a>Function 类型</h2><ul>
<li>不推荐使用Function 构造函数定义函数，因为这种语<br>法会导致解析两次代码（第一次是解析常规 ECMAScript 代码，第二次是解析传入构造函数中的字符串），从而影响性能。</li>
<li>解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行</li>
<li>arguments 的主要用途是保存函数参数，但这个对象还有一个名叫 callee 的属性，该属性是一个指针，指向拥有这个 arguments 对象的函数。</li>
<li>每个函数都包含两个属性： length 和 prototype。其中， length 属性表示函数希望接收的命名参数的个数</li>
</ul>
<h2 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h2><p>ECMAScript 提供了 3 个特殊的引用类型： Boolean、 Number 和String。</p>
<p>实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">"some text"</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p>这个例子中的变量 s1 包含一个字符串，字符串当然是基本类型值。而下一行调用了 s1 的substring()方法，并将返回的结果保存在了 s2 中。我们知道，基本类型值不是对象，因而从逻辑上讲它们不应该有方法（尽管如我们所愿，它们确实有方法）。</p>
<p>其实，为了让我们实现这种直观的操作，后台已经自动完成了一系列的处理。当第二行代码访问 s1 时，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台都会自动完成下列处理<br>(1) 创建 String 类型的一个实例；<br>(2) 在实例上调用指定的方法；<br>(3) 销毁这个实例。<br>可以将以上三个步骤想象成是执行了下列 ECMAScript 代码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"some text"</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">2</span>);</span><br><span class="line">s1 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></p>
<p>经过此番处理，基本的字符串值就变得跟对象一样了。而且，上面这三个步骤也分别适用于 Boolean和 Number 类型对应的布尔值和数字值。</p>
<p>自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。</p>
<ul>
<li>Number 类型<ul>
<li>toString 方法：传递一个表示基数的参数，告诉它返回几进制字符串格式</li>
<li>toFixed: 按照指定的小数位返回数值的字符串</li>
</ul>
</li>
<li>String类型<ul>
<li>charAt()方法：返回给定位置的那个字符</li>
<li>charCodeAt()：返回指定位置字字符编码</li>
<li>concat()： 用于将一或多个字符串拼接起来，返回拼接得到的新字符串</li>
<li>substr：第二个参数指定的则是返回的字符个数</li>
</ul>
</li>
</ul>
<h2 id="Global-对象"><a href="#Global-对象" class="headerlink" title="Global 对象"></a>Global 对象</h2><ul>
<li>encodeURI()和 encodeURIComponent()</li>
</ul>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ul>
<li>Object.defineProperty()<ul>
<li>修改属性默认的特性</li>
<li>可以多次调用 Object.defineProperty()方法修改同一个属性，但在把 configurable特性设置为false 之后就会有限制了。</li>
<li>访问器属性：getter 和 setter</li>
</ul>
</li>
<li>Object.defineProperties()</li>
<li>Object.getOwnPropertyDescriptor</li>
<li><p>创建对象</p>
<ul>
<li><p>工厂模式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.job = job;</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数模式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>以这种方式调用构造函数实际上会经历以下 4个步骤：<br>(1) 创建一个新对象；<br>(2) 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；<br>(3) 执行构造函数中的代码（为这个新对象添加属性）；<br>(4) 返回新对象。</li>
<li>使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍</li>
</ul>
</li>
<li><p>原型模式</p>
<ul>
<li>每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向一个对象，包含所有实例共享的属性和方法。所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性指向 prototype 属性所在函数</li>
<li>实例自身有一个[[Prototype]]，可以通过 <strong>proto</strong> 访问其构造函数的 prototype （原型对象）<br>isPrototypeOf，Object.getPrototypeOf 可以用来判断原型对象</li>
<li>每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。</li>
<li>无论该属性存在于实例中还是存在于原型中, 调用 in 始终都返回 true， 使用 hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中。</li>
<li>要取得对象上所有可枚举的实例属性，不包含原型上的，可以使用 Object.keys()方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>组合使用构造函数模式和原型模式</p>
</li>
<li><p>动态原型模式</p>
</li>
<li><p>寄生构造函数模式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.job = job;</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul>
<li>原型链<ul>
<li>其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法</li>
<li>实现的本质是重写原型对象，代之以一个新类型的实例。</li>
<li>所有函数的默认原型都是 Object 的实例，因此默认原型都会包含一个内部指针，指向 Object.prototype。</li>
<li>确定原型和实例的关系<ul>
<li>instanceof 操作符</li>
<li>isPrototypeOf()方法</li>
</ul>
</li>
</ul>
</li>
<li><p>借用构造函数</p>
<ul>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//继承了 SuperType</span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance2.colors); <span class="comment">//"red,blue,green"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>组合继承</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//继承属性</span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承方法</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="http://yoursite.com">我是你豆子欧巴</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="http://yoursite.com/2018/01/23/面试整理-JavaScript-篇/">http://yoursite.com/2018/01/23/面试整理-JavaScript-篇/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span>
      
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>



      
      
    

    
      <footer class="post-footer">
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2018/01/25/for-in-循环顺序的问题/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">for in 循环顺序的问题</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2018/01/02/二分查找/">
        <span class="next-text nav-default">二分查找</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    
    
      
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2018

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">我是你豆子欧巴</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  



    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  </body>
</html>
