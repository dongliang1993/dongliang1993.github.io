<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="面试整理 JavaScript 篇"/>













  <link rel="alternate" href="/default" title="我是你豆子欧巴">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0" />



<link rel="canonical" href="http://yoursite.com/2018/01/23/面试整理-JavaScript-篇/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />




  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>





  <script src="//cdn1.lncld.net/static/js/3.1.1/av-min.js"></script>
  <script id="leancloud">
    AV.init({
      appId: "BFBKC2C7jVkD7w4SCRF57xom-gzGzoHsz",
      appKey: "elTqQP3tDP3wAwIFKyE57fHe"
    });
  </script>





    <title> 面试整理 JavaScript 篇 - 我是你豆子欧巴 </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">我是你豆子欧巴</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            Home
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            Categories
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            About
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">我是你豆子欧巴</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              Home
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              Archives
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              Tags
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              Categories
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              About
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          面试整理 JavaScript 篇
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-01-23
        </span>
        
        
        <div class="post-visits"
             data-url="/2018/01/23/面试整理-JavaScript-篇/"
             data-title="面试整理 JavaScript 篇">
            阅读次数
          </div>
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#标识符"><span class="toc-text"><a href="#&#x6807;&#x8BC6;&#x7B26;" class="headerlink" title="&#x6807;&#x8BC6;&#x7B26;"></a>&#x6807;&#x8BC6;&#x7B26;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#严格模式"><span class="toc-text"><a href="#&#x4E25;&#x683C;&#x6A21;&#x5F0F;" class="headerlink" title="&#x4E25;&#x683C;&#x6A21;&#x5F0F;"></a>&#x4E25;&#x683C;&#x6A21;&#x5F0F;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关键字和保留字"><span class="toc-text"><a href="#&#x5173;&#x952E;&#x5B57;&#x548C;&#x4FDD;&#x7559;&#x5B57;" class="headerlink" title="&#x5173;&#x952E;&#x5B57;&#x548C;&#x4FDD;&#x7559;&#x5B57;"></a>&#x5173;&#x952E;&#x5B57;&#x548C;&#x4FDD;&#x7559;&#x5B57;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS-中基本的数据类型"><span class="toc-text"><a href="#JS-&#x4E2D;&#x57FA;&#x672C;&#x7684;&#x6570;&#x636E;&#x7C7B;&#x578B;" class="headerlink" title="JS &#x4E2D;&#x57FA;&#x672C;&#x7684;&#x6570;&#x636E;&#x7C7B;&#x578B;"></a>JS &#x4E2D;&#x57FA;&#x672C;&#x7684;&#x6570;&#x636E;&#x7C7B;&#x578B;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#typeof-操作符"><span class="toc-text"><a href="#typeof-&#x64CD;&#x4F5C;&#x7B26;" class="headerlink" title="typeof &#x64CD;&#x4F5C;&#x7B26;"></a>typeof &#x64CD;&#x4F5C;&#x7B26;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关于-null-类型的注意点"><span class="toc-text"><a href="#&#x5173;&#x4E8E;-null-&#x7C7B;&#x578B;&#x7684;&#x6CE8;&#x610F;&#x70B9;" class="headerlink" title="&#x5173;&#x4E8E; null &#x7C7B;&#x578B;&#x7684;&#x6CE8;&#x610F;&#x70B9;"></a>&#x5173;&#x4E8E; null &#x7C7B;&#x578B;&#x7684;&#x6CE8;&#x610F;&#x70B9;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Boolean类型"><span class="toc-text"><a href="#Boolean&#x7C7B;&#x578B;" class="headerlink" title="Boolean&#x7C7B;&#x578B;"></a>Boolean&#x7C7B;&#x578B;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Number类型"><span class="toc-text"><a href="#Number&#x7C7B;&#x578B;" class="headerlink" title="Number&#x7C7B;&#x578B;"></a>Number&#x7C7B;&#x578B;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String类型"><span class="toc-text"><a href="#String&#x7C7B;&#x578B;" class="headerlink" title="String&#x7C7B;&#x578B;"></a>String&#x7C7B;&#x578B;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#操作符（很多细节）"><span class="toc-text"><a href="#&#x64CD;&#x4F5C;&#x7B26;&#xFF08;&#x5F88;&#x591A;&#x7EC6;&#x8282;&#xFF09;" class="headerlink" title="&#x64CD;&#x4F5C;&#x7B26;&#xFF08;&#x5F88;&#x591A;&#x7EC6;&#x8282;&#xFF09;"></a>&#x64CD;&#x4F5C;&#x7B26;&#xFF08;&#x5F88;&#x591A;&#x7EC6;&#x8282;&#xFF09;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#label-语句"><span class="toc-text"><a href="#label-&#x8BED;&#x53E5;" class="headerlink" title="label &#x8BED;&#x53E5;"></a>label &#x8BED;&#x53E5;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#with语句"><span class="toc-text"><a href="#with&#x8BED;&#x53E5;" class="headerlink" title="with&#x8BED;&#x53E5;"></a>with&#x8BED;&#x53E5;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数"><span class="toc-text"><a href="#&#x51FD;&#x6570;" class="headerlink" title="&#x51FD;&#x6570;"></a>&#x51FD;&#x6570;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本类型和引用类型的值"><span class="toc-text"><a href="#&#x57FA;&#x672C;&#x7C7B;&#x578B;&#x548C;&#x5F15;&#x7528;&#x7C7B;&#x578B;&#x7684;&#x503C;" class="headerlink" title="&#x57FA;&#x672C;&#x7C7B;&#x578B;&#x548C;&#x5F15;&#x7528;&#x7C7B;&#x578B;&#x7684;&#x503C;"></a>&#x57FA;&#x672C;&#x7C7B;&#x578B;&#x548C;&#x5F15;&#x7528;&#x7C7B;&#x578B;&#x7684;&#x503C;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#检测类型"><span class="toc-text"><a href="#&#x68C0;&#x6D4B;&#x7C7B;&#x578B;" class="headerlink" title="&#x68C0;&#x6D4B;&#x7C7B;&#x578B;"></a>&#x68C0;&#x6D4B;&#x7C7B;&#x578B;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#执行环境及作用域"><span class="toc-text"><a href="#&#x6267;&#x884C;&#x73AF;&#x5883;&#x53CA;&#x4F5C;&#x7528;&#x57DF;" class="headerlink" title="&#x6267;&#x884C;&#x73AF;&#x5883;&#x53CA;&#x4F5C;&#x7528;&#x57DF;"></a>&#x6267;&#x884C;&#x73AF;&#x5883;&#x53CA;&#x4F5C;&#x7528;&#x57DF;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#垃圾收集"><span class="toc-text"><a href="#&#x5783;&#x573E;&#x6536;&#x96C6;" class="headerlink" title="&#x5783;&#x573E;&#x6536;&#x96C6;"></a>&#x5783;&#x573E;&#x6536;&#x96C6;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#引用类型"><span class="toc-text"><a href="#&#x5F15;&#x7528;&#x7C7B;&#x578B;" class="headerlink" title="&#x5F15;&#x7528;&#x7C7B;&#x578B;"></a>&#x5F15;&#x7528;&#x7C7B;&#x578B;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-类型"><span class="toc-text"><a href="#Object-&#x7C7B;&#x578B;" class="headerlink" title="Object &#x7C7B;&#x578B;"></a>Object &#x7C7B;&#x578B;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Array-类型"><span class="toc-text"><a href="#Array-&#x7C7B;&#x578B;" class="headerlink" title="Array &#x7C7B;&#x578B;"></a>Array &#x7C7B;&#x578B;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Function-类型"><span class="toc-text"><a href="#Function-&#x7C7B;&#x578B;" class="headerlink" title="Function &#x7C7B;&#x578B;"></a>Function &#x7C7B;&#x578B;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本包装类型"><span class="toc-text"><a href="#&#x57FA;&#x672C;&#x5305;&#x88C5;&#x7C7B;&#x578B;" class="headerlink" title="&#x57FA;&#x672C;&#x5305;&#x88C5;&#x7C7B;&#x578B;"></a>&#x57FA;&#x672C;&#x5305;&#x88C5;&#x7C7B;&#x578B;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Global-对象"><span class="toc-text"><a href="#Global-&#x5BF9;&#x8C61;" class="headerlink" title="Global &#x5BF9;&#x8C61;"></a>Global &#x5BF9;&#x8C61;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象"><span class="toc-text"><a href="#&#x9762;&#x5411;&#x5BF9;&#x8C61;" class="headerlink" title="&#x9762;&#x5411;&#x5BF9;&#x8C61;"></a>&#x9762;&#x5411;&#x5BF9;&#x8C61;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承"><span class="toc-text"><a href="#&#x7EE7;&#x627F;" class="headerlink" title="&#x7EE7;&#x627F;"></a>&#x7EE7;&#x627F;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数表达式"><span class="toc-text"><a href="#&#x51FD;&#x6570;&#x8868;&#x8FBE;&#x5F0F;" class="headerlink" title="&#x51FD;&#x6570;&#x8868;&#x8FBE;&#x5F0F;"></a>&#x51FD;&#x6570;&#x8868;&#x8FBE;&#x5F0F;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#递归"><span class="toc-text"><a href="#&#x9012;&#x5F52;" class="headerlink" title="&#x9012;&#x5F52;"></a>&#x9012;&#x5F52;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#闭包"><span class="toc-text"><a href="#&#x95ED;&#x5305;" class="headerlink" title="&#x95ED;&#x5305;"></a>&#x95ED;&#x5305;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模块模式（单例模式）"><span class="toc-text"><a href="#&#x6A21;&#x5757;&#x6A21;&#x5F0F;&#xFF08;&#x5355;&#x4F8B;&#x6A21;&#x5F0F;&#xFF09;" class="headerlink" title="&#x6A21;&#x5757;&#x6A21;&#x5F0F;&#xFF08;&#x5355;&#x4F8B;&#x6A21;&#x5F0F;&#xFF09;"></a>&#x6A21;&#x5757;&#x6A21;&#x5F0F;&#xFF08;&#x5355;&#x4F8B;&#x6A21;&#x5F0F;&#xFF09;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XMLHttpRequest"><span class="toc-text"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#兼容"><span class="toc-text"><a href="#&#x517C;&#x5BB9;" class="headerlink" title="&#x517C;&#x5BB9;"></a>&#x517C;&#x5BB9;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#XHR-的用法"><span class="toc-text"><a href="#XHR-&#x7684;&#x7528;&#x6CD5;" class="headerlink" title="XHR &#x7684;&#x7528;&#x6CD5;"></a>XHR &#x7684;&#x7528;&#x6CD5;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GET-请求"><span class="toc-text"><a href="#GET-&#x8BF7;&#x6C42;" class="headerlink" title="GET &#x8BF7;&#x6C42;"></a>GET &#x8BF7;&#x6C42;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#POST-请求"><span class="toc-text"><a href="#POST-&#x8BF7;&#x6C42;" class="headerlink" title="POST &#x8BF7;&#x6C42;"></a>POST &#x8BF7;&#x6C42;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XMLHttpRequest-2-级"><span class="toc-text"><a href="#XMLHttpRequest-2-&#x7EA7;" class="headerlink" title="XMLHttpRequest 2 &#x7EA7;"></a>XMLHttpRequest 2 &#x7EA7;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进度事件"><span class="toc-text"><a href="#&#x8FDB;&#x5EA6;&#x4E8B;&#x4EF6;" class="headerlink" title="&#x8FDB;&#x5EA6;&#x4E8B;&#x4EF6;"></a>&#x8FDB;&#x5EA6;&#x4E8B;&#x4EF6;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#长轮询是传统轮询（也称为短轮询）的一个翻版，即浏览器定时向服务器发送请求，看有没有更新的数据"><span class="toc-text"><a href="#&#x957F;&#x8F6E;&#x8BE2;&#x662F;&#x4F20;&#x7EDF;&#x8F6E;&#x8BE2;&#xFF08;&#x4E5F;&#x79F0;&#x4E3A;&#x77ED;&#x8F6E;&#x8BE2;&#xFF09;&#x7684;&#x4E00;&#x4E2A;&#x7FFB;&#x7248;&#xFF0C;&#x5373;&#x6D4F;&#x89C8;&#x5668;&#x5B9A;&#x65F6;&#x5411;&#x670D;&#x52A1;&#x5668;&#x53D1;&#x9001;&#x8BF7;&#x6C42;&#xFF0C;&#x770B;&#x6709;&#x6CA1;&#x6709;&#x66F4;&#x65B0;&#x7684;&#x6570;&#x636E;" class="headerlink" title="&#x957F;&#x8F6E;&#x8BE2;&#x662F;&#x4F20;&#x7EDF;&#x8F6E;&#x8BE2;&#xFF08;&#x4E5F;&#x79F0;&#x4E3A;&#x77ED;&#x8F6E;&#x8BE2;&#xFF09;&#x7684;&#x4E00;&#x4E2A;&#x7FFB;&#x7248;&#xFF0C;&#x5373;&#x6D4F;&#x89C8;&#x5668;&#x5B9A;&#x65F6;&#x5411;&#x670D;&#x52A1;&#x5668;&#x53D1;&#x9001;&#x8BF7;&#x6C42;&#xFF0C;&#x770B;&#x6709;&#x6CA1;&#x6709;&#x66F4;&#x65B0;&#x7684;&#x6570;&#x636E;"></a>&#x957F;&#x8F6E;&#x8BE2;&#x662F;&#x4F20;&#x7EDF;&#x8F6E;&#x8BE2;&#xFF08;&#x4E5F;&#x79F0;&#x4E3A;&#x77ED;&#x8F6E;&#x8BE2;&#xFF09;&#x7684;&#x4E00;&#x4E2A;&#x7FFB;&#x7248;&#xFF0C;&#x5373;&#x6D4F;&#x89C8;&#x5668;&#x5B9A;&#x65F6;&#x5411;&#x670D;&#x52A1;&#x5668;&#x53D1;&#x9001;&#x8BF7;&#x6C42;&#xFF0C;&#x770B;&#x6709;&#x6CA1;&#x6709;&#x66F4;&#x65B0;&#x7684;&#x6570;&#x636E;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Web-Sockets"><span class="toc-text"><a href="#Web-Sockets" class="headerlink" title="Web Sockets"></a>Web Sockets</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事-件"><span class="toc-text"><a href="#&#x4E8B;-&#x4EF6;" class="headerlink" title="&#x4E8B; &#x4EF6;"></a>&#x4E8B; &#x4EF6;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#事件流"><span class="toc-text"><a href="#&#x4E8B;&#x4EF6;&#x6D41;" class="headerlink" title="&#x4E8B;&#x4EF6;&#x6D41;"></a>&#x4E8B;&#x4EF6;&#x6D41;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件处理程序"><span class="toc-text"><a href="#&#x4E8B;&#x4EF6;&#x5904;&#x7406;&#x7A0B;&#x5E8F;" class="headerlink" title="&#x4E8B;&#x4EF6;&#x5904;&#x7406;&#x7A0B;&#x5E8F;"></a>&#x4E8B;&#x4EF6;&#x5904;&#x7406;&#x7A0B;&#x5E8F;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件对象"><span class="toc-text"><a href="#&#x4E8B;&#x4EF6;&#x5BF9;&#x8C61;" class="headerlink" title="&#x4E8B;&#x4EF6;&#x5BF9;&#x8C61;"></a>&#x4E8B;&#x4EF6;&#x5BF9;&#x8C61;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件类型"><span class="toc-text"><a href="#&#x4E8B;&#x4EF6;&#x7C7B;&#x578B;" class="headerlink" title="&#x4E8B;&#x4EF6;&#x7C7B;&#x578B;"></a>&#x4E8B;&#x4EF6;&#x7C7B;&#x578B;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件委托"><span class="toc-text"><a href="#&#x4E8B;&#x4EF6;&#x59D4;&#x6258;" class="headerlink" title="&#x4E8B;&#x4EF6;&#x59D4;&#x6258;"></a>&#x4E8B;&#x4EF6;&#x59D4;&#x6258;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#移除事件处理程序"><span class="toc-text"><a href="#&#x79FB;&#x9664;&#x4E8B;&#x4EF6;&#x5904;&#x7406;&#x7A0B;&#x5E8F;" class="headerlink" title="&#x79FB;&#x9664;&#x4E8B;&#x4EF6;&#x5904;&#x7406;&#x7A0B;&#x5E8F;"></a>&#x79FB;&#x9664;&#x4E8B;&#x4EF6;&#x5904;&#x7406;&#x7A0B;&#x5E8F;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模拟事件"><span class="toc-text"><a href="#&#x6A21;&#x62DF;&#x4E8B;&#x4EF6;" class="headerlink" title="&#x6A21;&#x62DF;&#x4E8B;&#x4EF6;"></a>&#x6A21;&#x62DF;&#x4E8B;&#x4EF6;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不在块中定义函数时，先提升函数，再提升变量声明。"><span class="toc-text"><a href="#&#x4E0D;&#x5728;&#x5757;&#x4E2D;&#x5B9A;&#x4E49;&#x51FD;&#x6570;&#x65F6;&#xFF0C;&#x5148;&#x63D0;&#x5347;&#x51FD;&#x6570;&#xFF0C;&#x518D;&#x63D0;&#x5347;&#x53D8;&#x91CF;&#x58F0;&#x660E;&#x3002;" class="headerlink" title="&#x4E0D;&#x5728;&#x5757;&#x4E2D;&#x5B9A;&#x4E49;&#x51FD;&#x6570;&#x65F6;&#xFF0C;&#x5148;&#x63D0;&#x5347;&#x51FD;&#x6570;&#xFF0C;&#x518D;&#x63D0;&#x5347;&#x53D8;&#x91CF;&#x58F0;&#x660E;&#x3002;"></a>&#x4E0D;&#x5728;&#x5757;&#x4E2D;&#x5B9A;&#x4E49;&#x51FD;&#x6570;&#x65F6;&#xFF0C;&#x5148;&#x63D0;&#x5347;&#x51FD;&#x6570;&#xFF0C;&#x518D;&#x63D0;&#x5347;&#x53D8;&#x91CF;&#x58F0;&#x660E;&#x3002;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-相关"><span class="toc-text"><a href="#React-&#x76F8;&#x5173;" class="headerlink" title="React &#x76F8;&#x5173;"></a>React &#x76F8;&#x5173;</span></a></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ul>
<li>定义：指变量、函数、属性的名字，或者函数的参数</li>
<li>规则<ul>
<li>第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；</li>
<li>其他字符可以是字母、下划线、美元符号或数字。</li>
</ul>
</li>
<li>不能把关键字、保留字、 true、 false 和 null 用作标识符。 </li>
</ul>
<h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><ul>
<li>严格模式是为 JavaScript 定义了一种不同的<br>解析与执行模型</li>
<li>在顶部或者函数内部的上方 “use strict”;</li>
</ul>
<h2 id="关键字和保留字"><a href="#关键字和保留字" class="headerlink" title="关键字和保留字"></a>关键字和保留字</h2><ul>
<li>关键字<ul>
<li>定义：可用于表示控制语句的开始或结束，或者用于执行特定操作字符</li>
</ul>
</li>
<li>保留字<ul>
<li>定义：有可能在将来被用作关键字的字符</li>
</ul>
</li>
<li>不要使用关键字和保留字作为标识符和属性名</li>
</ul>
<h2 id="JS-中基本的数据类型"><a href="#JS-中基本的数据类型" class="headerlink" title="JS 中基本的数据类型"></a>JS 中基本的数据类型</h2><p>ECMAScript 中有 5 种简单数据类型（也称为基本数据类型）：Undefined、Null、Boolean、Number 和 String。还有 1 种复杂数据类型——Object</p>
<h2 id="typeof-操作符"><a href="#typeof-操作符" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h2><ul>
<li>typeof 是一个操作符而不是函数，因此例子中的圆括号尽管可以使用，但不是必需的</li>
<li>对一个值使用 typeof 操作符可能返回下列某个字符串：<ul>
<li>“undefined”——如果这个值未定义；</li>
<li>“boolean”——如果这个值是布尔值；</li>
<li>“string”——如果这个值是字符串；</li>
<li>“number”——如果这个值是数值；</li>
<li>“object”——如果这个值是对象或 null；</li>
<li>“function”——如果这个值是函数</li>
</ul>
</li>
<li>对未初始化（即未赋值）的变量执行 typeof 操作符会返回 undefined 值，而对未声明的变量执行 typeof 操作符同样也会返回 undefined 值。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message; <span class="comment">// 这个变量声明之后默认取得了 undefined 值</span></span><br><span class="line"><span class="comment">// 下面这个变量并没有声明</span></span><br><span class="line"><span class="comment">// var age</span></span><br><span class="line">alert(<span class="keyword">typeof</span> message); <span class="comment">// "undefined"</span></span><br><span class="line">alert(<span class="keyword">typeof</span> age); <span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="关于-null-类型的注意点"><a href="#关于-null-类型的注意点" class="headerlink" title="关于 null 类型的注意点"></a>关于 null 类型的注意点</h2><ul>
<li>从逻辑角度来看， null 值表示一个空对象指针，而这也正是使用 typeof 操作符检测 null 值时会返回”object”的原因</li>
<li>undefined 值是派生自 null 值的，因此 null == undefined // true</li>
</ul>
<h2 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h2><ul>
<li>转换为false的值：false, ‘’（空字符串），0，NaN，null，undefined</li>
<li>注意 负数其实是转换成 true 的</li>
</ul>
<h2 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h2><ul>
<li>八进制<ul>
<li>第一位必须是零（0） ，然后是八进制数字序列（0～7） 。</li>
<li>如果字面值中的数值超出了范围，那么前导零将被忽略，后面的数值将被当作十进制数值解析</li>
</ul>
</li>
<li>十六进制<ul>
<li>前两位必须是 0x，后跟任何十六进制数字（0～9 及 A～F）。其中，字母 A～F可以大写，也可以小写。</li>
</ul>
</li>
<li>浮点数值计算会产生舍入误差</li>
<li>数值范围<ul>
<li>ECMAScript 能够表示的最小数值保存在 Number.MIN_VALUE<br>中；能够表示的最大数值保存在Number.MAX_VALUE 如果某次计算的结果得到了一个超出 JavaScript 数值范围的值，那么这个数值将被自动转换成特殊的 Infinity 值。具体来说，如果这个数值是负数，则会被转换成-Infinity（负无穷），如果这个数值是正数，则会被转换成 Infinity（正无穷）。</li>
<li>isFinite</li>
</ul>
</li>
<li>NaN<ul>
<li>任何涉及 NaN 的操作（例如 NaN/10）都会返回 NaN，</li>
<li>NaN 与任何值都不相等，包括 NaN 本身。</li>
<li>isNaN 来判断<ul>
<li>isNaN()在接收到一个值之后，会尝试<br>将这个值转换为数值。某些不是数值的值会直接转换为数值，例如字符串”10”或 Boolean 值。而任何<br>不能被转换为数值的值都会导致这个函数返回 true</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><ul>
<li>数值、布尔值、对象和字符串值都有 toString()方法。但 null 和 undefined 值没有这个方法。</li>
<li>在调用数值的 toString()方法时，可<br>以传递一个参数：输出数值的基数</li>
</ul>
<h2 id="操作符（很多细节）"><a href="#操作符（很多细节）" class="headerlink" title="操作符（很多细节）"></a>操作符（很多细节）</h2><ul>
<li>在应用于对象时，相应的操作符通常都会先后调用对象的 valueOf()和（或） toString()方法，以便取得可以操作的值</li>
<li>位操作符（未看完）<ul>
<li>按内存中表示数值的位来操作数值</li>
<li></li>
</ul>
</li>
</ul>
<h2 id="label-语句"><a href="#label-语句" class="headerlink" title="label 语句"></a>label 语句</h2><ul>
<li>break 和 continue 语句都可以与 label 语句联合使用，从而返回代码中特定的位置<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">outermost:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span> outermost;</span><br><span class="line">    &#125;</span><br><span class="line">    num++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">alert(num); <span class="comment">//55</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a>with语句</h2><ul>
<li>with 语句的作用是将代码的作用域设置到一个特定的对象中。 </li>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> qs = location.search.substring(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> hostName = location.hostname;</span><br><span class="line"><span class="keyword">var</span> url = location.href;</span><br><span class="line"><span class="comment">// 上面几行代码都包含 location 对象。如果使用 with 语句，可以把上面的代码改写成如下所示：</span></span><br><span class="line"><span class="keyword">with</span>(location) &#123;</span><br><span class="line">  <span class="keyword">var</span> qs = search.substring(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">var</span> hostName = hostname;</span><br><span class="line">  <span class="keyword">var</span> url = href;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在这个重写后的例子中，使用 with 语句关联了 location 对象。这意味着在 with 语句的代码块<br>内部，每个变量首先被认为是一个局部变量，而如果在局部环境中找不到该变量的定义，就会查询<br>location 对象中是否有同名的属性。如果发现了同名属性， 则以 location 对象属性的值作为变量的值</p>
</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li>ECMAScript 函数不介意传递进来多少个参数，也不在乎传进来参数是什么数据类型</li>
<li>在函数体内可以通过 arguments 对象来访问这个参数数组，从而获取传递给函数的每一个参数<ul>
<li>arguments.length 可以获得实参个数</li>
<li>它的值永远与对应命名参数的值保持同步。</li>
<li>没有传递值的命名参数将自动被赋予undefined 值。</li>
</ul>
</li>
<li>签名：接受的参数的类型和数量</li>
</ul>
<h2 id="基本类型和引用类型的值"><a href="#基本类型和引用类型的值" class="headerlink" title="基本类型和引用类型的值"></a>基本类型和引用类型的值</h2><ul>
<li>ECMAScript 变量可能包含两种不同数据类型的值：基本类型值和引用类型值。 基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。</li>
<li>基本数据类型： Undefined、 Null、 Boolean、 Number 和 String。这 5 种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。保存在栈中</li>
<li>引用类型的值是保存在内存中的对象。在操作对象时，实际上是在操作对象的引用而不是实际的对象。保存在堆中</li>
<li>如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制<br>到为新变量分配的位置上。当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另一个变量</li>
<li>传递参数<ul>
<li>ECMAScript 中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。基本类型值的传递如同基本类型变量的复制一样，而引用类型值的传递，则如同引用类型变量的复制一样。</li>
<li>在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数，或者用<br>ECMAScript 的概念来说，就是 arguments 对象中的一个元素）。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部</li>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  num += <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> result = addTen(count);</span><br><span class="line">alert(count); <span class="comment">//20，没有变化</span></span><br><span class="line">alert(result); <span class="comment">//30</span></span><br><span class="line"><span class="comment">// 个人理解，可以改写成</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 赋值成局部变量</span></span><br><span class="line">  <span class="comment">// 以把 ECMAScript 函数的参数想象成局部变量。</span></span><br><span class="line">  <span class="keyword">var</span> num = num</span><br><span class="line">  num += <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h2><ul>
<li>检测一个变量是不是基本数据类型<ul>
<li>typeof 检测基本数据类型，不能检查不 null</li>
<li>instanceof 检查引用类型</li>
</ul>
</li>
</ul>
<h2 id="执行环境及作用域"><a href="#执行环境及作用域" class="headerlink" title="执行环境及作用域"></a>执行环境及作用域</h2><ul>
<li>执行环境（也称为作用域）的类型总共只有两种：全局和局部（函数）</li>
<li>标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。如果在局部环境中找到了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味着该变量尚未声明。</li>
<li>内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性、有次序的。每个环境都<br>可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个<br>执行环境。</li>
<li>访问局部变量要比访问全局变量更快，因<br>为不用向上搜索作用域链</li>
<li>延长作用域链<ul>
<li>with 语句</li>
<li>try…catch</li>
</ul>
</li>
</ul>
<h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><ul>
<li>局部变量只在函数执行的过程中存在。然后在函数中使用这些变量，直至函数执行结束。此时，局部变量就没有存在的必要了，因此可以释放它们的内存以供将来使用。垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。</li>
<li>分类<ul>
<li>标记清除<ul>
<li>给当前不使用的值加上标记，然后再回收其内存</li>
</ul>
</li>
<li>引用计数（不常用）<ul>
<li>循环引用</li>
</ul>
</li>
</ul>
</li>
<li>一旦数据不再有用，最好通过将其值设置为 null 来释放其引用——这个做法叫做解除引用（dereferencing）。</li>
</ul>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><h2 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h2><ul>
<li>在通过对象字面量定义对象时，实际上不会调用 Object 构造函数</li>
</ul>
<h2 id="Array-类型"><a href="#Array-类型" class="headerlink" title="Array 类型"></a>Array 类型</h2><ul>
<li>检测数组：Array.isArray</li>
<li>调用数组的 toString() 方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。</li>
<li>alert() 要接收字符串参数，所以它会在后台调用 toString() 方法，由此会得到与直接调用 toString() 方法相同的结果。</li>
<li>数组可以用来模拟栈和队列，栈：后进先出。队列：先进先出</li>
<li>sort 方法：<ul>
<li>在默认情况下， sort() 方法按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。为了实现排序， sort() 方法会调用每个数组项的 toString() 转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值， sort() 方法比较的也是字符串</li>
<li>sort() 方法可以接收一个比较函数作为参数。比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回 0，如果第一个参数应该位于第二个之后则返回一个正数。</li>
</ul>
</li>
<li>splice 方法：<ul>
<li>删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。例如， splice(0,2) 会删除数组中的前两项。</li>
<li>插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。例如，splice(2,0,”red”,”green”) 会从当前数组的位置 2 开始插入字符串”red”和”green”。</li>
<li>替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，splice (2,1,”red”,”green”) 会删除当前数组位置 2 的项，然后再从位置 2 开始插入字符串”red”和”green”。</li>
</ul>
</li>
</ul>
<h2 id="Function-类型"><a href="#Function-类型" class="headerlink" title="Function 类型"></a>Function 类型</h2><ul>
<li>不推荐使用 Function 构造函数定义函数，因为这种语<br>法会导致解析两次代码（第一次是解析常规 ECMAScript 代码，第二次是解析传入构造函数中的字符串），从而影响性能。</li>
<li>解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行</li>
<li>arguments 的主要用途是保存函数参数，但这个对象还有一个名叫 callee 的属性，该属性是一个指针，指向拥有这个 arguments 对象的函数。</li>
<li>每个函数都包含两个属性： length 和 prototype。其中， length 属性表示函数希望接收的命名参数的个数</li>
</ul>
<h2 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h2><p>ECMAScript 提供了 3 个特殊的引用类型： Boolean、 Number 和 String。</p>
<p>实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">"some text"</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p>这个例子中的变量 s1 包含一个字符串，字符串当然是基本类型值。而下一行调用了 s1 的 substring() 方法，并将返回的结果保存在了 s2 中。我们知道，基本类型值不是对象，因而从逻辑上讲它们不应该有方法（尽管如我们所愿，它们确实有方法）。</p>
<p>其实，为了让我们实现这种直观的操作，后台已经自动完成了一系列的处理。当第二行代码访问 s1 时，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台都会自动完成下列处理<br>(1) 创建 String 类型的一个实例；<br>(2) 在实例上调用指定的方法；<br>(3) 销毁这个实例。<br>可以将以上三个步骤想象成是执行了下列 ECMAScript 代码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"some text"</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">2</span>);</span><br><span class="line">s1 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></p>
<p>经过此番处理，基本的字符串值就变得跟对象一样了。而且，上面这三个步骤也分别适用于 Boolean 和 Number 类型对应的布尔值和数字值。</p>
<p>自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。</p>
<ul>
<li>Number 类型<ul>
<li>toString 方法：传递一个表示基数的参数，告诉它返回几进制字符串格式</li>
<li>toFixed: 按照指定的小数位返回数值的字符串</li>
</ul>
</li>
<li>String 类型<ul>
<li>charAt() 方法：返回给定位置的那个字符</li>
<li>charCodeAt()：返回指定位置字字符编码</li>
<li>concat()： 用于将一或多个字符串拼接起来，返回拼接得到的新字符串</li>
<li>substr：第二个参数指定的则是返回的字符个数</li>
</ul>
</li>
</ul>
<h2 id="Global-对象"><a href="#Global-对象" class="headerlink" title="Global 对象"></a>Global 对象</h2><ul>
<li>encodeURI() 和 encodeURIComponent()</li>
</ul>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ul>
<li>Object.defineProperty()<ul>
<li>修改属性默认的特性</li>
<li>可以多次调用 Object.defineProperty() 方法修改同一个属性，但在把 configurable 特性设置为 false 之后就会有限制了。</li>
<li>访问器属性：getter 和 setter</li>
</ul>
</li>
<li>Object.defineProperties()</li>
<li>Object.getOwnPropertyDescriptor</li>
<li><p>创建对象</p>
<ul>
<li><p>工厂模式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.job = job;</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数模式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>以这种方式调用构造函数实际上会经历以下 4 个步骤：<br>(1) 创建一个新对象；<br>(2) 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；<br>(3) 执行构造函数中的代码（为这个新对象添加属性）；<br>(4) 返回新对象。</li>
<li>使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍</li>
</ul>
</li>
<li><p>原型模式</p>
<ul>
<li>每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向一个对象，包含所有实例共享的属性和方法。所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性指向 prototype 属性所在函数</li>
<li>实例自身有一个 [[Prototype]]，可以通过 <strong>proto</strong> 访问其构造函数的 prototype （原型对象）<br>isPrototypeOf，Object.getPrototypeOf 可以用来判断原型对象</li>
<li>每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。</li>
<li>无论该属性存在于实例中还是存在于原型中，调用 in 始终都返回 true， 使用 hasOwnProperty() 方法可以检测一个属性是存在于实例中，还是存在于原型中。</li>
<li>要取得对象上所有可枚举的实例属性，不包含原型上的，可以使用 Object.keys() 方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>组合使用构造函数模式和原型模式</p>
</li>
<li><p>动态原型模式</p>
</li>
<li><p>寄生构造函数模式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.job = job;</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul>
<li>原型链<ul>
<li>其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法</li>
<li>实现的本质是重写原型对象，代之以一个新类型的实例。</li>
<li>所有函数的默认原型都是 Object 的实例，因此默认原型都会包含一个内部指针，指向 Object.prototype。</li>
<li>确定原型和实例的关系<ul>
<li>instanceof 操作符</li>
<li>isPrototypeOf() 方法</li>
</ul>
</li>
</ul>
</li>
<li><p>借用构造函数</p>
<ul>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 继承了 SuperType</span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance2.colors); <span class="comment">//"red,blue,green"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>组合继承</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 继承属性</span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h2><ul>
<li>通过 name 属性可以访问到给函数指定的名字</li>
<li>函数声明提升：可以把函数声明放在调用它的语句后面。</li>
</ul>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><ul>
<li>递归函数是在一个函数通过名字调用自身的情况下构成的</li>
<li>arguments.callee 是一个指向正在执行的函数的指针，因此可以用它来实现对函数的递归调用</li>
</ul>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul>
<li>闭包是指有权访问另一个函数作用域中的变量的函数</li>
<li>在函数执行过程中，为读取和写入变量的值，就需要在作用域链中查找变量。</li>
<li><a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html</a></li>
</ul>
<h2 id="模块模式（单例模式）"><a href="#模块模式（单例模式）" class="headerlink" title="模块模式（单例模式）"></a>模块模式（单例模式）</h2><ul>
<li>指的就是只有一个实例的对象</li>
<li>模块模式通过为单例添加私有变量和特权方法能够使其得到增强<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">  <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 特权 / 公有方法和属性</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    publicProperty: <span class="literal">true</span>,</span><br><span class="line">    publicMethod : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      privateVariable++;</span><br><span class="line">      <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h2><h2 id="兼容"><a href="#兼容" class="headerlink" title="兼容"></a>兼容</h2><ul>
<li>IE10/IE11 部分支持</li>
<li>new ActiveXObject(“Microsoft.XMLHTTP”)</li>
</ul>
<h3 id="XHR-的用法"><a href="#XHR-的用法" class="headerlink" title="XHR 的用法"></a>XHR 的用法</h3><ul>
<li>创建 xhr 对象 var xhr = new XMLHttpRequest();</li>
<li>xhr.open(“get”, “example.php”, false);<ul>
<li>接受 3 个参数：要发送的请求的类型（”get”、 “post”等） 、请求的 URL 和表示是否异步发送请求的布尔值</li>
<li>URL 相对于执行代码的当前页面（当然也可以使用绝对路径）</li>
<li>调用 open() 方法并不会真正发送请求，而只是启动一个请求以备发送</li>
</ul>
</li>
<li>xhr.send(null);<ul>
<li>这里的 send() 方法接收一个参数，即要作为请求主体发送的数据。如果不需要通过请求主体发送数据，则必须传入 null</li>
</ul>
</li>
<li>xhr.setRequestHeader<ul>
<li>可以设置自定义的请求头部信息</li>
</ul>
</li>
<li>响应<ul>
<li>readyState<ul>
<li>表示请求 / 响应过程的当前活动阶段</li>
<li>0：未初始化。尚未调用 open() 方法。</li>
<li>1：启动。已经调用 open() 方法，但尚未调用 send() 方法。</li>
<li>2：发送。已经调用 send() 方法，但尚未接收到响应。</li>
<li>3：接收。已经接收到部分响应数据。</li>
<li>4：完成。已经接收到全部响应数据，而且已经可以在客户端使用了。</li>
<li>只要 readyState 属性的值由一个值变成另一个值，都会触发一次 readystatechange 事件。</li>
</ul>
</li>
<li>responseText：作为响应主体被返回的文本。</li>
<li>responseXML：如果响应的内容类型是”text/xml”或”application/xml”，这个属性中将保存包含着响应数据的 XML DOM 文档。</li>
<li>status：响应的 HTTP 状态。</li>
<li>statusText： HTTP 状态的说明</li>
</ul>
</li>
</ul>
<h3 id="GET-请求"><a href="#GET-请求" class="headerlink" title="GET 请求"></a>GET 请求</h3><ul>
<li>查询字符串中每个参数的名称和值都必须使用 encodeURIComponent() 进行编码，然后才能放到 URL 的末尾</li>
</ul>
<h3 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h3><ul>
<li>使用 XHR 来模仿表单提交：首先将 Content-Type 头部信息设置为 application/x-www-form-urlencoded，</li>
</ul>
<h2 id="XMLHttpRequest-2-级"><a href="#XMLHttpRequest-2-级" class="headerlink" title="XMLHttpRequest 2 级"></a>XMLHttpRequest 2 级</h2><ul>
<li><p>FormData</p>
<ul>
<li>append() 方法接收两个参数：键和值<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> FormData();</span><br><span class="line">data.append(<span class="string">"name"</span>, <span class="string">"Nicholas"</span>);</span><br><span class="line">xhr.send(data);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>超时设定</p>
<ul>
<li>表示请求在等待响应多少毫秒之后就终止</li>
<li>在给 timeout 设置一个数值后，如果在规定的时间内浏览器还没有接收到响应，那么就会触发 timeout 事件，进而会调用 ontimeout 事件处理程序<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xhr.timeout = <span class="number">1000</span>; <span class="comment">// 将超时设置为 1 秒钟（仅适用于 IE8+）</span></span><br><span class="line">xhr.ontimeout = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">"Request did not return in a second."</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>overrideMimeType() 方法</p>
<ul>
<li>重写 XHR 响应的 MIME 类型</li>
<li>调用 overrideMimeType() 必须在 send() 方法之前，才能保证重写响应的 MIME 类 xhr.overrideMimeType(“text/xml”);</li>
</ul>
</li>
</ul>
<h2 id="进度事件"><a href="#进度事件" class="headerlink" title="进度事件"></a>进度事件</h2><ul>
<li><p>load 事件</p>
<ul>
<li>响应接收完毕后将触发 load 事件，因此也就没有必要去检查 readyState 属性了<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = createXHR();</span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>)&#123;</span><br><span class="line">  alert(xhr.responseText);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  alert(<span class="string">"Request was unsuccessful: "</span> + xhr.status);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"altevents.php"</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>progress 事件</p>
<ul>
<li>这个事件会在浏览器接收新数据期间周期性地触发</li>
<li>lengthComputable 是一个表示进度信息是否可用的布尔值， position 表示已经接收的字节数， totalSize 表示根据 Content-Length 响应头部确定的预期字节数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xhr.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> divStatus = <span class="built_in">document</span>.getElementById(<span class="string">"status"</span>);</span><br><span class="line"><span class="keyword">if</span> (event.lengthComputable)&#123;</span><br><span class="line">  divStatus.innerHTML = <span class="string">"Received "</span> + event.position + <span class="string">" of "</span> +</span><br><span class="line">  event.totalSize +<span class="string">" bytes"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="长轮询是传统轮询（也称为短轮询）的一个翻版，即浏览器定时向服务器发送请求，看有没有更新的数据"><a href="#长轮询是传统轮询（也称为短轮询）的一个翻版，即浏览器定时向服务器发送请求，看有没有更新的数据" class="headerlink" title="长轮询是传统轮询（也称为短轮询）的一个翻版，即浏览器定时向服务器发送请求，看有没有更新的数据"></a>长轮询是传统轮询（也称为短轮询）的一个翻版，即浏览器定时向服务器发送请求，看有没有更新的数据</h2><h2 id="Web-Sockets"><a href="#Web-Sockets" class="headerlink" title="Web Sockets"></a>Web Sockets</h2><ul>
<li>Web Sockets API<ul>
<li>var socket = new WebSocket(“ws://www.example.com/server.php”);<br>必须给 WebSocket 构造函数传入绝对 URL。</li>
</ul>
</li>
<li>发送和接收数据<ul>
<li>socket.send(“Hello world!”)</li>
<li>Web Sockets 只能通过连接发送纯文本数据，所以对于复杂的数据结构，在通过连接发送之前，必须进行序列化</li>
<li>当服务器向客户端发来消息时， WebSocket 对象就会触发 message 事件</li>
</ul>
</li>
<li>其他事件<ul>
<li>open，error，close</li>
<li>WebSocket 对象不支持 DOM 2 级事件侦听器，因此必须使用 DOM 0 级语法分别定义每个事件处（onopen）</li>
</ul>
</li>
</ul>
<h2 id="事-件"><a href="#事-件" class="headerlink" title="事 件"></a>事 件</h2><h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><ul>
<li>事件流描述的是从页面中接收事件的顺序<ul>
<li>分类<ul>
<li>IE 的事件流是事件冒泡流</li>
<li>Netscape Communicator 的事件流是事件捕获流</li>
</ul>
</li>
</ul>
</li>
<li>事件冒泡<ul>
<li>IE 的事件流叫做事件冒泡（event bubbling），即事件开始时由最具体的元素（可以认为是你点击的那个元素）接收，然后逐级向上传播到较为不具体的节点（文档）</li>
</ul>
</li>
<li>事件捕获<ul>
<li>事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件</li>
</ul>
</li>
<li>DOM 事件流<ul>
<li>“DOM2 级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。</li>
</ul>
</li>
</ul>
<h3 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h3><ul>
<li>响应某个事件的函数就叫做事件处理程序（或事件侦听器）。事件处理程序的名字以”on”开头</li>
<li>HTML 事件处理程序<ul>
<li><input type="button" value="Click Me" onclick="alert('Clicked')"></li>
<li><input type="button" value="Click Me" onclick="showMessage()"></li>
</ul>
</li>
<li><p>DOM0 级事件处理程序</p>
<ul>
<li>通过 JavaScript 指定事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性</li>
<li><p>每个元素（包括 window 和 document）都有自己的事件处理程序属性，这些属性通常全部小写</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">"Clicked"</span>);</span><br><span class="line">  alert(<span class="keyword">this</span>.id);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>程序中的 this 引用当前元素</p>
</li>
<li>删除通过 DOM0 级方法指定的事件处理程序只要将事件处理程序属性的值设置为 null 即可</li>
</ul>
</li>
<li><p>DOM2 级事件处理程序</p>
<ul>
<li>定义了两个方法，用于处理指定和删除事件处理程序的操作： addEventListener() 和 removeEventListener()。</li>
<li>接受 3 个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是 true，表示在捕获阶段调用事件处理程序；如果是 false，表示在冒泡阶段调用事件处理程序</li>
<li>程序中的 this 引用当前元素</li>
<li>使用 DOM2 级方法添加事件处理程序的主要好处是可以添加多个事件处理程序</li>
<li>通过 addEventListener() 添加的匿名函数将无法移除</li>
</ul>
</li>
<li><p>IE 事件处理程序</p>
<ul>
<li>IE 实现了与 DOM 中类似的两个方法： attachEvent() 和 detachEvent()。</li>
<li>这两个方法接受相同的两个参数：事件处理程序名称与事件处理程序函数。</li>
<li>由于 IE8 及更早版本只支持事件冒泡，所以通过 attachEvent() 添加的事件处理程序都会被添加到冒泡阶段</li>
<li>attachEvent() 的第一个参数是”onclick”</li>
<li>在使用 attachEvent() 方法的情况下，事件处理程序会在全局作用域中运行，因此 this 等于 window</li>
</ul>
</li>
</ul>
<h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><ul>
<li><p>DOM 中的事件对象</p>
<ul>
<li>无论指定事件处理程序时使用什么方法（DOM0 级或 DOM2 级） ，都会传入 event 对象</li>
<li>在事件处理程序内部，对象 this 始终等于 currentTarget 的值（就是当前这个元素），而 target 则只包含事件的实际目标（真正触发的目标)</li>
<li>在需要通过一个函数处理多个事件时，可以使用 type 属性</li>
<li>要阻止特定事件的默认行为，可以使用 preventDefault() 方法<ul>
<li>链接的默认行为就是在被单击时会导航到其 href 特性指定的 URL</li>
</ul>
</li>
<li>stopPropagation() 方法用于立即停止事件在 DOM 层次中的传播，即取消进一步的事件捕获或冒泡</li>
<li>事件对象的 eventPhase 属性，可以用来确定事件当前正位于事件流的哪个阶段。<ul>
<li>在捕获阶段 eventPhase 等于 1；处于目标对象上 eventPhase 等于 2；冒泡阶段 eventPhase 等于 3。</li>
</ul>
</li>
</ul>
</li>
<li><p>IE 中的事件对象</p>
<ul>
<li>在使用 DOM0 级方法添加事件处理程序时， event 对象作为 window 对象的一个属性存在，可是，如果事件处理程序是使用 attachEvent() 添加的，那么就会有一个 event 对象作为参数被传入事件处理程序函数中</li>
<li>returnValue 属性相当于 DOM 中的 preventDefault() 方法，它们的作用都是取消给定事件的默认行为。</li>
<li>cancelBubble 属性与 DOM 中的 stopPropagation() 方法作用相同，都是用来停止事件冒泡的</li>
</ul>
</li>
</ul>
<h3 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h3><ul>
<li><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3></li>
<li>事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件<ul>
<li>整个页面占用的内存空间更少，能够提升整体性能。</li>
</ul>
</li>
</ul>
<h3 id="移除事件处理程序"><a href="#移除事件处理程序" class="headerlink" title="移除事件处理程序"></a>移除事件处理程序</h3><ul>
<li>如果你知道某个元素即将被移除，那么最好手工移除事件处理程序</li>
</ul>
<h3 id="模拟事件"><a href="#模拟事件" class="headerlink" title="模拟事件"></a>模拟事件</h3><ul>
<li>DOM 中的事件模拟</li>
</ul>
<h2 id="不在块中定义函数时，先提升函数，再提升变量声明。"><a href="#不在块中定义函数时，先提升函数，再提升变量声明。" class="headerlink" title="不在块中定义函数时，先提升函数，再提升变量声明。"></a>不在块中定义函数时，先提升函数，再提升变量声明。</h2><h2 id="React-相关"><a href="#React-相关" class="headerlink" title="React 相关"></a>React 相关</h2><ul>
<li>setState<ul>
<li>不会立刻改变 React 组件中 state 的值；<ul>
<li>render 函数被重新执行时 this.state 才被改变。</li>
</ul>
</li>
<li>多次 setState 函数调用产生的效果会合并。</li>
<li>setState 通过引发一次组件的更新过程来引发重新绘制；</li>
<li>同步更新 state 的方法<ul>
<li>传递给 this.setState 一个函数</li>
<li>在React中，如果是由React引发的事件处理（比如通过onClick引发的事件处理），调用setState不会同步更新this.state，除此之外的setState调用会同步执行this.state。所谓“除此之外”，指的是绕过React通过addEventListener直接添加的事件处理函数，还有通过setTimeout/setInterval产生的异步调用。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>每个函数都有一个属性叫做prototype。</li>
<li>这个prototype的属性值是一个对象（属性的集合，再次强调！），默认的只有一个叫做constructor的属性，指向这个函数本身。</li>
<li>每个对象都有一个隐藏的属性——“<strong>proto</strong>”，这个属性引用了创建这个对象的函数的prototype。即：fn.<strong>proto</strong> === Fn.prototype。这里的”<strong>proto</strong>“成为“隐式原型”</li>
<li>Instanceof运算符的第一个变量是一个对象，暂时称为A；第二个变量一般是一个函数，暂时称为B。<br>Instanceof的判断队则是：沿着A的<strong>proto</strong>这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。</li>
</ul>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>Author: </span>
      <a href="http://yoursite.com">我是你豆子欧巴</a>
    </p>
    <p class="copyright-item">
      <span>Link: </span>
      <a href="http://yoursite.com/2018/01/23/面试整理-JavaScript-篇/">http://yoursite.com/2018/01/23/面试整理-JavaScript-篇/</a>
    </p>
    <p class="copyright-item">
      <span>License: </span>
      
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>



      
      
    

    
      <footer class="post-footer">
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2018/01/25/for-in-循环顺序的问题/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">for in 循环顺序的问题</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/2018/01/02/二分查找/">
        <span class="next-text nav-default">二分查找</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    
    
      
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2018

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">我是你豆子欧巴</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  



    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  </body>
</html>
